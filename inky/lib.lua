-- Generated by Haxe 3.4.7
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function()
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function()
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function()
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function()
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();


local _hx_exports = _hx_exports or {}
_hx_exports["ink"] = _hx_exports["ink"] or _hx_e()
_hx_exports["ink"]["runtime"] = _hx_exports["ink"]["runtime"] or _hx_e()
local _estr = function(self) return lua.Boot.__string_rec(self,''); end
local Array = _hx_e()
local Date = _hx_e()
local lua = {}
lua.lib = {}
lua.lib.lrexlib = {}
lua.lib.lrexlib.Rex = _G.require("inky.rex_pcre")
local EReg = _hx_e()
local InkRuntime = _hx_e()
local IntIterator = _hx_e()
local Lambda = _hx_e()
local List = _hx_e()
local _List = {}
_List.ListNode = _hx_e()
_List.ListIterator = _hx_e()
local _Map = {}
_Map.Map_Impl_ = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local Sys = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
local haxe = {}
haxe.IMap = _hx_e()
haxe._Int32 = {}
haxe._Int32.Int32_Impl_ = _hx_e()
haxe._Int64 = {}
haxe._Int64.Int64_Impl_ = _hx_e()
haxe._Int64.___Int64 = _hx_e()
haxe.Int64Helper = _hx_e()
haxe.Json = _hx_e()
haxe.Log = _hx_e()
haxe.ds = {}
haxe.ds.BalancedTree = _hx_e()
haxe.ds.TreeNode = _hx_e()
haxe.ds.EnumValueMap = _hx_e()
haxe.ds.GenericCell = _hx_e()
haxe.ds.GenericStack = _hx_e()
haxe.ds._HashMap = {}
haxe.ds._HashMap.HashMap_Impl_ = _hx_e()
haxe.ds._HashMap.HashMapData = _hx_e()
haxe.ds.IntMap = _hx_e()
haxe.ds.ObjectMap = _hx_e()
haxe.ds.StringMap = _hx_e()
haxe.ds.WeakMap = _hx_e()
haxe.format = {}
haxe.format.JsonParser = _hx_e()
haxe.format.JsonPrinter = _hx_e()
haxe.io = {}
haxe.io.Bytes = _hx_e()
haxe.io.BytesBuffer = _hx_e()
haxe.io.Input = _hx_e()
haxe.io.BytesInput = _hx_e()
haxe.io.Eof = _hx_e()
haxe.io.Error = _hx_e()
haxe.io.FPHelper = _hx_e()
haxe.io.Output = _hx_e()
haxe.io.Path = _hx_e()
haxe.macro = {}
haxe.macro.Compiler = _hx_e()
haxe.macro.Constant = _hx_e()
haxe.macro.Binop = _hx_e()
haxe.macro.Unop = _hx_e()
haxe.macro.ExprDef = _hx_e()
haxe.macro.ComplexType = _hx_e()
haxe.macro.TypeParam = _hx_e()
haxe.macro.Access = _hx_e()
haxe.macro.FieldType = _hx_e()
haxe.macro.TypeDefKind = _hx_e()
haxe.macro.Error = _hx_e()
haxe.macro.ImportMode = _hx_e()
local ink = {}
ink.random = {}
ink.random.RNG = _hx_e()
ink.random.ParkMiller = _hx_e()
ink.random.Limits = _hx_e()
ink.runtime = {}
ink.runtime.Assert = _hx_e()
ink.runtime.CallStack = _hx_e()
ink.runtime.Element = _hx_e()
ink.runtime.Thread = _hx_e()
ink.runtime.RObject = _hx_e()
ink.runtime.Choice = _hx_e()
ink.runtime.ChoicePoint = _hx_e()
ink.runtime.Cloner = _hx_e()
ink.runtime.CountFlags = _hx_e()
ink.runtime.INamedContent = _hx_e()
ink.runtime.Container = _hx_e()
ink.runtime.ControlCommand = _hx_e()
ink.runtime.DebugMetadata = _hx_e()
ink.runtime.Divert = _hx_e()
ink.runtime.GlueType = _hx_e()
ink.runtime.Glue = _hx_e()
ink.runtime.HashSet = _hx_e()
ink.runtime.HashSetString = _hx_e()
ink.runtime.IEquatable = _hx_e()
ink.runtime.IProxy = _hx_e()
ink.runtime.SystemException = _hx_e()
ink.runtime.Json = _hx_e()
ink.runtime.LibUtil = _hx_e()
ink.runtime.MapCloner = _hx_e()
ink.runtime.NativeFunctionCall = _hx_e()
ink.runtime.Path = _hx_e()
ink.runtime.Component = _hx_e()
ink.runtime.Story = _hx_e()
ink.runtime.StoryException = _hx_e()
ink.runtime.SystemNotImplementedException = _hx_e()
ink.runtime.StoryState = _hx_e()
ink.runtime.Value = _hx_e()
ink.runtime.IntValue = _hx_e()
ink.runtime.FloatValue = _hx_e()
ink.runtime.StringValue = _hx_e()
ink.runtime.DivertTargetValue = _hx_e()
ink.runtime.VariablePointerValue = _hx_e()
ink.runtime.VariableAssignment = _hx_e()
ink.runtime.VariableReference = _hx_e()
ink.runtime.VariablesState = _hx_e()
ink.runtime.VoidObj = _hx_e()
ink.runtime.js = {}
ink.runtime.js.JSProxyTrap = _hx_e()
lua.Boot = _hx_e()
lua.UserData = _hx_e()
lua.HaxeIterator = _hx_e()
lua._Io = {}
lua._Io.IoType_Impl_ = _hx_e()
lua.Lib = _hx_e()
lua._NativeIterator = {}
lua._NativeIterator.NativeIterator_Impl_ = _hx_e()
lua.Thread = _hx_e()
lua.lib.environ = {}

lua.lib.environ.Environ = _G.require("inky.environ.process")
lua.lib.luasocket = {}
lua.lib.luasocket.Socket = _G.require("socket")
lua.lib.luv = {}
lua.lib.luv.Handle = _G.require("inky.luv")
lua.lib.luv.Loop = _G.require("inky.luv")
lua.lib.luv.Misc = _G.require("inky.luv")
lua.lib.luv.Stream = _G.require("inky.luv")
lua.lib.luv.Pipe = _G.require("inky.luv")
lua.lib.luv.Process = _G.require("inky.luv")
lua.lib.luv.Request = _G.require("inky.luv")
lua.lib.luv.Signal = _G.require("inky.luv")
lua.lib.luv.Thread = _G.require("inky.luv")
lua.lib.luv.Timer = _G.require("inky.luv")
lua.lib.luv.fs = {}
lua.lib.luv.fs.FileSystem = _G.require("inky.luv")
lua.lib.luv.net = {}
lua.lib.luv.net.Tcp = _G.require("inky.luv")
local sys = {}
sys.FileSystem = _hx_e()
sys.io = {}
sys.io.FileInput = _hx_e()
sys.io.FileOutput = _hx_e()
sys.io.FileSeek = _hx_e()
sys.io.Process = _hx_e()
sys.io.ProcessInput = _hx_e()
sys.io.ProcessOutput = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = function()
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self)
  _hx_tab_array(self,0);
end
_hxClasses["Array"] = Array
Array.__name__ = {"Array"}
Array.prototype = _hx_a(
  'length', nil,
  'concat', function(self,a)
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(i);
      end;
    local ret = _g;
    local _g3 = 0;
    while (_g3 < a.length) do
      local i1 = a[_g3];
      _g3 = _g3 + 1;
      ret:push(i1);
      end;
    do return ret end
  end,
  'join', function(self,sep)
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self)
      do return cur_length < _gthis.length end;
    end,next=function(self)
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'pop', function(self)
    if (self.length == 0) then
      do return nil end;
    end;
    local rawlength = _G.rawget(self,"length");
    local ret = _G.rawget(self,rawlength - 1);
    _G.rawset(self,"length",rawlength - 1);
    do return ret end
  end,
  'push', function(self,x)
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'reverse', function(self)
    local tmp;
    local i = 0;
    while (i < Std.int(self.length / 2)) do
      tmp = self[i];
      self[i] = self[(self.length - i) - 1];
      self[(self.length - i) - 1] = tmp;
      i = i + 1;
      end;
  end,
  'shift', function(self)
    if (self.length == 0) then
      do return nil end;
    end;
    local ret = self[0];
    local _g1 = 0;
    local _g = self.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[i] = self[i + 1];
      end;
    local tmp = self;
    tmp.length = tmp.length - 1;
    do return ret end
  end,
  'slice', function(self,pos,_end)
    if ((_end == nil) or (_end > self.length)) then
      _end = self.length;
    else
      if (_end < 0) then
        _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
      end;
    end;
    if (pos < 0) then
      pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
    end;
    if ((pos > _end) or (pos > self.length)) then
      do return _hx_tab_array({ }, 0) end;
    end;
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = _end;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      end;
    do return ret end
  end,
  'sort', function(self,f)
    local i = 0;
    local l = self.length;
    while (i < l) do
      local swap = false;
      local j = 0;
      local max = (l - i) - 1;
      while (j < max) do
        if (f(self[j],self[j + 1]) > 0) then
          local tmp = self[j + 1];
          self[j + 1] = self[j];
          self[j] = tmp;
          swap = true;
        end;
        j = j + 1;
        end;
      if (not swap) then
        break;
      end;
      i = i + 1;
      end;
  end,
  'splice', function(self,pos,len)
    if ((len < 0) or (pos > self.length)) then
      do return _hx_tab_array({ }, 0) end;
    else
      if (pos < 0) then
        pos = self.length - (_G.math.fmod(-pos, self.length));
      end;
    end;
    local b = self.length - pos;
    len = (function()
      local _hx_1
      if (Math.isNaN(len) or Math.isNaN(b)) then
      _hx_1 = (0/0); else
      _hx_1 = _G.math.min(len,b); end
      return _hx_1
    end )();
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = pos + len;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      self[i] = self[i + len];
      end;
    local _g11 = pos + len;
    local _g2 = self.length;
    while (_g11 < _g2) do
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      self[i1] = self[i1 + len];
      end;
    local tmp = self;
    tmp.length = tmp.length - len;
    do return ret end
  end,
  'toString', function(self)
    local tbl = ({});
    _G.table.insert(tbl,"[");
    _G.table.insert(tbl,self:join(","));
    _G.table.insert(tbl,"]");
    do return _G.table.concat(tbl,"") end
  end,
  'unshift', function(self,x)
    local len = self.length;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[len - i] = self[(len - i) - 1];
      end;
    self[0] = x;
  end,
  'insert', function(self,pos,x)
    if (pos > self.length) then
      pos = self.length;
    end;
    if (pos < 0) then
      pos = self.length + pos;
      if (pos < 0) then
        pos = 0;
      end;
    end;
    local cur_len = self.length;
    while (cur_len > pos) do
      self[cur_len] = self[cur_len - 1];
      cur_len = cur_len - 1;
      end;
    self[pos] = x;
  end,
  'remove', function(self,x)
    local _g1 = 0;
    local _g = self.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (self[i] == x) then
        local _g3 = i;
        local _g2 = self.length - 1;
        while (_g3 < _g2) do
          _g3 = _g3 + 1;
          local j = _g3 - 1;
          self[j] = self[j + 1];
          end;
        self[self.length - 1] = nil;
        self.length = self.length - 1;
        do return true end;
      end;
      end;
    do return false end
  end,
  'indexOf', function(self,x,fromIndex)
    local _end = self.length;
    if (fromIndex == nil) then
      fromIndex = 0;
    else
      if (fromIndex < 0) then
        fromIndex = self.length + fromIndex;
        if (fromIndex < 0) then
          fromIndex = 0;
        end;
      end;
    end;
    local _g1 = fromIndex;
    local _g = _end;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (x == self[i]) then
        do return i end;
      end;
      end;
    do return -1 end
  end,
  'lastIndexOf', function(self,x,fromIndex)
    if ((fromIndex == nil) or (fromIndex >= self.length)) then
      fromIndex = self.length - 1;
    else
      if (fromIndex < 0) then
        fromIndex = self.length + fromIndex;
        if (fromIndex < 0) then
          do return -1 end;
        end;
      end;
    end;
    local i = fromIndex;
    while (i >= 0) do
      if (self[i] == x) then
        do return i end;
      else
        i = i - 1;
      end;
      end;
    do return -1 end
  end,
  'copy', function(self)
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(i);
      end;
    do return _g end
  end,
  'map', function(self,f)
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(f(i));
      end;
    do return _g end
  end,
  'filter', function(self,f)
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      if (f(i)) then
        _g:push(i);
      end;
      end;
    do return _g end
  end,
  'iterator', function(self)
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self)
      do return cur_length < _gthis.length end;
    end,next=function(self)
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
  ,'__class__',  Array
)

Date.new = function(year,month,day,hour,min,sec)
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec)
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t",self.t);
end
_hxClasses["Date"] = Date
Date.__name__ = {"Date"}
Date.now = function()
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t",Std.int(d.t));
  do return d end;
end
Date.fromTime = function(t)
  local d = _hx_e();
  _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t",Std.int(d.t));
  do return d end;
end
Date.fromString = function(s)
  do return lua.Boot.strDate(s) end;
end
Date.prototype = _hx_a(
  'd', nil,
  't', nil,
  'getTime', function(self)
    do return self.t * 1000 end
  end,
  'getHours', function(self)
    do return self.d.hour end
  end,
  'getMinutes', function(self)
    do return self.d.min end
  end,
  'getSeconds', function(self)
    do return self.d.sec end
  end,
  'getFullYear', function(self)
    do return self.d.year end
  end,
  'getMonth', function(self)
    do return self.d.month - 1 end
  end,
  'getDate', function(self)
    do return self.d.day end
  end,
  'getDay', function(self)
    do return self.d.wday - 1 end
  end,
  'toString', function(self)
    do return lua.Boot.dateStr(self) end
  end
  ,'__class__',  Date
)

EReg.new = function(r,opt)
  local self = _hx_new(EReg.prototype)
  EReg.super(self,r,opt)
  return self
end
EReg.super = function(self,r,opt)
  local ropt = 0;
  local _g1 = 0;
  local _g = opt.length;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local _g2 = opt:charAt(i);
    local _g21 = _g2;
    if (_g21) == "g" then
      self.global = true;
    elseif (_g21) == "i" then
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.CASELESS);
    elseif (_g21) == "m" then
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.MULTILINE);
    elseif (_g21) == "s" then
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.DOTALL);
    elseif (_g21) == "u" then
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.UTF8);else end;
    end;
  if (self.global == nil) then
    self.global = false;
  end;
  self.r = lua.lib.lrexlib.Rex.new(r,ropt);
end
_hxClasses["EReg"] = EReg
EReg.__name__ = {"EReg"}
EReg.prototype = _hx_a(
  'r', nil,
  'global', nil,
  's', nil,
  'm', nil,
  'match', function(self,s)
    if (s == nil) then
      do return false end;
    end;
    self.m = _hx_table.pack(self.r:exec(s));
    self.s = s;
    do return self.m[1] ~= nil end
  end,
  'matched', function(self,n)
    if ((self.m[1] == nil) or (n < 0)) then
      _G.error("EReg::matched",0);
    else
      if (n == 0) then
        local k = _G.string.sub(self.s,self.m[1],self.m[2]);
        do return k end;
      else
        if (lua.Boot.__instanceof(self.m[3],_G.table)) then
          local mn = 2 * (n - 1);
          if (lua.Boot.__instanceof(self.m[3][mn + 1],Bool)) then
            do return nil end;
          end;
          do return _G.string.sub(self.s,self.m[3][mn + 1],self.m[3][mn + 2]) end;
        else
          _G.error("EReg:matched",0);
        end;
      end;
    end;
  end,
  'matchedLeft', function(self)
    if (self.m[1] == nil) then
      _G.error("No string matched",0);
    end;
    do return _G.string.sub(self.s,1,self.m[1] - 1) end
  end,
  'matchedRight', function(self)
    if (self.m[1] == nil) then
      _G.error("No string matched",0);
    end;
    do return _G.string.sub(self.s,self.m[2] + 1) end
  end,
  'matchedPos', function(self)
    if (self.m[1] == nil) then
      _G.error("No string matched",0);
    end;
    do return _hx_o({__fields__={pos=true,len=true},pos=self.m[1] - 1,len=(self.m[2] - self.m[1]) + 1}) end
  end,
  'matchSub', function(self,s,pos,len)
    if (len == nil) then
      len = -1;
    end;
    local ss = s:substr(0,(function()
      local _hx_1
      if (len < 0) then
      _hx_1 = s.length; else
      _hx_1 = pos + len; end
      return _hx_1
    end )());
    if (self.global) then
      self.m = _hx_table.pack(self.r:exec(ss,pos + 1));
      local b = self.m[1] ~= nil;
      if (b) then
        self.s = s;
      end;
      do return b end;
    else
      self.m = _hx_table.pack(self.r:exec(ss,pos + 1));
      local b1 = self.m[1] ~= nil;
      if (b1) then
        self.s = s;
      end;
      do return b1 end;
    end;
  end,
  'split', function(self,s)
    if (self.global) then
      do return lua.Lib.fillArray(lua.lib.lrexlib.Rex.split(s,self.r)) end;
    else
      local d = "#__delim__#";
      do return lua.Lib.fillArray(lua.lib.lrexlib.Rex.split(self:replace(s,d),d)) end;
    end;
  end,
  'replace', function(self,s,by)
    by = lua.lib.lrexlib.Rex.gsub(by,"\\$(\\d)","%%%1");
    by = lua.lib.lrexlib.Rex.gsub(by,"\\${2}","$");
    do return lua.lib.lrexlib.Rex.gsub(s,self.r,by,(function()
      local _hx_1
      if (self.global) then
      _hx_1 = nil; else
      _hx_1 = 1; end
      return _hx_1
    end )()) end
  end,
  'map', function(self,s,f)
    local offset = 0;
    local buf_length;
    local buf_b = _hx_e();
    buf_length = 0;
    while (true) do
      if (offset >= s.length) then
        break;
      else
        if (not self:matchSub(s,offset)) then
          local str = Std.string(s:substr(offset));
          _G.table.insert(buf_b,str);
          buf_length = buf_length + str.length;
          break;
        end;
      end;
      local p = self:matchedPos();
      local str1 = Std.string(s:substr(offset,p.pos - offset));
      _G.table.insert(buf_b,str1);
      buf_length = buf_length + str1.length;
      local str2 = Std.string(f(self));
      _G.table.insert(buf_b,str2);
      buf_length = buf_length + str2.length;
      if (p.len == 0) then
        local str3 = Std.string(s:substr(p.pos,1));
        _G.table.insert(buf_b,str3);
        buf_length = buf_length + str3.length;
        offset = p.pos + 1;
      else
        offset = p.pos + p.len;
      end;
      if (not self.global) then
        break;
      end;
      end;
    if ((not self.global and (offset > 0)) and (offset < s.length)) then
      local str4 = Std.string(s:substr(offset));
      _G.table.insert(buf_b,str4);
      buf_length = buf_length + str4.length;
    end;
    do return _G.table.concat(buf_b) end
  end
  ,'__class__',  EReg
)

local json = require("json")

InkRuntime.new = {}
_hxClasses["InkRuntime"] = InkRuntime
InkRuntime.__name__ = {"InkRuntime"}
InkRuntime.main = function()
  local story = ink.runtime.Story.new("{\"inkVersion\":12,\"root\":[[{\"->\":\"start\"},null],\"done\",{\"start\":[[\"^Hello world\",\"\\n\",[\"ev\",\"str\",{\"f()\":\".^.s\"},\"/str\",\"/ev\",{\"*\":\".^.c\",\"flg\":18},{\"s\":[\"^Hut 14.\",null],\"c\":[{\"f()\":\".^.^.s\"},\"\\n\",\"^The door was locked after I sat down.\",\"\\n\",\"end\",{\"#f\":5}]}],null],{\"#f\":3}],\"global decl\":[\"ev\",0,{\"VAR=\":\"forceful\"},0,{\"VAR=\":\"evasive\"},0,{\"VAR=\":\"teacup\"},0,{\"VAR=\":\"gotcomponent\"},0,{\"VAR=\":\"drugged\"},0,{\"VAR=\":\"hooper_mentioned\"},0,{\"VAR=\":\"losttemper\"},0,{\"VAR=\":\"admitblackmail\"},0,{\"VAR=\":\"hooperClueType\"},0,{\"VAR=\":\"hooperConfessed\"},0,{\"VAR=\":\"smashingWindowItem\"},0,{\"VAR=\":\"notraitor\"},0,{\"VAR=\":\"revealedhooperasculprit\"},0,{\"VAR=\":\"smashedglass\"},0,{\"VAR=\":\"muddyshoes\"},0,{\"VAR=\":\"framedhooper\"},0,{\"VAR=\":\"putcomponentintent\"},0,{\"VAR=\":\"throwncomponentaway\"},0,{\"VAR=\":\"piecereturned\"},0,{\"VAR=\":\"longgrasshooperframe\"},0,{\"VAR=\":\"DEBUG\"},\"/ev\",\"end\",null],\"#f\":3}]}");
  print(story:ToJsonString())
end

IntIterator.new = function(min,max)
  local self = _hx_new(IntIterator.prototype)
  IntIterator.super(self,min,max)
  return self
end
IntIterator.super = function(self,min,max)
  self.min = min;
  self.max = max;
end
_hxClasses["IntIterator"] = IntIterator
IntIterator.__name__ = {"IntIterator"}
IntIterator.prototype = _hx_a(
  'min', nil,
  'max', nil,
  'hasNext', function(self)
    do return self.min < self.max end
  end,
  'next', function(self)
    do return (function()
    local _hx_obj = self;
    local _hx_fld = 'min';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)() end
  end
  ,'__class__',  IntIterator
)

Lambda.new = {}
_hxClasses["Lambda"] = Lambda
Lambda.__name__ = {"Lambda"}
Lambda.array = function(it)
  local a = Array.new();
  local i = it:iterator();
  while (i:hasNext()) do
    local i1 = i:next();
    a:push(i1);
    end;
  do return a end;
end
Lambda.list = function(it)
  local l = List.new();
  local i = it:iterator();
  while (i:hasNext()) do
    local i1 = i:next();
    l:add(i1);
    end;
  do return l end;
end
Lambda.map = function(it,f)
  local l = List.new();
  local x = it:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    l:add(f(x1));
    end;
  do return l end;
end
Lambda.mapi = function(it,f)
  local l = List.new();
  local i = 0;
  local x = it:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    i = i + 1;
    l:add(f(i - 1,x1));
    end;
  do return l end;
end
Lambda.flatten = function(it)
  local l = List.new();
  local e = it:iterator();
  while (e:hasNext()) do
    local e1 = e:next();
    local x = e1:iterator();
    while (x:hasNext()) do
      local x1 = x:next();
      l:add(x1);
      end;
    end;
  do return l end;
end
Lambda.flatMap = function(it,f)
  do return Lambda.flatten(Lambda.map(it,f)) end;
end
Lambda.has = function(it,elt)
  local x = it:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    if (x1 == elt) then
      do return true end;
    end;
    end;
  do return false end;
end
Lambda.exists = function(it,f)
  local x = it:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    if (f(x1)) then
      do return true end;
    end;
    end;
  do return false end;
end
Lambda.foreach = function(it,f)
  local x = it:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    if (not f(x1)) then
      do return false end;
    end;
    end;
  do return true end;
end
Lambda.iter = function(it,f)
  local x = it:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    f(x1);
    end;
end
Lambda.filter = function(it,f)
  local l = List.new();
  local x = it:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    if (f(x1)) then
      l:add(x1);
    end;
    end;
  do return l end;
end
Lambda.fold = function(it,f,first)
  local x = it:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    first = f(x1,first);
    end;
  do return first end;
end
Lambda.count = function(it,pred)
  local n = 0;
  if (pred == nil) then
    local _ = it:iterator();
    while (_:hasNext()) do
      local _1 = _:next();
      n = n + 1;
      end;
  else
    local x = it:iterator();
    while (x:hasNext()) do
      local x1 = x:next();
      if (pred(x1)) then
        n = n + 1;
      end;
      end;
  end;
  do return n end;
end
Lambda.empty = function(it)
  do return not it:iterator():hasNext() end;
end
Lambda.indexOf = function(it,v)
  local i = 0;
  local v2 = it:iterator();
  while (v2:hasNext()) do
    local v21 = v2:next();
    if (v == v21) then
      do return i end;
    end;
    i = i + 1;
    end;
  do return -1 end;
end
Lambda.find = function(it,f)
  local v = it:iterator();
  while (v:hasNext()) do
    local v1 = v:next();
    if (f(v1)) then
      do return v1 end;
    end;
    end;
  do return nil end;
end
Lambda.concat = function(a,b)
  local l = List.new();
  local x = a:iterator();
  while (x:hasNext()) do
    local x1 = x:next();
    l:add(x1);
    end;
  local x2 = b:iterator();
  while (x2:hasNext()) do
    local x3 = x2:next();
    l:add(x3);
    end;
  do return l end;
end

List.new = function()
  local self = _hx_new(List.prototype)
  List.super(self)
  return self
end
List.super = function(self)
  self.length = 0;
end
_hxClasses["List"] = List
List.__name__ = {"List"}
List.prototype = _hx_a(
  'h', nil,
  'q', nil,
  'length', nil,
  'add', function(self,item)
    local x = _List.ListNode.new(item,nil);
    if (self.h == nil) then
      self.h = x;
    else
      self.q.next = x;
    end;
    self.q = x;
    self.length = self.length + 1;
  end,
  'push', function(self,item)
    local x = _List.ListNode.new(item,self.h);
    self.h = x;
    if (self.q == nil) then
      self.q = x;
    end;
    self.length = self.length + 1;
  end,
  'first', function(self)
    if (self.h == nil) then
      do return nil end;
    else
      do return self.h.item end;
    end;
  end,
  'last', function(self)
    if (self.q == nil) then
      do return nil end;
    else
      do return self.q.item end;
    end;
  end,
  'pop', function(self)
    if (self.h == nil) then
      do return nil end;
    end;
    local x = self.h.item;
    self.h = self.h.next;
    if (self.h == nil) then
      self.q = nil;
    end;
    self.length = self.length - 1;
    do return x end
  end,
  'isEmpty', function(self)
    do return self.h == nil end
  end,
  'clear', function(self)
    self.h = nil;
    self.q = nil;
    self.length = 0;
  end,
  'remove', function(self,v)
    local prev = nil;
    local l = self.h;
    while (l ~= nil) do
      if (l.item == v) then
        if (prev == nil) then
          self.h = l.next;
        else
          prev.next = l.next;
        end;
        if (self.q == l) then
          self.q = prev;
        end;
        self.length = self.length - 1;
        do return true end;
      end;
      prev = l;
      l = l.next;
      end;
    do return false end
  end,
  'iterator', function(self)
    do return _List.ListIterator.new(self.h) end
  end,
  'toString', function(self)
    local s_length;
    local s_b = _hx_e();
    s_length = 0;
    local first = true;
    local l = self.h;
    local str = "{";
    _G.table.insert(s_b,str);
    s_length = s_length + str.length;
    while (l ~= nil) do
      if (first) then
        first = false;
      else
        local str1 = ", ";
        _G.table.insert(s_b,str1);
        s_length = s_length + str1.length;
      end;
      local str2 = Std.string(Std.string(l.item));
      _G.table.insert(s_b,str2);
      s_length = s_length + str2.length;
      l = l.next;
      end;
    local str3 = "}";
    _G.table.insert(s_b,str3);
    s_length = s_length + str3.length;
    do return _G.table.concat(s_b) end
  end,
  'join', function(self,sep)
    local s_length;
    local s_b = _hx_e();
    s_length = 0;
    local first = true;
    local l = self.h;
    while (l ~= nil) do
      if (first) then
        first = false;
      else
        local str = Std.string(sep);
        _G.table.insert(s_b,str);
        s_length = s_length + str.length;
      end;
      local str1 = Std.string(l.item);
      _G.table.insert(s_b,str1);
      s_length = s_length + str1.length;
      l = l.next;
      end;
    do return _G.table.concat(s_b) end
  end,
  'filter', function(self,f)
    local l2 = List.new();
    local l = self.h;
    while (l ~= nil) do
      local v = l.item;
      l = l.next;
      if (f(v)) then
        l2:add(v);
      end;
      end;
    do return l2 end
  end,
  'map', function(self,f)
    local b = List.new();
    local l = self.h;
    while (l ~= nil) do
      local v = l.item;
      l = l.next;
      b:add(f(v));
      end;
    do return b end
  end
  ,'__class__',  List
)

_List.ListNode.new = function(item,next)
  local self = _hx_new(_List.ListNode.prototype)
  _List.ListNode.super(self,item,next)
  return self
end
_List.ListNode.super = function(self,item,next)
  self.item = item;
  self.next = next;
end
_hxClasses["_List.ListNode"] = _List.ListNode
_List.ListNode.__name__ = {"_List","ListNode"}
_List.ListNode.prototype = _hx_a(
  'item', nil,
  'next', nil
  ,'__class__',  _List.ListNode
)

_List.ListIterator.new = function(head)
  local self = _hx_new(_List.ListIterator.prototype)
  _List.ListIterator.super(self,head)
  return self
end
_List.ListIterator.super = function(self,head)
  self.head = head;
end
_hxClasses["_List.ListIterator"] = _List.ListIterator
_List.ListIterator.__name__ = {"_List","ListIterator"}
_List.ListIterator.prototype = _hx_a(
  'head', nil,
  'hasNext', function(self)
    do return self.head ~= nil end
  end,
  'next', function(self)
    local val = self.head.item;
    self.head = self.head.next;
    do return val end
  end
  ,'__class__',  _List.ListIterator
)

_Map.Map_Impl_.new = {}
_hxClasses["_Map.Map_Impl_"] = _Map.Map_Impl_
_Map.Map_Impl_.__name__ = {"_Map","Map_Impl_"}
_Map.Map_Impl_.set = function(this1,key,value)
  this1:set(key,value);
end
_Map.Map_Impl_.get = function(this1,key)
  do return this1:get(key) end;
end
_Map.Map_Impl_.exists = function(this1,key)
  do return this1:exists(key) end;
end
_Map.Map_Impl_.remove = function(this1,key)
  do return this1:remove(key) end;
end
_Map.Map_Impl_.keys = function(this1)
  do return this1:keys() end;
end
_Map.Map_Impl_.iterator = function(this1)
  do return this1:iterator() end;
end
_Map.Map_Impl_.toString = function(this1)
  do return this1:toString() end;
end
_Map.Map_Impl_.arrayWrite = function(this1,k,v)
  this1:set(k,v);
  do return v end;
end
_Map.Map_Impl_.toStringMap = function(t)
  do return haxe.ds.StringMap.new() end;
end
_Map.Map_Impl_.toIntMap = function(t)
  do return haxe.ds.IntMap.new() end;
end
_Map.Map_Impl_.toEnumValueMapMap = function(t)
  do return haxe.ds.EnumValueMap.new() end;
end
_Map.Map_Impl_.toObjectMap = function(t)
  do return haxe.ds.ObjectMap.new() end;
end
_Map.Map_Impl_.fromStringMap = function(map)
  do return map end;
end
_Map.Map_Impl_.fromIntMap = function(map)
  do return map end;
end
_Map.Map_Impl_.fromObjectMap = function(map)
  do return map end;
end

Math.new = {}
_hxClasses["Math"] = Math
Math.__name__ = {"Math"}
Math.__properties__ = {get_NaN="get_NaN",get_POSITIVE_INFINITY="get_POSITIVE_INFINITY",get_NEGATIVE_INFINITY="get_NEGATIVE_INFINITY",get_PI="get_PI"}
Math.PI = nil
Math.get_PI = function()
  do return _G.math.pi end;
end
Math.NEGATIVE_INFINITY = nil
Math.get_NEGATIVE_INFINITY = function()
  do return -_G.math.huge end;
end
Math.POSITIVE_INFINITY = nil
Math.get_POSITIVE_INFINITY = function()
  do return _G.math.huge end;
end
Math.NaN = nil
Math.get_NaN = function()
  do return (0/0) end;
end
Math.isNaN = function(f)
  do return f ~= f end;
end
Math.isFinite = function(f)
  if (f > -_G.math.huge) then
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.abs = function(v)
  do return _G.math.abs(v) end;
end
Math.acos = function(v)
  do return _G.math.acos(v) end;
end
Math.asin = function(v)
  do return _G.math.asin(v) end;
end
Math.atan = function(v)
  do return _G.math.atan(v) end;
end
Math.ceil = function(v)
  do return _G.math.ceil(v) end;
end
Math.cos = function(v)
  do return _G.math.cos(v) end;
end
Math.exp = function(v)
  do return _G.math.exp(v) end;
end
Math.sin = function(v)
  do return _G.math.sin(v) end;
end
Math.sqrt = function(v)
  do return _G.math.sqrt(v) end;
end
Math.tan = function(v)
  do return _G.math.tan(v) end;
end
Math.floor = function(v)
  do return _G.math.floor(v) end;
end
Math.log = function(v)
  do return _G.math.log(v) end;
end
Math.random = function()
  do return _G.math.random() end;
end
Math.atan2 = function(y,x)
  do return _G.math.atan2(y,x) end;
end
Math.max = function(a,b)
  if (Math.isNaN(a) or Math.isNaN(b)) then
    do return (0/0) end;
  else
    do return _G.math.max(a,b) end;
  end;
end
Math.min = function(a,b)
  if (Math.isNaN(a) or Math.isNaN(b)) then
    do return (0/0) end;
  else
    do return _G.math.min(a,b) end;
  end;
end
Math.pow = function(v,exp)
  do return _G.math.pow(v,exp) end;
end
Math.round = function(v)
  do return _G.math.floor(v + 0.5) end;
end
Math.ffloor = function(v)
  do return _G.math.floor(v) end;
end
Math.fceil = function(v)
  do return _G.math.ceil(v) end;
end
Math.fround = function(v)
  do return _G.math.floor(v + 0.5) end;
end

Reflect.new = {}
_hxClasses["Reflect"] = Reflect
Reflect.__name__ = {"Reflect"}
Reflect.hasField = function(o,field)
  if (o.__fields__ ~= nil) then
    do return o.__fields__[field] ~= nil end;
  else
    do return o[field] ~= nil end;
  end;
end
Reflect.field = function(o,field)
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function()

      do return o[field] end;
     return _hx_expected_result end)
   if not _hx_status then
    local _hx_1 = _hx_result
    local e = _hx_1
    do return nil end;
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
Reflect.setField = function(o,field,value)
  o[field] = value;
end
Reflect.getProperty = function(o,field)
  local tmp;
  if (o == nil) then
    do return nil end;
  else
    if ((o.__properties__ ~= nil) and (Reflect.field(o,"get_" .. field) ~= nil)) then
      do return Reflect.callMethod(o,Reflect.field(o,"get_" .. field),_hx_tab_array({ }, 0)) end;
    else
      do return Reflect.field(o,field) end;
    end;
  end;
end
Reflect.setProperty = function(o,field,value)
  local tmp;
  if (o.__properties__ and o.__properties__["set_" .. field]) then
    tmp = o.__properties__["set_" .. field];
    if (o.__name__ ~= nil) then
      Reflect.callMethod(nil,Reflect.field(o,tmp),_hx_tab_array({[0]=value }, 1));
    else
      Reflect.callMethod(o,Reflect.field(o,tmp),_hx_tab_array({[0]=value }, 1));
    end;
  else
    o[field] = value;
  end;
end
Reflect.callMethod = function(o,func,args)
  if ((args == nil) or (args.length == 0)) then
    do return func(o) end;
  else
    local self_arg = false;
    if (o ~= nil) then
      self_arg = true;
    end;
    local new_args = ({});
    local _g1 = 0;
    local _g = args.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      new_args[i + 1] = args[i];
      end;
    if (self_arg) then
      do return func(o,_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
    else
      do return func(_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
    end;
  end;
end
Reflect.fields = function(o)
  local _g = _hx_tab_array({ }, 0);
  local f = lua.Boot.fieldIterator(o);
  while (f:hasNext()) do
    local f1 = f:next();
    _g:push(f1);
    end;
  do return _g end;
end
Reflect.isFunction = function(f)
  if (_G.type(f) == "function") then
    do return not ((function()
      local _hx_1
      if (_G.type(f) ~= "table") then
      _hx_1 = false; else
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function()
      local _hx_2
      if (_G.type(f) ~= "table") then
      _hx_2 = false; else
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.compare = function(a,b)
  if (a == b) then
    do return 0 end;
  else
    if (a == nil) then
      do return -1 end;
    else
      if (b == nil) then
        do return 1 end;
      else
        if (a > b) then
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
    end;
  end;
end
Reflect.compareMethods = function(f1,f2)
  do return f1 == f2 end;
end
Reflect.isObject = function(v)
  if (v == nil) then
    do return false end;
  end;
  local t = type(v);
  if (not ((t == "string") or ((t == "table") and (v.__enum__ == nil)))) then
    if (t == "function") then
      do return ((function()
        local _hx_1
        if (_G.type(v) ~= "table") then
        _hx_1 = false; else
        _hx_1 = v.__name__; end
        return _hx_1
      end )() or (function()
        local _hx_2
        if (_G.type(v) ~= "table") then
        _hx_2 = false; else
        _hx_2 = v.__ename__; end
        return _hx_2
      end )()) ~= nil end;
    else
      do return false end;
    end;
  else
    do return true end;
  end;
end
Reflect.isEnumValue = function(v)
  if ((v ~= nil) and lua.Boot.__instanceof(v,_G.table)) then
    do return v.__enum__ ~= nil end;
  else
    do return false end;
  end;
end
Reflect.deleteField = function(o,field)
  if (not ((function()
    local _hx_1
    if (o.__fields__ ~= nil) then
    _hx_1 = o.__fields__[field] ~= nil; else
    _hx_1 = o[field] ~= nil; end
    return _hx_1
  end )())) then
    do return false end;
  end;
  o[field] = nil;
  o.__fields__[field] = nil;
  do return true end;
end
Reflect.copy = function(o)
  local o2 = _hx_e();
  local _g = 0;
  local _g1 = Reflect.fields(o);
  while (_g < _g1.length) do
    local f = _g1[_g];
    _g = _g + 1;
    o2[f] = Reflect.field(o,f);
    end;
  do return o2 end;
end
Reflect.makeVarArgs = function(f)
  do return function(...)
			local a = {...}
			local b = {}
			local l = 0
			for k, v in pairs(a) do
				b[k-1] = v
				l = math.max(k,l)
			end
			return f(_hx_tab_array(b, l))
		end end;
end

String.new = function(string)
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string)
end
_hxClasses["String"] = String
String.__name__ = {"String"}
String.__oldindex = nil
String.__index = function(s,k)
  if (k == "length") then
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function()
      local _hx_1
      if (o.__fields__ ~= nil) then
      _hx_1 = o.__fields__[field] ~= nil; else
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code)
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'length', nil,
  'toUpperCase', function(self)
    do return _G.string.upper(self) end
  end,
  'toLowerCase', function(self)
    do return _G.string.lower(self) end
  end,
  'indexOf', function(self,str,startIndex)
    if (startIndex == nil) then
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = _G.string.find(self,str,startIndex,true);
    if ((r ~= nil) and (r > 0)) then
      do return r - 1 end;
    else
      do return -1 end;
    end;
  end,
  'lastIndexOf', function(self,str,startIndex)
    local i = 0;
    local ret = -1;
    if (startIndex == nil) then
      startIndex = self.length;
    end;
    while (true) do
      local p = self:indexOf(str,ret + 1);
      if ((p == -1) or (p > startIndex)) then
        do return ret end;
      end;
      ret = p;
      end;
  end,
  'split', function(self,delimiter)
    local idx = 1;
    local ret = _hx_tab_array({ }, 0);
    local delim_offset = (function()
      local _hx_1
      if (delimiter.length > 0) then
      _hx_1 = delimiter.length; else
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do
      local newidx = 0;
      if (delimiter.length > 0) then
        newidx = _G.string.find(self,delimiter,idx,true);
      else
        if (idx >= self.length) then
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then
        local match = _G.string.sub(self,idx,newidx - 1);
        ret:push(match);
        idx = newidx + delimiter.length;
      else
        ret:push(_G.string.sub(self,idx,_G.string.len(self)));
        idx = nil;
      end;
      end;
    do return ret end
  end,
  'toString', function(self)
    do return self end
  end,
  'substring', function(self,startIndex,endIndex)
    if (endIndex == nil) then
      endIndex = self.length;
    end;
    if (endIndex < 0) then
      endIndex = 0;
    end;
    if (startIndex < 0) then
      startIndex = 0;
    end;
    if (endIndex < startIndex) then
      do return _G.string.sub(self,endIndex + 1,startIndex) end;
    else
      do return _G.string.sub(self,startIndex + 1,endIndex) end;
    end;
  end,
  'get_length', function(self)
    do return _G.string.len(self) end
  end,
  'charAt', function(self,index)
    do return _G.string.sub(self,index + 1,index + 1) end
  end,
  'charCodeAt', function(self,index)
    do return _G.string.byte(self,index + 1) end
  end,
  'substr', function(self,pos,len)
    if ((len == nil) or (len > (pos + self.length))) then
      len = self.length;
    else
      if (len < 0) then
        len = self.length + len;
      end;
    end;
    if (pos < 0) then
      pos = self.length + pos;
    end;
    if (pos < 0) then
      pos = 0;
    end;
    do return _G.string.sub(self,pos + 1,pos + len) end
  end
  ,'__class__',  String
)

Std.new = {}
_hxClasses["Std"] = Std
Std.__name__ = {"Std"}
Std.is = function(v,t)
  do return lua.Boot.__instanceof(v,t) end;
end
Std.instance = function(value,c)
  if (lua.Boot.__instanceof(value,c)) then
    do return value end;
  else
    do return nil end;
  end;
end
Std.string = function(s)
  do return lua.Boot.__string_rec(s) end;
end
Std.int = function(x)
  if (not ((x > -_G.math.huge) and (x < _G.math.huge)) or Math.isNaN(x)) then
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x)
  if (x == nil) then
    do return nil end;
  end;
  local hexMatch = _G.string.match(x,"^ *[%-+]*0[xX][%da-FA-F]*");
  if (hexMatch ~= nil) then
    do return _G.tonumber(hexMatch:substr(2),16) end;
  else
    local intMatch = _G.string.match(x,"^ *[%-+]?%d*");
    if (intMatch ~= nil) then
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x)
  if ((x == nil) or (x == "")) then
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x,"^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then
    do return (0/0) end;
  end;
  x = x:substr(digitMatch.length);
  local decimalMatch = _G.string.match(x,"^%.%d*");
  if (decimalMatch == nil) then
    decimalMatch = "";
  end;
  x = x:substr(decimalMatch.length);
  local eMatch = _G.string.match(x,"^[eE][+%-]?%d+");
  if (eMatch == nil) then
    eMatch = "";
  end;
  local result = _G.tonumber(digitMatch .. decimalMatch .. eMatch);
  if (result ~= nil) then
    do return result end;
  else
    do return (0/0) end;
  end;
end
Std.random = function(x)
  if (x <= 0) then
    do return 0 end;
  else
    do return _G.math.floor(_G.math.random() * x) end;
  end;
end

StringBuf.new = function()
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self)
  self.b = _hx_e();
  self.length = 0;
end
_hxClasses["StringBuf"] = StringBuf
StringBuf.__name__ = {"StringBuf"}
StringBuf.prototype = _hx_a(
  'b', nil,
  'length', nil,
  'get_length', function(self)
    do return self.length end
  end,
  'add', function(self,x)
    local str = Std.string(x);
    _G.table.insert(self.b,str);
    local tmp = self;
    tmp.length = tmp.length + str.length;
  end,
  'addChar', function(self,c)
    _G.table.insert(self.b,_G.string.char(c));
    local tmp = self;
    tmp.length = tmp.length + 1;
  end,
  'addSub', function(self,s,pos,len)
    local part = (function()
      local _hx_1
      if (len == nil) then
      _hx_1 = s:substr(pos); else
      _hx_1 = s:substr(pos,len); end
      return _hx_1
    end )();
    _G.table.insert(self.b,part);
    local tmp = self;
    tmp.length = tmp.length + part.length;
  end,
  'toString', function(self)
    do return _G.table.concat(self.b) end
  end
  ,'__class__',  StringBuf,
  '__properties__',  {get_length="get_length"}
)

StringTools.new = {}
_hxClasses["StringTools"] = StringTools
StringTools.__name__ = {"StringTools"}
StringTools.urlEncode = function(s)
  s = _G.string.gsub(s,"\n","\r\n");
  s = _G.string.gsub(s,"([^%w %-%_%.%~])",function(c)
    do return _G.string.format("%%%02X",_G.string.byte(c) .. "") end;
  end);
  s = _G.string.gsub(s," ","+");
  do return s end;
end
StringTools.urlDecode = function(s)
  s = _G.string.gsub(s,"+"," ");
  s = _G.string.gsub(s,"%%(%x%x)",function(h)
    do return _G.string.char(_G.tonumber(h,16)) end;
  end);
  s = _G.string.gsub(s,"\r\n","\n");
  do return s end;
end
StringTools.htmlEscape = function(s,quotes)
  s = s:split("&"):join("&amp;"):split("<"):join("&lt;"):split(">"):join("&gt;");
  if (quotes) then
    do return s:split("\""):join("&quot;"):split("'"):join("&#039;") end;
  else
    do return s end;
  end;
end
StringTools.htmlUnescape = function(s)
  do return s:split("&gt;"):join(">"):split("&lt;"):join("<"):split("&quot;"):join("\""):split("&#039;"):join("'"):split("&amp;"):join("&") end;
end
StringTools.startsWith = function(s,start)
  if (s.length >= start.length) then
    do return s:substr(0,start.length) == start end;
  else
    do return false end;
  end;
end
StringTools.endsWith = function(s,_end)
  local elen = _end.length;
  local slen = s.length;
  if (slen >= elen) then
    do return s:substr(slen - elen,elen) == _end end;
  else
    do return false end;
  end;
end
StringTools.isSpace = function(s,pos)
  if (((s.length == 0) or (pos < 0)) or (pos >= s.length)) then
    do return false end;
  end;
  local c = s:charCodeAt(pos);
  if (not ((c > 8) and (c < 14))) then
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s)
  local l = s.length;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s,r)) do
    r = r + 1;
    end;
  if (r > 0) then
    do return s:substr(r,l - r) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s)
  local l = s.length;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s,(l - r) - 1)) do
    r = r + 1;
    end;
  if (r > 0) then
    do return s:substr(0,l - r) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s)
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end
StringTools.lpad = function(s,c,l)
  if (c.length <= 0) then
    do return s end;
  end;
  while (s.length < l) do
    s = c .. s;
    end;
  do return s end;
end
StringTools.rpad = function(s,c,l)
  if (c.length <= 0) then
    do return s end;
  end;
  while (s.length < l) do
    s = s .. c;
    end;
  do return s end;
end
StringTools.replace = function(s,sub,by)
  do return s:split(sub):join(by) end;
end
StringTools.hex = function(n,digits)
  local s = "";
  local hexChars = "0123456789ABCDEF";
  while (true) do
    s = hexChars:charAt(_hx_bit.band(n,15)) .. s;
    n = _hx_bit.rshift(n,4);
    if (not (n > 0)) then
      break;
    end;
    end;
  if (digits ~= nil) then
    while (s.length < digits) do
      s = "0" .. s;
      end;
  end;
  do return s end;
end
StringTools.fastCodeAt = function(s,index)
  do return _G.string.byte(s,index + 1) end;
end
StringTools.isEof = function(c)
  do return c == nil end;
end
StringTools.quoteUnixArg = function(argument)
  if (argument == "") then
    do return "''" end;
  end;
  if (not EReg.new("[^a-zA-Z0-9_@%+=:,./-]",""):match(argument)) then
    do return argument end;
  end;
  do return "'" .. StringTools.replace(argument,"'","'\"'\"'") .. "'" end;
end
StringTools.quoteWinArg = function(argument,escapeMetaCharacters)
  if (not EReg.new("^[^ \t\\\\\"]+$",""):match(argument)) then
    local result_length;
    local result_b = _hx_e();
    result_length = 0;
    local needquote = ((argument:indexOf(" ") ~= -1) or (argument:indexOf("\t") ~= -1)) or (argument == "");
    if (needquote) then
      local str = "\"";
      _G.table.insert(result_b,str);
      result_length = result_length + str.length;
    end;
    local bs_buf = StringBuf.new();
    local _g1 = 0;
    local _g = argument.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local _g2 = argument:charCodeAt(i);
      if (_g2 == nil) then
        local c = _g2;
        if (bs_buf.length > 0) then
          local str1 = Std.string(_G.table.concat(bs_buf.b));
          _G.table.insert(result_b,str1);
          result_length = result_length + str1.length;
          bs_buf = StringBuf.new();
        end;
        _G.table.insert(result_b,_G.string.char(c));
        result_length = result_length + 1;
      else
        local _g21 = _g2;
        if (_g21) == 34 then
          local bs = _G.table.concat(bs_buf.b);
          local str2 = Std.string(bs);
          _G.table.insert(result_b,str2);
          result_length = result_length + str2.length;
          local str3 = Std.string(bs);
          _G.table.insert(result_b,str3);
          result_length = result_length + str3.length;
          bs_buf = StringBuf.new();
          local str4 = "\\\"";
          _G.table.insert(result_b,str4);
          result_length = result_length + str4.length;
        elseif (_g21) == 92 then
          local str5 = "\\";
          _G.table.insert(bs_buf.b,str5);
          local bs_buf1 = bs_buf;
          bs_buf1.length = bs_buf1.length + str5.length;else
        local c1 = _g2;
        if (bs_buf.length > 0) then
          local str6 = Std.string(_G.table.concat(bs_buf.b));
          _G.table.insert(result_b,str6);
          result_length = result_length + str6.length;
          bs_buf = StringBuf.new();
        end;
        _G.table.insert(result_b,_G.string.char(c1));
        result_length = result_length + 1; end;
      end;
      end;
    local str7 = Std.string(_G.table.concat(bs_buf.b));
    _G.table.insert(result_b,str7);
    result_length = result_length + str7.length;
    if (needquote) then
      local str8 = Std.string(_G.table.concat(bs_buf.b));
      _G.table.insert(result_b,str8);
      result_length = result_length + str8.length;
      local str9 = "\"";
      _G.table.insert(result_b,str9);
      result_length = result_length + str9.length;
    end;
    argument = _G.table.concat(result_b);
  end;
  if (escapeMetaCharacters) then
    local result_length1;
    local result_b1 = _hx_e();
    result_length1 = 0;
    local _g11 = 0;
    local _g3 = argument.length;
    while (_g11 < _g3) do
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      local c2 = argument:charCodeAt(i1);
      if (StringTools.winMetaCharacters:indexOf(c2) >= 0) then
        _G.table.insert(result_b1,_G.string.char(94));
        result_length1 = result_length1 + 1;
      end;
      _G.table.insert(result_b1,_G.string.char(c2));
      result_length1 = result_length1 + 1;
      end;
    do return _G.table.concat(result_b1) end;
  else
    do return argument end;
  end;
end

Sys.new = {}
_hxClasses["Sys"] = Sys
Sys.__name__ = {"Sys"}
Sys._system_name = nil
Sys.print = function(v)
  _G.io.write(Std.string(v));
  _G.io.flush();
  do return end;
end
Sys.println = function(v)
  _G.print(Std.string(v));
  do return end;
end
Sys.args = function()
  local t = _G.arg;
  local length = nil;
  if (length == nil) then
    length = _hx_table.maxn(t) + 1;
  end;
  local _g = _hx_tab_array({ }, 0);
  local _g1 = 0;
  local _g2 = _hx_tab_array(t,length);
  while (_g1 < _g2.length) do
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
    end;
  local args = _g;
  args:shift();
  do return args end;
end
Sys.command = function(cmd,args)
  local p = sys.io.Process.new(cmd,args);
  local code = p:exitCode();
  p:close();
  do return code end;
end
Sys.cpuTime = function()
  do return _G.os.clock() end;
end
Sys.exit = function(code)
  _G.os.exit(code);
end
Sys.getChar = function(echo)
  do return _G.string.byte(_G.io.read(1)) end;
end
Sys.getSystemName = function()
  do return lua.Boot.systemName() end;
end
Sys.systemName = function()
  if (Sys._system_name == nil) then
    Sys._system_name = Sys.getSystemName();
  end;
  do return Sys._system_name end;
end
Sys.environment = function()
  local map = haxe.ds.StringMap.new();
  local f = function(k,v)
    map.v[k] = v;
    map.k[k] = true;
  end;
  for k,v in lua.lib.environ.Environ.enum() do f(k,v) end;
  do return map end;
end
Sys.executablePath = function()
  do return lua.lib.luv.Misc.exepath() end;
end
Sys.programPath = function()
  do return haxe.io.Path.join(_hx_tab_array({[0]=lua.lib.luv.Misc.cwd(), _G.arg[0] }, 2)) end;
end
Sys.getCwd = function()
  do return lua.lib.luv.Misc.cwd() end;
end
Sys.setCwd = function(s)
  lua.lib.luv.Misc.chdir(s);
end
Sys.getEnv = function(s)
  do return _G.os.getenv(s) end;
end
Sys.putEnv = function(s,v)
  lua.lib.environ.Environ.setenv(s,v);
end
Sys.setTimeLocale = function(loc)
  do return _G.os.setlocale(loc) ~= nil end;
end
Sys.sleep = function(seconds)
  lua.lib.luv.Thread.sleep(_G.math.floor(seconds * 1000));
end
Sys.stderr = function()
  do return sys.io.FileOutput.new(_G.io.stderr) end;
end
Sys.stdin = function()
  do return sys.io.FileInput.new(_G.io.stdin) end;
end
Sys.stdout = function()
  do return sys.io.FileOutput.new(_G.io.stdout) end;
end
Sys.time = function()
  do return lua.lib.luasocket.Socket.gettime() end;
end
_hxClasses["ValueType"] = ValueType;
_hxClasses["ValueType"] = { __ename__ = {"ValueType"}, __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)
rawset(ValueType.TNull, 'toString', _estr)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)
rawset(ValueType.TInt, 'toString', _estr)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)
rawset(ValueType.TFloat, 'toString', _estr)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)
rawset(ValueType.TBool, 'toString', _estr)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)
rawset(ValueType.TObject, 'toString', _estr)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)
rawset(ValueType.TFunction, 'toString', _estr)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); rawset(_x, 'toString', _estr); return _x; end
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); rawset(_x, 'toString', _estr); return _x; end
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)
rawset(ValueType.TUnknown, 'toString', _estr)

ValueType.__empty_constructs__ = _hx_tab_array({[0] = ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown}, 7)

Type.new = {}
_hxClasses["Type"] = Type
Type.__name__ = {"Type"}
Type.getClass = function(o)
  if (o == nil) then
    do return nil end;
  end;
  if (lua.Boot.__instanceof(o,Array)) then
    do return Array end;
  else
    local cl = o.__class__;
    if (cl ~= nil) then
      do return cl end;
    else
      do return nil end;
    end;
  end;
end
Type.getEnum = function(o)
  if (o == nil) then
    do return nil end;
  end;
  do return o.__enum__ end;
end
Type.getSuperClass = function(c)
  do return c.__super__ end;
end
Type.getClassName = function(c)
  if (c.__name__ == nil) then
    do return nil end;
  end;
  do return _G.table.concat(c.__name__,".") end;
end
Type.getEnumName = function(e)
  if (e.__ename__ == nil) then
    do return nil end;
  end;
  do return _G.table.concat(e.__ename__,".") end;
end
Type.resolveClass = function(name)
  local cl = _hxClasses[name];
  if ((cl == nil) or not ((function()
    local _hx_1
    if (_G.type(cl) ~= "table") then
    _hx_1 = false; else
    _hx_1 = cl.__name__; end
    return _hx_1
  end )())) then
    do return nil end;
  end;
  do return cl end;
end
Type.resolveEnum = function(name)
  local e = _hxClasses[name];
  if ((e == nil) or not ((function()
    local _hx_1
    if (_G.type(e) ~= "table") then
    _hx_1 = false; else
    _hx_1 = e.__ename__; end
    return _hx_1
  end )())) then
    do return nil end;
  end;
  do return e end;
end
Type.createInstance = function(cl,args)
  do return cl.new(_hx_table.unpack(args,0)) end;
end
Type.createEmptyInstance = function(cl)
  local ret = ({});
  _G.setmetatable(ret,_hx_o({__fields__={__index=true},__index=cl.prototype}));
  do return ret end;
end
Type.createEnum = function(e,constr,params)
  local f = Reflect.field(e,constr);
  if (f == nil) then
    _G.error("No such constructor " .. constr,0);
  end;
  if (Reflect.isFunction(f)) then
    if (params == nil) then
      _G.error("Constructor " .. constr .. " need parameters",0);
    end;
    do return Reflect.callMethod(nil,f,params) end;
  end;
  if ((params ~= nil) and (params.length ~= 0)) then
    _G.error("Constructor " .. constr .. " does not need parameters",0);
  end;
  do return f end;
end
Type.createEnumIndex = function(e,index,params)
  local c = e.__constructs__[index];
  if (c == nil) then
    _G.error(index .. " is not a valid enum constructor index",0);
  end;
  do return Type.createEnum(e,c,params) end;
end
Type.getInstanceFields = function(c)
  local p = c.prototype;
  local a = _hx_tab_array({ }, 0);
  while (p ~= nil) do
    local f = lua.Boot.fieldIterator(p);
    while (f:hasNext()) do
      local f1 = f:next();
      if (not Lambda.has(a,f1)) then
        a:push(f1);
      end;
      end;
    local mt = _G.getmetatable(p);
    if ((mt ~= nil) and (mt.__index ~= nil)) then
      p = mt.__index;
    else
      p = nil;
    end;
    end;
  do return a end;
end
Type.getClassFields = function(c)
  local a = Reflect.fields(c);
  a:remove("__name__");
  a:remove("__interfaces__");
  a:remove("__properties__");
  a:remove("__super__");
  a:remove("__meta__");
  a:remove("prototype");
  a:remove("new");
  do return a end;
end
Type.getEnumConstructs = function(e)
  local a = e.__constructs__;
  local _g = _hx_tab_array({ }, 0);
  local _g1 = 0;
  local _g2 = a;
  while (_g1 < _g2.length) do
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
    end;
  do return _g end;
end
Type.typeof = function(v)
  local _g = _G.type(v);
  local _g1 = _g;
  if (_g1) == "boolean" then
    do return ValueType.TBool end;
  elseif (_g1) == "function" then
    if ((function()
      local _hx_1
      if (_G.type(v) ~= "table") then
      _hx_1 = false; else
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function()
      local _hx_2
      if (_G.type(v) ~= "table") then
      _hx_2 = false; else
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g1) == "nil" then
    do return ValueType.TNull end;
  elseif (_g1) == "number" then
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g1) == "string" then
    do return ValueType.TClass(String) end;
  elseif (_g1) == "table" then
    local e = v.__enum__;
    if (e ~= nil) then
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (lua.Boot.__instanceof(v,Array)) then
      c = Array;
    else
      local cl = v.__class__;
      if (cl ~= nil) then
        c = cl;
      else
        c = nil;
      end;
    end;
    if (c ~= nil) then
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end
Type.enumEq = function(a,b)
  if (a == b) then
    do return true end;
  end;
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function()

      if (a[0] ~= b[0]) then
        do return false end;
      end;
      local _g1 = 2;
      local _g = a.length;
      while (_g1 < _g) do
        _g1 = _g1 + 1;
        local i = _g1 - 1;
        if (not Type.enumEq(a[i],b[i])) then
          do return false end;
        end;
        end;
      local e = a.__enum__;
      if ((e ~= b.__enum__) or (e == nil)) then
        do return false end;
      end;
     return _hx_expected_result end)
   if not _hx_status then
    local _hx_1 = _hx_result
    local e1 = _hx_1
    do return false end;
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  do return true end;
end
Type.enumConstructor = function(e)
  do return e[0] end;
end
Type.enumParameters = function(e)
  do return e:slice(2) end;
end
Type.enumIndex = function(e)
  do return e[1] end;
end
Type.allEnums = function(e)
  do return e.__empty_constructs__ end;
end

haxe.IMap.new = {}
_hxClasses["haxe.IMap"] = haxe.IMap
haxe.IMap.__name__ = {"haxe","IMap"}
haxe.IMap.prototype = _hx_a(
  'get', nil,
  'set', nil,
  'exists', nil,
  'remove', nil,
  'keys', nil,
  'iterator', nil,
  'toString', nil
  ,'__class__',  haxe.IMap
)

haxe._Int32.Int32_Impl_.new = {}
_hxClasses["haxe._Int32.Int32_Impl_"] = haxe._Int32.Int32_Impl_
haxe._Int32.Int32_Impl_.__name__ = {"haxe","_Int32","Int32_Impl_"}
haxe._Int32.Int32_Impl_.preIncrement = function(this1)
  this1 = this1 + 1;
  this1 = haxe._Int32.Int32_Impl_.clamp(this1);
  do return this1 end;
end
haxe._Int32.Int32_Impl_.postIncrement = function(this1)
  this1 = this1 + 1;
  local ret = this1 - 1;
  this1 = haxe._Int32.Int32_Impl_.clamp(this1);
  do return ret end;
end
haxe._Int32.Int32_Impl_.preDecrement = function(this1)
  this1 = this1 - 1;
  this1 = haxe._Int32.Int32_Impl_.clamp(this1);
  do return this1 end;
end
haxe._Int32.Int32_Impl_.postDecrement = function(this1)
  this1 = this1 - 1;
  local ret = this1 + 1;
  this1 = haxe._Int32.Int32_Impl_.clamp(this1);
  do return ret end;
end
haxe._Int32.Int32_Impl_.add = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(a + b) end;
end
haxe._Int32.Int32_Impl_.addInt = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(a + b) end;
end
haxe._Int32.Int32_Impl_.sub = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(a - b) end;
end
haxe._Int32.Int32_Impl_.subInt = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(a - b) end;
end
haxe._Int32.Int32_Impl_.intSub = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(a - b) end;
end
haxe._Int32.Int32_Impl_.mul = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp((a * (_hx_bit.band(b,65535))) + haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a * (_hx_bit.rshift(b,16)),16))) end;
end
haxe._Int32.Int32_Impl_.mulInt = function(a,b)
  do return haxe._Int32.Int32_Impl_.mul(a,b) end;
end
haxe._Int32.Int32_Impl_.complement = function(a)
  do return _hx_bit_clamp(_hx_bit.bnot(a)) end;
end
haxe._Int32.Int32_Impl_["or"] = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.bor(a,b)) end;
end
haxe._Int32.Int32_Impl_.orInt = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.bor(a,b)) end;
end
haxe._Int32.Int32_Impl_.xor = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.bxor(a,b)) end;
end
haxe._Int32.Int32_Impl_.xorInt = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.bxor(a,b)) end;
end
haxe._Int32.Int32_Impl_.shr = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.arshift(a,b)) end;
end
haxe._Int32.Int32_Impl_.shrInt = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.arshift(a,b)) end;
end
haxe._Int32.Int32_Impl_.intShr = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.arshift(a,b)) end;
end
haxe._Int32.Int32_Impl_.shl = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a,b)) end;
end
haxe._Int32.Int32_Impl_.shlInt = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a,b)) end;
end
haxe._Int32.Int32_Impl_.intShl = function(a,b)
  do return haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a,b)) end;
end
haxe._Int32.Int32_Impl_.toFloat = function(this1)
  do return this1 end;
end
haxe._Int32.Int32_Impl_.ucompare = function(a,b)
  if (a < 0) then
    if (b < 0) then
      do return haxe._Int32.Int32_Impl_.clamp(_hx_bit_clamp(_hx_bit.bnot(b)) - _hx_bit_clamp(_hx_bit.bnot(a))) end;
    else
      do return 1 end;
    end;
  end;
  if (b < 0) then
    do return -1 end;
  else
    do return haxe._Int32.Int32_Impl_.clamp(a - b) end;
  end;
end
haxe._Int32.Int32_Impl_.clamp = function(x)
  do return _hx_bit_clamp(x) end;
end

haxe._Int64.Int64_Impl_.new = {}
_hxClasses["haxe._Int64.Int64_Impl_"] = haxe._Int64.Int64_Impl_
haxe._Int64.Int64_Impl_.__name__ = {"haxe","_Int64","Int64_Impl_"}
haxe._Int64.Int64_Impl_.__properties__ = {get_low="get_low",get_high="get_high"}
haxe._Int64.Int64_Impl_._new = function(x)
  local this1 = x;
  do return this1 end;
end
haxe._Int64.Int64_Impl_.copy = function(this1)
  local this2 = haxe._Int64.___Int64.new(this1.high,this1.low);
  do return this2 end;
end
haxe._Int64.Int64_Impl_.make = function(high,low)
  local this1 = haxe._Int64.___Int64.new(high,low);
  do return this1 end;
end
haxe._Int64.Int64_Impl_.ofInt = function(x)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(x,31),x);
  do return this1 end;
end
haxe._Int64.Int64_Impl_.toInt = function(x)
  if (x.high ~= haxe._Int32.Int32_Impl_.shr(x.low,31)) then
    _G.error("Overflow",0);
  end;
  do return x.low end;
end
haxe._Int64.Int64_Impl_.is = function(val)
  do return lua.Boot.__instanceof(val,haxe._Int64.___Int64) end;
end
haxe._Int64.Int64_Impl_.getHigh = function(x)
  do return x.high end;
end
haxe._Int64.Int64_Impl_.getLow = function(x)
  do return x.low end;
end
haxe._Int64.Int64_Impl_.isNeg = function(x)
  do return x.high < 0 end;
end
haxe._Int64.Int64_Impl_.isZero = function(x)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);
  local b = this1;
  if (x.high == b.high) then
    do return x.low == b.low end;
  else
    do return false end;
  end;
end
haxe._Int64.Int64_Impl_.compare = function(a,b)
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b.low);
  end;
  if (a.high < 0) then
    if (b.high < 0) then
      do return v end;
    else
      do return -1 end;
    end;
  else
    if (b.high >= 0) then
      do return v end;
    else
      do return 1 end;
    end;
  end;
end
haxe._Int64.Int64_Impl_.ucompare = function(a,b)
  local v = haxe._Int32.Int32_Impl_.ucompare(a.high,b.high);
  if (v ~= 0) then
    do return v end;
  else
    do return haxe._Int32.Int32_Impl_.ucompare(a.low,b.low) end;
  end;
end
haxe._Int64.Int64_Impl_.toStr = function(x)
  do return haxe._Int64.Int64_Impl_.toString(x) end;
end
haxe._Int64.Int64_Impl_.toString = function(this1)
  local i = this1;
  local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);
  local b = this2;
  if ((i.high == b.high) and (i.low == b.low)) then
    do return "0" end;
  end;
  local str = "";
  local neg = false;
  if (i.high < 0) then
    neg = true;
  end;
  local this3 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(10,31),10);
  local ten = this3;
  while (true) do
    local this4 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);
    local b1 = this4;
    if (not ((i.high ~= b1.high) or (i.low ~= b1.low))) then
      break;
    end;
    local r = haxe._Int64.Int64_Impl_.divMod(i,ten);
    if (r.modulus.high < 0) then
      local x = r.modulus;
      local a = x.high;
      local high = _hx_bit_clamp(_hx_bit.bnot(a));
      local low = -x.low;
      if (low == 0) then
        high = high + 1;
        local ret = high - 1;
        high = haxe._Int32.Int32_Impl_.clamp(high);
      end;
      local this5 = haxe._Int64.___Int64.new(high,low);
      str = this5.low .. str;
      local x1 = r.quotient;
      local a1 = x1.high;
      local high1 = _hx_bit_clamp(_hx_bit.bnot(a1));
      local low1 = -x1.low;
      if (low1 == 0) then
        high1 = high1 + 1;
        local ret1 = high1 - 1;
        high1 = haxe._Int32.Int32_Impl_.clamp(high1);
      end;
      local this6 = haxe._Int64.___Int64.new(high1,low1);
      i = this6;
    else
      str = r.modulus.low .. str;
      i = r.quotient;
    end;
    end;
  if (neg) then
    str = "-" .. str;
  end;
  do return str end;
end
haxe._Int64.Int64_Impl_.parseString = function(sParam)
  do return haxe.Int64Helper.parseString(sParam) end;
end
haxe._Int64.Int64_Impl_.fromFloat = function(f)
  do return haxe.Int64Helper.fromFloat(f) end;
end
haxe._Int64.Int64_Impl_.divMod = function(dividend,divisor)
  if (divisor.high == 0) then
    local _g = divisor.low;
    local _g1 = _g;
    if (_g1) == 0 then
      _G.error("divide by zero",0);
    elseif (_g1) == 1 then
      local this1 = haxe._Int64.___Int64.new(dividend.high,dividend.low);
      local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);
      do return _hx_o({__fields__={quotient=true,modulus=true},quotient=this1,modulus=this2}) end; end;
  end;
  local divSign = (dividend.high < 0) ~= (divisor.high < 0);
  local modulus;
  if (dividend.high < 0) then
    local a = dividend.high;
    local high = _hx_bit_clamp(_hx_bit.bnot(a));
    local low = -dividend.low;
    if (low == 0) then
      high = high + 1;
      local ret = high - 1;
      high = haxe._Int32.Int32_Impl_.clamp(high);
    end;
    local this3 = haxe._Int64.___Int64.new(high,low);
    modulus = this3;
  else
    local this4 = haxe._Int64.___Int64.new(dividend.high,dividend.low);
    modulus = this4;
  end;
  if (divisor.high < 0) then
    local a1 = divisor.high;
    local high1 = _hx_bit_clamp(_hx_bit.bnot(a1));
    local low1 = -divisor.low;
    if (low1 == 0) then
      high1 = high1 + 1;
      local ret1 = high1 - 1;
      high1 = haxe._Int32.Int32_Impl_.clamp(high1);
    end;
    local this5 = haxe._Int64.___Int64.new(high1,low1);
    divisor = this5;
  else
    divisor = divisor;
  end;
  local this6 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);
  local quotient = this6;
  local this7 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(1,31),1);
  local mask = this7;
  while (not (divisor.high < 0)) do
    local v = haxe._Int32.Int32_Impl_.ucompare(divisor.high,modulus.high);
    local cmp = (function()
      local _hx_1
      if (v ~= 0) then
      _hx_1 = v; else
      _hx_1 = haxe._Int32.Int32_Impl_.ucompare(divisor.low,modulus.low); end
      return _hx_1
    end )();
    local b = 1;
    b = _hx_bit.band(b,63);
    if (b == 0) then
      local this8 = haxe._Int64.___Int64.new(divisor.high,divisor.low);
      divisor = this8;
    else
      if (b < 32) then
        local this9 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_["or"](haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(divisor.high,b)),_hx_bit.rshift(divisor.low,32 - b)),haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(divisor.low,b)));
        divisor = this9;
      else
        local this10 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(divisor.low,b - 32)),0);
        divisor = this10;
      end;
    end;
    local b1 = 1;
    b1 = _hx_bit.band(b1,63);
    if (b1 == 0) then
      local this11 = haxe._Int64.___Int64.new(mask.high,mask.low);
      mask = this11;
    else
      if (b1 < 32) then
        local this12 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_["or"](haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(mask.high,b1)),_hx_bit.rshift(mask.low,32 - b1)),haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(mask.low,b1)));
        mask = this12;
      else
        local this13 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(mask.low,b1 - 32)),0);
        mask = this13;
      end;
    end;
    if (cmp >= 0) then
      break;
    end;
    end;
  while (true) do
    local this14 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);
    local b2 = this14;
    if (not ((mask.high ~= b2.high) or (mask.low ~= b2.low))) then
      break;
    end;
    local v1 = haxe._Int32.Int32_Impl_.ucompare(modulus.high,divisor.high);
    if ((function()
      local _hx_2
      if (v1 ~= 0) then
      _hx_2 = v1; else
      _hx_2 = haxe._Int32.Int32_Impl_.ucompare(modulus.low,divisor.low); end
      return _hx_2
    end )() >= 0) then
      local this15 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_["or"](quotient.high,mask.high),haxe._Int32.Int32_Impl_["or"](quotient.low,mask.low));
      quotient = this15;
      local high2 = haxe._Int32.Int32_Impl_.clamp(modulus.high - divisor.high);
      local low2 = haxe._Int32.Int32_Impl_.clamp(modulus.low - divisor.low);
      if (haxe._Int32.Int32_Impl_.ucompare(modulus.low,divisor.low) < 0) then
        high2 = high2 - 1;
        local ret2 = high2 + 1;
        high2 = haxe._Int32.Int32_Impl_.clamp(high2);
      end;
      local this16 = haxe._Int64.___Int64.new(high2,low2);
      modulus = this16;
    end;
    local b3 = 1;
    b3 = _hx_bit.band(b3,63);
    if (b3 == 0) then
      local this17 = haxe._Int64.___Int64.new(mask.high,mask.low);
      mask = this17;
    else
      if (b3 < 32) then
        local this18 = haxe._Int64.___Int64.new(_hx_bit.rshift(mask.high,b3),haxe._Int32.Int32_Impl_["or"](haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(mask.high,32 - b3)),_hx_bit.rshift(mask.low,b3)));
        mask = this18;
      else
        local this19 = haxe._Int64.___Int64.new(0,_hx_bit.rshift(mask.high,b3 - 32));
        mask = this19;
      end;
    end;
    local b4 = 1;
    b4 = _hx_bit.band(b4,63);
    if (b4 == 0) then
      local this20 = haxe._Int64.___Int64.new(divisor.high,divisor.low);
      divisor = this20;
    else
      if (b4 < 32) then
        local this21 = haxe._Int64.___Int64.new(_hx_bit.rshift(divisor.high,b4),haxe._Int32.Int32_Impl_["or"](haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(divisor.high,32 - b4)),_hx_bit.rshift(divisor.low,b4)));
        divisor = this21;
      else
        local this22 = haxe._Int64.___Int64.new(0,_hx_bit.rshift(divisor.high,b4 - 32));
        divisor = this22;
      end;
    end;
    end;
  if (divSign) then
    local a2 = quotient.high;
    local high3 = _hx_bit_clamp(_hx_bit.bnot(a2));
    local low3 = -quotient.low;
    if (low3 == 0) then
      high3 = high3 + 1;
      local ret3 = high3 - 1;
      high3 = haxe._Int32.Int32_Impl_.clamp(high3);
    end;
    local this23 = haxe._Int64.___Int64.new(high3,low3);
    quotient = this23;
  end;
  if (dividend.high < 0) then
    local a3 = modulus.high;
    local high4 = _hx_bit_clamp(_hx_bit.bnot(a3));
    local low4 = -modulus.low;
    if (low4 == 0) then
      high4 = high4 + 1;
      local ret4 = high4 - 1;
      high4 = haxe._Int32.Int32_Impl_.clamp(high4);
    end;
    local this24 = haxe._Int64.___Int64.new(high4,low4);
    modulus = this24;
  end;
  do return _hx_o({__fields__={quotient=true,modulus=true},quotient=quotient,modulus=modulus}) end;
end
haxe._Int64.Int64_Impl_.neg = function(x)
  local a = x.high;
  local high = _hx_bit_clamp(_hx_bit.bnot(a));
  local low = -x.low;
  if (low == 0) then
    high = high + 1;
    local ret = high - 1;
    high = haxe._Int32.Int32_Impl_.clamp(high);
  end;
  local this1 = haxe._Int64.___Int64.new(high,low);
  do return this1 end;
end
haxe._Int64.Int64_Impl_.preIncrement = function(this1)
  local this2 = haxe._Int64.___Int64.new(this1.high,this1.low);
  this1 = this2;
  local ret = (function()
  local _hx_obj = this1;
  local _hx_fld = 'low';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  this1.low = haxe._Int32.Int32_Impl_.clamp(this1.low);
  if (this1.low == 0) then
    local ret1 = (function()
    local _hx_obj = this1;
    local _hx_fld = 'high';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    this1.high = haxe._Int32.Int32_Impl_.clamp(this1.high);
  end;
  do return this1 end;
end
haxe._Int64.Int64_Impl_.postIncrement = function(this1)
  local ret = this1;
  local this2 = haxe._Int64.___Int64.new(this1.high,this1.low);
  this1 = this2;
  local ret1 = (function()
  local _hx_obj = this1;
  local _hx_fld = 'low';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  this1.low = haxe._Int32.Int32_Impl_.clamp(this1.low);
  if (this1.low == 0) then
    local ret2 = (function()
    local _hx_obj = this1;
    local _hx_fld = 'high';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    this1.high = haxe._Int32.Int32_Impl_.clamp(this1.high);
  end;
  do return ret end;
end
haxe._Int64.Int64_Impl_.preDecrement = function(this1)
  local this2 = haxe._Int64.___Int64.new(this1.high,this1.low);
  this1 = this2;
  if (this1.low == 0) then
    local ret = (function()
    local _hx_obj = this1;
    local _hx_fld = 'high';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
     return _;
     end)();
    this1.high = haxe._Int32.Int32_Impl_.clamp(this1.high);
  end;
  local ret1 = (function()
  local _hx_obj = this1;
  local _hx_fld = 'low';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
   return _;
   end)();
  this1.low = haxe._Int32.Int32_Impl_.clamp(this1.low);
  do return this1 end;
end
haxe._Int64.Int64_Impl_.postDecrement = function(this1)
  local ret = this1;
  local this2 = haxe._Int64.___Int64.new(this1.high,this1.low);
  this1 = this2;
  if (this1.low == 0) then
    local ret1 = (function()
    local _hx_obj = this1;
    local _hx_fld = 'high';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
     return _;
     end)();
    this1.high = haxe._Int32.Int32_Impl_.clamp(this1.high);
  end;
  local ret2 = (function()
  local _hx_obj = this1;
  local _hx_fld = 'low';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
   return _;
   end)();
  this1.low = haxe._Int32.Int32_Impl_.clamp(this1.low);
  do return ret end;
end
haxe._Int64.Int64_Impl_.add = function(a,b)
  local high = haxe._Int32.Int32_Impl_.clamp(a.high + b.high);
  local low = haxe._Int32.Int32_Impl_.clamp(a.low + b.low);
  if (haxe._Int32.Int32_Impl_.ucompare(low,a.low) < 0) then
    high = high + 1;
    local ret = high - 1;
    high = haxe._Int32.Int32_Impl_.clamp(high);
  end;
  local this1 = haxe._Int64.___Int64.new(high,low);
  do return this1 end;
end
haxe._Int64.Int64_Impl_.addInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local b1 = this1;
  local high = haxe._Int32.Int32_Impl_.clamp(a.high + b1.high);
  local low = haxe._Int32.Int32_Impl_.clamp(a.low + b1.low);
  if (haxe._Int32.Int32_Impl_.ucompare(low,a.low) < 0) then
    high = high + 1;
    local ret = high - 1;
    high = haxe._Int32.Int32_Impl_.clamp(high);
  end;
  local this2 = haxe._Int64.___Int64.new(high,low);
  do return this2 end;
end
haxe._Int64.Int64_Impl_.sub = function(a,b)
  local high = haxe._Int32.Int32_Impl_.clamp(a.high - b.high);
  local low = haxe._Int32.Int32_Impl_.clamp(a.low - b.low);
  if (haxe._Int32.Int32_Impl_.ucompare(a.low,b.low) < 0) then
    high = high - 1;
    local ret = high + 1;
    high = haxe._Int32.Int32_Impl_.clamp(high);
  end;
  local this1 = haxe._Int64.___Int64.new(high,low);
  do return this1 end;
end
haxe._Int64.Int64_Impl_.subInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local b1 = this1;
  local high = haxe._Int32.Int32_Impl_.clamp(a.high - b1.high);
  local low = haxe._Int32.Int32_Impl_.clamp(a.low - b1.low);
  if (haxe._Int32.Int32_Impl_.ucompare(a.low,b1.low) < 0) then
    high = high - 1;
    local ret = high + 1;
    high = haxe._Int32.Int32_Impl_.clamp(high);
  end;
  local this2 = haxe._Int64.___Int64.new(high,low);
  do return this2 end;
end
haxe._Int64.Int64_Impl_.intSub = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a,31),a);
  local a1 = this1;
  local high = haxe._Int32.Int32_Impl_.clamp(a1.high - b.high);
  local low = haxe._Int32.Int32_Impl_.clamp(a1.low - b.low);
  if (haxe._Int32.Int32_Impl_.ucompare(a1.low,b.low) < 0) then
    high = high - 1;
    local ret = high + 1;
    high = haxe._Int32.Int32_Impl_.clamp(high);
  end;
  local this2 = haxe._Int64.___Int64.new(high,low);
  do return this2 end;
end
haxe._Int64.Int64_Impl_.mul = function(a,b)
  local mask = 65535;
  local al = _hx_bit.band(a.low,mask);
  local ah = _hx_bit.rshift(a.low,16);
  local bl = _hx_bit.band(b.low,mask);
  local bh = _hx_bit.rshift(b.low,16);
  local p00 = haxe._Int32.Int32_Impl_.mul(al,bl);
  local p10 = haxe._Int32.Int32_Impl_.mul(ah,bl);
  local p01 = haxe._Int32.Int32_Impl_.mul(al,bh);
  local p11 = haxe._Int32.Int32_Impl_.mul(ah,bh);
  local low = p00;
  local high = haxe._Int32.Int32_Impl_.clamp(haxe._Int32.Int32_Impl_.clamp(p11 + (_hx_bit.rshift(p01,16))) + (_hx_bit.rshift(p10,16)));
  p01 = haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(p01,16));
  low = haxe._Int32.Int32_Impl_.clamp(low + p01);
  if (haxe._Int32.Int32_Impl_.ucompare(low,p01) < 0) then
    high = high + 1;
    local ret = high - 1;
    high = haxe._Int32.Int32_Impl_.clamp(high);
  end;
  p10 = haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(p10,16));
  low = haxe._Int32.Int32_Impl_.clamp(low + p10);
  if (haxe._Int32.Int32_Impl_.ucompare(low,p10) < 0) then
    high = high + 1;
    local ret1 = high - 1;
    high = haxe._Int32.Int32_Impl_.clamp(high);
  end;
  high = haxe._Int32.Int32_Impl_.clamp(high + haxe._Int32.Int32_Impl_.clamp(haxe._Int32.Int32_Impl_.mul(a.low,b.high) + haxe._Int32.Int32_Impl_.mul(a.high,b.low)));
  local this1 = haxe._Int64.___Int64.new(high,low);
  do return this1 end;
end
haxe._Int64.Int64_Impl_.mulInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  do return haxe._Int64.Int64_Impl_.mul(a,this1) end;
end
haxe._Int64.Int64_Impl_.div = function(a,b)
  do return haxe._Int64.Int64_Impl_.divMod(a,b).quotient end;
end
haxe._Int64.Int64_Impl_.divInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  do return haxe._Int64.Int64_Impl_.divMod(a,this1).quotient end;
end
haxe._Int64.Int64_Impl_.intDiv = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a,31),a);
  local x = haxe._Int64.Int64_Impl_.divMod(this1,b).quotient;
  if (x.high ~= haxe._Int32.Int32_Impl_.shr(x.low,31)) then
    _G.error("Overflow",0);
  end;
  local x1 = x.low;
  local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(x1,31),x1);
  do return this2 end;
end
haxe._Int64.Int64_Impl_.mod = function(a,b)
  do return haxe._Int64.Int64_Impl_.divMod(a,b).modulus end;
end
haxe._Int64.Int64_Impl_.modInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local x = haxe._Int64.Int64_Impl_.divMod(a,this1).modulus;
  if (x.high ~= haxe._Int32.Int32_Impl_.shr(x.low,31)) then
    _G.error("Overflow",0);
  end;
  local x1 = x.low;
  local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(x1,31),x1);
  do return this2 end;
end
haxe._Int64.Int64_Impl_.intMod = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a,31),a);
  local x = haxe._Int64.Int64_Impl_.divMod(this1,b).modulus;
  if (x.high ~= haxe._Int32.Int32_Impl_.shr(x.low,31)) then
    _G.error("Overflow",0);
  end;
  local x1 = x.low;
  local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(x1,31),x1);
  do return this2 end;
end
haxe._Int64.Int64_Impl_.eq = function(a,b)
  if (a.high == b.high) then
    do return a.low == b.low end;
  else
    do return false end;
  end;
end
haxe._Int64.Int64_Impl_.eqInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local b1 = this1;
  if (a.high == b1.high) then
    do return a.low == b1.low end;
  else
    do return false end;
  end;
end
haxe._Int64.Int64_Impl_.neq = function(a,b)
  if (not (a.high ~= b.high)) then
    do return a.low ~= b.low end;
  else
    do return true end;
  end;
end
haxe._Int64.Int64_Impl_.neqInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local b1 = this1;
  if (not (a.high ~= b1.high)) then
    do return a.low ~= b1.low end;
  else
    do return true end;
  end;
end
haxe._Int64.Int64_Impl_.lt = function(a,b)
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b.low);
  end;
  do return (function()
    local _hx_1
    if (a.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() < 0 end;
end
haxe._Int64.Int64_Impl_.ltInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local b1 = this1;
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b1.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b1.low);
  end;
  do return (function()
    local _hx_1
    if (a.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b1.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b1.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() < 0 end;
end
haxe._Int64.Int64_Impl_.intLt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a,31),a);
  local a1 = this1;
  local v = haxe._Int32.Int32_Impl_.clamp(a1.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a1.low,b.low);
  end;
  do return (function()
    local _hx_1
    if (a1.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() < 0 end;
end
haxe._Int64.Int64_Impl_.lte = function(a,b)
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b.low);
  end;
  do return (function()
    local _hx_1
    if (a.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() <= 0 end;
end
haxe._Int64.Int64_Impl_.lteInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local b1 = this1;
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b1.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b1.low);
  end;
  do return (function()
    local _hx_1
    if (a.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b1.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b1.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() <= 0 end;
end
haxe._Int64.Int64_Impl_.intLte = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a,31),a);
  local a1 = this1;
  local v = haxe._Int32.Int32_Impl_.clamp(a1.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a1.low,b.low);
  end;
  do return (function()
    local _hx_1
    if (a1.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() <= 0 end;
end
haxe._Int64.Int64_Impl_.gt = function(a,b)
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b.low);
  end;
  do return (function()
    local _hx_1
    if (a.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() > 0 end;
end
haxe._Int64.Int64_Impl_.gtInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local b1 = this1;
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b1.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b1.low);
  end;
  do return (function()
    local _hx_1
    if (a.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b1.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b1.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() > 0 end;
end
haxe._Int64.Int64_Impl_.intGt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a,31),a);
  local a1 = this1;
  local v = haxe._Int32.Int32_Impl_.clamp(a1.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a1.low,b.low);
  end;
  do return (function()
    local _hx_1
    if (a1.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() > 0 end;
end
haxe._Int64.Int64_Impl_.gte = function(a,b)
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b.low);
  end;
  do return (function()
    local _hx_1
    if (a.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() >= 0 end;
end
haxe._Int64.Int64_Impl_.gteInt = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(b,31),b);
  local b1 = this1;
  local v = haxe._Int32.Int32_Impl_.clamp(a.high - b1.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a.low,b1.low);
  end;
  do return (function()
    local _hx_1
    if (a.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b1.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b1.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() >= 0 end;
end
haxe._Int64.Int64_Impl_.intGte = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a,31),a);
  local a1 = this1;
  local v = haxe._Int32.Int32_Impl_.clamp(a1.high - b.high);
  if (v ~= 0) then
    v = v;
  else
    v = haxe._Int32.Int32_Impl_.ucompare(a1.low,b.low);
  end;
  do return (function()
    local _hx_1
    if (a1.high < 0) then
    _hx_1 = (function()
      local _hx_2
      if (b.high < 0) then
      _hx_2 = v; else
      _hx_2 = -1; end
      return _hx_2
    end )(); elseif (b.high >= 0) then
    _hx_1 = v; else
    _hx_1 = 1; end
    return _hx_1
  end )() >= 0 end;
end
haxe._Int64.Int64_Impl_.complement = function(a)
  local a1 = a.high;
  local high = _hx_bit_clamp(_hx_bit.bnot(a1));
  local a2 = a.low;
  local this1 = haxe._Int64.___Int64.new(high,_hx_bit_clamp(_hx_bit.bnot(a2)));
  do return this1 end;
end
haxe._Int64.Int64_Impl_["and"] = function(a,b)
  local this1 = haxe._Int64.___Int64.new(_hx_bit.band(a.high,b.high),_hx_bit.band(a.low,b.low));
  do return this1 end;
end
haxe._Int64.Int64_Impl_["or"] = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_["or"](a.high,b.high),haxe._Int32.Int32_Impl_["or"](a.low,b.low));
  do return this1 end;
end
haxe._Int64.Int64_Impl_.xor = function(a,b)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.xor(a.high,b.high),haxe._Int32.Int32_Impl_.xor(a.low,b.low));
  do return this1 end;
end
haxe._Int64.Int64_Impl_.shl = function(a,b)
  b = _hx_bit.band(b,63);
  if (b == 0) then
    local this1 = haxe._Int64.___Int64.new(a.high,a.low);
    do return this1 end;
  else
    if (b < 32) then
      local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_["or"](haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a.high,b)),_hx_bit.rshift(a.low,32 - b)),haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a.low,b)));
      do return this2 end;
    else
      local this3 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a.low,b - 32)),0);
      do return this3 end;
    end;
  end;
end
haxe._Int64.Int64_Impl_.shr = function(a,b)
  b = _hx_bit.band(b,63);
  if (b == 0) then
    local this1 = haxe._Int64.___Int64.new(a.high,a.low);
    do return this1 end;
  else
    if (b < 32) then
      local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a.high,b),haxe._Int32.Int32_Impl_["or"](haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a.high,32 - b)),_hx_bit.rshift(a.low,b)));
      do return this2 end;
    else
      local this3 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(a.high,31),haxe._Int32.Int32_Impl_.shr(a.high,b - 32));
      do return this3 end;
    end;
  end;
end
haxe._Int64.Int64_Impl_.ushr = function(a,b)
  b = _hx_bit.band(b,63);
  if (b == 0) then
    local this1 = haxe._Int64.___Int64.new(a.high,a.low);
    do return this1 end;
  else
    if (b < 32) then
      local this2 = haxe._Int64.___Int64.new(_hx_bit.rshift(a.high,b),haxe._Int32.Int32_Impl_["or"](haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a.high,32 - b)),_hx_bit.rshift(a.low,b)));
      do return this2 end;
    else
      local this3 = haxe._Int64.___Int64.new(0,_hx_bit.rshift(a.high,b - 32));
      do return this3 end;
    end;
  end;
end
haxe._Int64.Int64_Impl_.get_high = function(this1)
  do return this1.high end;
end
haxe._Int64.Int64_Impl_.set_high = function(this1,x)
  this1.high = x do return this1.high end;
end
haxe._Int64.Int64_Impl_.get_low = function(this1)
  do return this1.low end;
end
haxe._Int64.Int64_Impl_.set_low = function(this1,x)
  this1.low = x do return this1.low end;
end

haxe._Int64.___Int64.new = function(high,low)
  local self = _hx_new(haxe._Int64.___Int64.prototype)
  haxe._Int64.___Int64.super(self,high,low)
  return self
end
haxe._Int64.___Int64.super = function(self,high,low)
  self.high = high;
  self.low = low;
end
_hxClasses["haxe._Int64.___Int64"] = haxe._Int64.___Int64
haxe._Int64.___Int64.__name__ = {"haxe","_Int64","___Int64"}
haxe._Int64.___Int64.prototype = _hx_a(
  'high', nil,
  'low', nil,
  'toString', function(self)
    do return haxe._Int64.Int64_Impl_.toString(self) end
  end
  ,'__class__',  haxe._Int64.___Int64
)

haxe.Int64Helper.new = {}
_hxClasses["haxe.Int64Helper"] = haxe.Int64Helper
haxe.Int64Helper.__name__ = {"haxe","Int64Helper"}
haxe.Int64Helper.parseString = function(sParam)
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(10,31),10);
  local base = this1;
  local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);
  local current = this2;
  local this3 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(1,31),1);
  local multiplier = this3;
  local sIsNegative = false;
  local s = StringTools.trim(sParam);
  if (s:charAt(0) == "-") then
    sIsNegative = true;
    s = s:substring(1,s.length);
  end;
  local len = s.length;
  local _g1 = 0;
  local _g = len;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local digitInt = s:charCodeAt((len - 1) - i) - 48;
    if ((digitInt < 0) or (digitInt > 9)) then
      _G.error("NumberFormatError",0);
    end;
    local this4 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(digitInt,31),digitInt);
    local digit = this4;
    if (sIsNegative) then
      local b = haxe._Int64.Int64_Impl_.mul(multiplier,digit);
      local high = haxe._Int32.Int32_Impl_.clamp(current.high - b.high);
      local low = haxe._Int32.Int32_Impl_.clamp(current.low - b.low);
      if (haxe._Int32.Int32_Impl_.ucompare(current.low,b.low) < 0) then
        high = high - 1;
        local ret = high + 1;
        high = haxe._Int32.Int32_Impl_.clamp(high);
      end;
      local this5 = haxe._Int64.___Int64.new(high,low);
      current = this5;
      if (not (current.high < 0)) then
        _G.error("NumberFormatError: Underflow",0);
      end;
    else
      local b1 = haxe._Int64.Int64_Impl_.mul(multiplier,digit);
      local high1 = haxe._Int32.Int32_Impl_.clamp(current.high + b1.high);
      local low1 = haxe._Int32.Int32_Impl_.clamp(current.low + b1.low);
      if (haxe._Int32.Int32_Impl_.ucompare(low1,current.low) < 0) then
        high1 = high1 + 1;
        local ret1 = high1 - 1;
        high1 = haxe._Int32.Int32_Impl_.clamp(high1);
      end;
      local this6 = haxe._Int64.___Int64.new(high1,low1);
      current = this6;
      if (current.high < 0) then
        _G.error("NumberFormatError: Overflow",0);
      end;
    end;
    multiplier = haxe._Int64.Int64_Impl_.mul(multiplier,base);
    end;
  do return current end;
end
haxe.Int64Helper.fromFloat = function(f)
  if (Math.isNaN(f) or not ((f > -_G.math.huge) and (f < _G.math.huge))) then
    _G.error("Number is NaN or Infinite",0);
  end;
  local noFractions = f - (_G.math.fmod(f, 1));
  if (noFractions > 9007199254740991) then
    _G.error("Conversion overflow",0);
  end;
  if (noFractions < -9007199254740991) then
    _G.error("Conversion underflow",0);
  end;
  local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);
  local result = this1;
  local neg = noFractions < 0;
  local rest = (function()
    local _hx_1
    if (neg) then
    _hx_1 = -noFractions; else
    _hx_1 = noFractions; end
    return _hx_1
  end )();
  local i = 0;
  while (rest >= 1) do
    local curr = _G.math.fmod(rest, 2);
    rest = rest / 2;
    if (curr >= 1) then
      local this2 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(1,31),1);
      local a = this2;
      local b = i;
      b = _hx_bit.band(b,63);
      local b1;
      if (b == 0) then
        local this3 = haxe._Int64.___Int64.new(a.high,a.low);
        b1 = this3;
      else
        if (b < 32) then
          local this4 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_["or"](haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a.high,b)),_hx_bit.rshift(a.low,32 - b)),haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a.low,b)));
          b1 = this4;
        else
          local this5 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.clamp(_hx_bit.lshift(a.low,b - 32)),0);
          b1 = this5;
        end;
      end;
      local high = haxe._Int32.Int32_Impl_.clamp(result.high + b1.high);
      local low = haxe._Int32.Int32_Impl_.clamp(result.low + b1.low);
      if (haxe._Int32.Int32_Impl_.ucompare(low,result.low) < 0) then
        high = high + 1;
        local ret = high - 1;
        high = haxe._Int32.Int32_Impl_.clamp(high);
      end;
      local this6 = haxe._Int64.___Int64.new(high,low);
      result = this6;
    end;
    i = i + 1;
    end;
  if (neg) then
    local a1 = result.high;
    local high1 = _hx_bit_clamp(_hx_bit.bnot(a1));
    local low1 = -result.low;
    if (low1 == 0) then
      high1 = high1 + 1;
      local ret1 = high1 - 1;
      high1 = haxe._Int32.Int32_Impl_.clamp(high1);
    end;
    local this7 = haxe._Int64.___Int64.new(high1,low1);
    result = this7;
  end;
  do return result end;
end

haxe.Json.new = {}
_hxClasses["haxe.Json"] = haxe.Json
haxe.Json.__name__ = {"haxe","Json"}
haxe.Json.parse = function(text)
  do return haxe.format.JsonParser.new(text):parseRec() end;
end
haxe.Json.stringify = function(value,replacer,space)
  do return haxe.format.JsonPrinter.print(value,replacer,space) end;
end

haxe.Log.new = {}
_hxClasses["haxe.Log"] = haxe.Log
haxe.Log.__name__ = {"haxe","Log"}
haxe.Log.trace = function(v,infos)
  local str = nil;
  if (infos ~= nil) then
    str = infos.fileName .. ":" .. infos.lineNumber .. ": " .. Std.string(v);
    if (infos.customParams ~= nil) then
      str = str .. ("," .. infos.customParams:join(","));
    end;
  else
    str = v;
  end;
  if (str == nil) then
    str = "null";
  end;
  _hx_print(str);
end

haxe.ds.BalancedTree.new = function()
  local self = _hx_new(haxe.ds.BalancedTree.prototype)
  haxe.ds.BalancedTree.super(self)
  return self
end
haxe.ds.BalancedTree.super = function(self)
end
_hxClasses["haxe.ds.BalancedTree"] = haxe.ds.BalancedTree
haxe.ds.BalancedTree.__name__ = {"haxe","ds","BalancedTree"}
haxe.ds.BalancedTree.prototype = _hx_a(
  'root', nil,
  'set', function(self,key,value)
    self.root = self:setLoop(key,value,self.root);
  end,
  'get', function(self,key)
    local node = self.root;
    while (node ~= nil) do
      local c = self:compare(key,node.key);
      if (c == 0) then
        do return node.value end;
      end;
      if (c < 0) then
        node = node.left;
      else
        node = node.right;
      end;
      end;
    do return nil end
  end,
  'remove', function(self,key)
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function()

        self.root = self:removeLoop(key,self.root);
        do return true end;
       return _hx_expected_result end)
     if not _hx_status then
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,String) ) then
        local e = _hx_1
        do return false end;
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'exists', function(self,key)
    local node = self.root;
    while (node ~= nil) do
      local c = self:compare(key,node.key);
      if (c == 0) then
        do return true end;
      else
        if (c < 0) then
          node = node.left;
        else
          node = node.right;
        end;
      end;
      end;
    do return false end
  end,
  'iterator', function(self)
    local ret = _hx_tab_array({ }, 0);
    self:iteratorLoop(self.root,ret);
    local _gthis = ret;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self)
      do return cur_length < _gthis.length end;
    end,next=function(self)
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end,
  'keys', function(self)
    local ret = _hx_tab_array({ }, 0);
    self:keysLoop(self.root,ret);
    local _gthis = ret;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self)
      do return cur_length < _gthis.length end;
    end,next=function(self)
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end,
  'setLoop', function(self,k,v,node)
    if (node == nil) then
      do return haxe.ds.TreeNode.new(nil,k,v,nil) end;
    end;
    local c = self:compare(k,node.key);
    if (c == 0) then
      do return haxe.ds.TreeNode.new(node.left,k,v,node.right,(function()
        local _hx_1
        if (node == nil) then
        _hx_1 = 0; else
        _hx_1 = node._height; end
        return _hx_1
      end )()) end;
    else
      if (c < 0) then
        local nl = self:setLoop(k,v,node.left);
        do return self:balance(nl,node.key,node.value,node.right) end;
      else
        local nr = self:setLoop(k,v,node.right);
        do return self:balance(node.left,node.key,node.value,nr) end;
      end;
    end;
  end,
  'removeLoop', function(self,k,node)
    if (node == nil) then
      _G.error("Not_found",0);
    end;
    local c = self:compare(k,node.key);
    if (c == 0) then
      do return self:merge(node.left,node.right) end;
    else
      if (c < 0) then
        do return self:balance(self:removeLoop(k,node.left),node.key,node.value,node.right) end;
      else
        do return self:balance(node.left,node.key,node.value,self:removeLoop(k,node.right)) end;
      end;
    end;
  end,
  'iteratorLoop', function(self,node,acc)
    if (node ~= nil) then
      self:iteratorLoop(node.left,acc);
      acc:push(node.value);
      self:iteratorLoop(node.right,acc);
    end;
  end,
  'keysLoop', function(self,node,acc)
    if (node ~= nil) then
      self:keysLoop(node.left,acc);
      acc:push(node.key);
      self:keysLoop(node.right,acc);
    end;
  end,
  'merge', function(self,t1,t2)
    if (t1 == nil) then
      do return t2 end;
    end;
    if (t2 == nil) then
      do return t1 end;
    end;
    local t = self:minBinding(t2);
    do return self:balance(t1,t.key,t.value,self:removeMinBinding(t2)) end
  end,
  'minBinding', function(self,t)
    if (t == nil) then
      _G.error("Not_found",0);
    else
      if (t.left == nil) then
        do return t end;
      else
        do return self:minBinding(t.left) end;
      end;
    end;
  end,
  'removeMinBinding', function(self,t)
    if (t.left == nil) then
      do return t.right end;
    else
      do return self:balance(self:removeMinBinding(t.left),t.key,t.value,t.right) end;
    end;
  end,
  'balance', function(self,l,k,v,r)
    local hl = (function()
      local _hx_1
      if (l == nil) then
      _hx_1 = 0; else
      _hx_1 = l._height; end
      return _hx_1
    end )();
    local hr = (function()
      local _hx_2
      if (r == nil) then
      _hx_2 = 0; else
      _hx_2 = r._height; end
      return _hx_2
    end )();
    if (hl > (hr + 2)) then
      local _this = l.left;
      local _this1 = l.right;
      if ((function()
        local _hx_3
        if (_this == nil) then
        _hx_3 = 0; else
        _hx_3 = _this._height; end
        return _hx_3
      end )() >= (function()
        local _hx_4
        if (_this1 == nil) then
        _hx_4 = 0; else
        _hx_4 = _this1._height; end
        return _hx_4
      end )()) then
        do return haxe.ds.TreeNode.new(l.left,l.key,l.value,haxe.ds.TreeNode.new(l.right,k,v,r)) end;
      else
        do return haxe.ds.TreeNode.new(haxe.ds.TreeNode.new(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe.ds.TreeNode.new(l.right.right,k,v,r)) end;
      end;
    else
      if (hr > (hl + 2)) then
        local _this2 = r.right;
        local _this3 = r.left;
        if ((function()
          local _hx_5
          if (_this2 == nil) then
          _hx_5 = 0; else
          _hx_5 = _this2._height; end
          return _hx_5
        end )() > (function()
          local _hx_6
          if (_this3 == nil) then
          _hx_6 = 0; else
          _hx_6 = _this3._height; end
          return _hx_6
        end )()) then
          do return haxe.ds.TreeNode.new(haxe.ds.TreeNode.new(l,k,v,r.left),r.key,r.value,r.right) end;
        else
          do return haxe.ds.TreeNode.new(haxe.ds.TreeNode.new(l,k,v,r.left.left),r.left.key,r.left.value,haxe.ds.TreeNode.new(r.left.right,r.key,r.value,r.right)) end;
        end;
      else
        do return haxe.ds.TreeNode.new(l,k,v,r,(function()
          local _hx_7
          if (hl > hr) then
          _hx_7 = hl; else
          _hx_7 = hr; end
          return _hx_7
        end )() + 1) end;
      end;
    end;
  end,
  'compare', function(self,k1,k2)
    do return Reflect.compare(k1,k2) end
  end,
  'toString', function(self)
    if (self.root == nil) then
      do return "{}" end;
    else
      do return "{" .. self.root:toString() .. "}" end;
    end;
  end
  ,'__class__',  haxe.ds.BalancedTree
)

haxe.ds.TreeNode.new = function(l,k,v,r,h)
  local self = _hx_new(haxe.ds.TreeNode.prototype)
  haxe.ds.TreeNode.super(self,l,k,v,r,h)
  return self
end
haxe.ds.TreeNode.super = function(self,l,k,v,r,h)
  if (h == nil) then
    h = -1;
  end;
  self.left = l;
  self.key = k;
  self.value = v;
  self.right = r;
  if (h == -1) then
    local tmp;
    local _this = self.left;
    local _this1 = self.right;
    if ((function()
      local _hx_1
      if (_this == nil) then
      _hx_1 = 0; else
      _hx_1 = _this._height; end
      return _hx_1
    end )() > (function()
      local _hx_2
      if (_this1 == nil) then
      _hx_2 = 0; else
      _hx_2 = _this1._height; end
      return _hx_2
    end )()) then
      local _this2 = self.left;
      if (_this2 == nil) then
        tmp = 0;
      else
        tmp = _this2._height;
      end;
    else
      local _this3 = self.right;
      if (_this3 == nil) then
        tmp = 0;
      else
        tmp = _this3._height;
      end;
    end;
    self._height = tmp + 1;
  else
    self._height = h;
  end;
end
_hxClasses["haxe.ds.TreeNode"] = haxe.ds.TreeNode
haxe.ds.TreeNode.__name__ = {"haxe","ds","TreeNode"}
haxe.ds.TreeNode.prototype = _hx_a(
  'left', nil,
  'right', nil,
  'key', nil,
  'value', nil,
  '_height', nil,
  'toString', function(self)
    do return ((function()
      local _hx_1
      if (self.left == nil) then
      _hx_1 = ""; else
      _hx_1 = self.left:toString() .. ", "; end
      return _hx_1
    end )()) .. ("" .. Std.string(self.key) .. "=" .. Std.string(self.value)) .. ((function()
      local _hx_2
      if (self.right == nil) then
      _hx_2 = ""; else
      _hx_2 = ", " .. self.right:toString(); end
      return _hx_2
    end )()) end
  end
  ,'__class__',  haxe.ds.TreeNode
)

haxe.ds.EnumValueMap.new = function()
  local self = _hx_new(haxe.ds.EnumValueMap.prototype)
  haxe.ds.EnumValueMap.super(self)
  return self
end
haxe.ds.EnumValueMap.super = function(self)
  haxe.ds.BalancedTree.super(self);
end
_hxClasses["haxe.ds.EnumValueMap"] = haxe.ds.EnumValueMap
haxe.ds.EnumValueMap.__name__ = {"haxe","ds","EnumValueMap"}
haxe.ds.EnumValueMap.__interfaces__ = {haxe.IMap}
haxe.ds.EnumValueMap.prototype = _hx_a(
  'compare', function(self,k1,k2)
    local d = k1[1] - k2[1];
    if (d ~= 0) then
      do return d end;
    end;
    local p1 = k1:slice(2);
    local p2 = k2:slice(2);
    if ((p1.length == 0) and (p2.length == 0)) then
      do return 0 end;
    end;
    do return self:compareArgs(p1,p2) end
  end,
  'compareArgs', function(self,a1,a2)
    local ld = a1.length - a2.length;
    if (ld ~= 0) then
      do return ld end;
    end;
    local _g1 = 0;
    local _g = a1.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local d = self:compareArg(a1[i],a2[i]);
      if (d ~= 0) then
        do return d end;
      end;
      end;
    do return 0 end
  end,
  'compareArg', function(self,v1,v2)
    if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)) then
      do return self:compare(v1,v2) end;
    else
      if (lua.Boot.__instanceof(v1,Array) and lua.Boot.__instanceof(v2,Array)) then
        do return self:compareArgs(v1,v2) end;
      else
        do return Reflect.compare(v1,v2) end;
      end;
    end;
  end
  ,'__class__',  haxe.ds.EnumValueMap
)
haxe.ds.EnumValueMap.__super__ = haxe.ds.BalancedTree
setmetatable(haxe.ds.EnumValueMap.prototype,{__index=haxe.ds.BalancedTree.prototype})

haxe.ds.GenericCell.new = function(elt,next)
  local self = _hx_new(haxe.ds.GenericCell.prototype)
  haxe.ds.GenericCell.super(self,elt,next)
  return self
end
haxe.ds.GenericCell.super = function(self,elt,next)
  self.elt = elt;
  self.next = next;
end
_hxClasses["haxe.ds.GenericCell"] = haxe.ds.GenericCell
haxe.ds.GenericCell.__name__ = {"haxe","ds","GenericCell"}
haxe.ds.GenericCell.prototype = _hx_a(
  'elt', nil,
  'next', nil
  ,'__class__',  haxe.ds.GenericCell
)

haxe.ds.GenericStack.new = function()
  local self = _hx_new(haxe.ds.GenericStack.prototype)
  haxe.ds.GenericStack.super(self)
  return self
end
haxe.ds.GenericStack.super = function(self)
end
_hxClasses["haxe.ds.GenericStack"] = haxe.ds.GenericStack
haxe.ds.GenericStack.__name__ = {"haxe","ds","GenericStack"}
haxe.ds.GenericStack.prototype = _hx_a(
  'head', nil,
  'add', function(self,item)
    self.head = haxe.ds.GenericCell.new(item,self.head);
  end,
  'first', function(self)
    if (self.head == nil) then
      do return nil end;
    else
      do return self.head.elt end;
    end;
  end,
  'pop', function(self)
    local k = self.head;
    if (k == nil) then
      do return nil end;
    else
      self.head = k.next;
      do return k.elt end;
    end;
  end,
  'isEmpty', function(self)
    do return self.head == nil end
  end,
  'remove', function(self,v)
    local prev = nil;
    local l = self.head;
    while (l ~= nil) do
      if (l.elt == v) then
        if (prev == nil) then
          self.head = l.next;
        else
          prev.next = l.next;
        end;
        break;
      end;
      prev = l;
      l = l.next;
      end;
    do return l ~= nil end
  end,
  'iterator', function(self)
    local l = self.head;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self)
      do return l ~= nil end;
    end,next=function(self)
      local k = l;
      l = k.next;
      do return k.elt end;
    end}) end
  end,
  'toString', function(self)
    local a = Array.new();
    local l = self.head;
    while (l ~= nil) do
      a:push(l.elt);
      l = l.next;
      end;
    do return "{" .. a:join(",") .. "}" end
  end
  ,'__class__',  haxe.ds.GenericStack
)

haxe.ds._HashMap.HashMap_Impl_.new = {}
_hxClasses["haxe.ds._HashMap.HashMap_Impl_"] = haxe.ds._HashMap.HashMap_Impl_
haxe.ds._HashMap.HashMap_Impl_.__name__ = {"haxe","ds","_HashMap","HashMap_Impl_"}
haxe.ds._HashMap.HashMap_Impl_._new = function()
  local this1 = haxe.ds._HashMap.HashMapData.new();
  do return this1 end;
end
haxe.ds._HashMap.HashMap_Impl_.set = function(this1,k,v)
  local _this = this1.keys;
  local key = k:hashCode();
  _this.h[key] = k;
  local _this1 = this1.values;
  local key1 = k:hashCode();
  _this1.h[key1] = v;
end
haxe.ds._HashMap.HashMap_Impl_.get = function(this1,k)
  local _this = this1.values;
  local key = k:hashCode();
  do return _this.h[key] end;
end
haxe.ds._HashMap.HashMap_Impl_.exists = function(this1,k)
  local _this = this1.values;
  local key = k:hashCode();
  local o = _this.h;
  local field = key;
  if (o.__fields__ ~= nil) then
    do return o.__fields__[field] ~= nil end;
  else
    do return o[field] ~= nil end;
  end;
end
haxe.ds._HashMap.HashMap_Impl_.remove = function(this1,k)
  this1.values:remove(k:hashCode());
  do return this1.keys:remove(k:hashCode()) end;
end
haxe.ds._HashMap.HashMap_Impl_.keys = function(this1)
  do return this1.keys:iterator() end;
end
haxe.ds._HashMap.HashMap_Impl_.iterator = function(this1)
  do return this1.values:iterator() end;
end

haxe.ds._HashMap.HashMapData.new = function()
  local self = _hx_new(haxe.ds._HashMap.HashMapData.prototype)
  haxe.ds._HashMap.HashMapData.super(self)
  return self
end
haxe.ds._HashMap.HashMapData.super = function(self)
  self.keys = haxe.ds.IntMap.new();
  self.values = haxe.ds.IntMap.new();
end
_hxClasses["haxe.ds._HashMap.HashMapData"] = haxe.ds._HashMap.HashMapData
haxe.ds._HashMap.HashMapData.__name__ = {"haxe","ds","_HashMap","HashMapData"}
haxe.ds._HashMap.HashMapData.prototype = _hx_a(
  'keys', nil,
  'values', nil
  ,'__class__',  haxe.ds._HashMap.HashMapData
)

haxe.ds.IntMap.new = function()
  local self = _hx_new(haxe.ds.IntMap.prototype)
  haxe.ds.IntMap.super(self)
  return self
end
haxe.ds.IntMap.super = function(self)
  self.h = _hx_e();
end
_hxClasses["haxe.ds.IntMap"] = haxe.ds.IntMap
haxe.ds.IntMap.__name__ = {"haxe","ds","IntMap"}
haxe.ds.IntMap.__interfaces__ = {haxe.IMap}
haxe.ds.IntMap.prototype = _hx_a(
  'h', nil,
  'set', function(self,key,value)
    self.h[key] = value;
  end,
  'get', function(self,key)
    do return self.h[key] end
  end,
  'exists', function(self,key)
    local o = self.h;
    local field = key;
    if (o.__fields__ ~= nil) then
      do return o.__fields__[field] ~= nil end;
    else
      do return o[field] ~= nil end;
    end;
  end,
  'remove', function(self,key)
    local o = self.h;
    local field = key;
    if (not ((function()
      local _hx_1
      if (o.__fields__ ~= nil) then
      _hx_1 = o.__fields__[field] ~= nil; else
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )())) then
      do return false end;
    end;
    Reflect.deleteField(self.h,key);
    do return true end
  end,
  'keys', function(self)
    local _gthis = Reflect.fields(self.h);
    local cur_length = 0;
    local cur = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self)
      do return cur_length < _gthis.length end;
    end,next=function(self)
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self)
      local ret = cur:next();
      do return ret end;
    end,hasNext=function(self)
      do return cur:hasNext() end;
    end}) end
  end,
  'iterator', function(self)
    local _gthis = self;
    local it = self:keys();
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self)
      do return it:hasNext() end;
    end,next=function(self)
      do return _gthis.h[it:next()] end;
    end}) end
  end,
  'toString', function(self)
    local s_length;
    local s_b = _hx_e();
    s_length = 0;
    local str = "{";
    _G.table.insert(s_b,str);
    s_length = s_length + str.length;
    local it = self:keys();
    local i = it;
    while (i:hasNext()) do
      local i1 = i:next();
      local str1 = Std.string(i1);
      _G.table.insert(s_b,str1);
      s_length = s_length + str1.length;
      local str2 = " => ";
      _G.table.insert(s_b,str2);
      s_length = s_length + str2.length;
      local str3 = Std.string(Std.string(self.h[i1]));
      _G.table.insert(s_b,str3);
      s_length = s_length + str3.length;
      if (it:hasNext()) then
        local str4 = ", ";
        _G.table.insert(s_b,str4);
        s_length = s_length + str4.length;
      end;
      end;
    local str5 = "}";
    _G.table.insert(s_b,str5);
    s_length = s_length + str5.length;
    do return _G.table.concat(s_b) end
  end
  ,'__class__',  haxe.ds.IntMap
)

haxe.ds.ObjectMap.new = function()
  local self = _hx_new(haxe.ds.ObjectMap.prototype)
  haxe.ds.ObjectMap.super(self)
  return self
end
haxe.ds.ObjectMap.super = function(self)
  self.h = ({});
  self.k = ({});
end
_hxClasses["haxe.ds.ObjectMap"] = haxe.ds.ObjectMap
haxe.ds.ObjectMap.__name__ = {"haxe","ds","ObjectMap"}
haxe.ds.ObjectMap.__interfaces__ = {haxe.IMap}
haxe.ds.ObjectMap.assignId = function(obj)
  obj.__id__ = (function()
  local _hx_obj = haxe.ds.ObjectMap;
  local _hx_fld = 'count';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)() do return obj.__id__ end;
end
haxe.ds.ObjectMap.getId = function(obj)
  do return obj.__id__ end;
end
haxe.ds.ObjectMap.prototype = _hx_a(
  'h', nil,
  'k', nil,
  'set', function(self,key,value)
    self.h[key] = value;
    self.k[key] = true;
  end,
  'get', function(self,key)
    do return self.h[key] end
  end,
  'exists', function(self,key)
    do return self.k[key] ~= nil end
  end,
  'remove', function(self,key)
    if (self.k[key] == nil) then
      do return false end;
    end;
    self.k[key] = nil;
    self.h[key] = nil;
    do return true end
  end,
  'keys', function(self)
    local _gthis = self;
    local cur = next(self.h,nil);
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self)
      local ret = cur;
      cur = next(_gthis.k,cur);
      do return ret end;
    end,hasNext=function(self)
      do return cur ~= nil end;
    end}) end
  end,
  'iterator', function(self)
    local _gthis = self;
    local itr = self:keys();
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(_,...) return _hx_bind(itr,itr.hasNext)(...) end,next=function(self)
      do return _gthis.h[itr:next()] end;
    end}) end
  end,
  'toString', function(self)
    local s_length;
    local s_b = _hx_e();
    s_length = 0;
    local str = "{";
    _G.table.insert(s_b,str);
    s_length = s_length + str.length;
    local it = self:keys();
    local i = it;
    while (i:hasNext()) do
      local i1 = i:next();
      local str1 = Std.string(i1);
      _G.table.insert(s_b,str1);
      s_length = s_length + str1.length;
      local str2 = " => ";
      _G.table.insert(s_b,str2);
      s_length = s_length + str2.length;
      local str3 = Std.string(Std.string(self.h[i1]));
      _G.table.insert(s_b,str3);
      s_length = s_length + str3.length;
      if (it:hasNext()) then
        local str4 = ", ";
        _G.table.insert(s_b,str4);
        s_length = s_length + str4.length;
      end;
      end;
    local str5 = "}";
    _G.table.insert(s_b,str5);
    s_length = s_length + str5.length;
    do return _G.table.concat(s_b) end
  end
  ,'__class__',  haxe.ds.ObjectMap
)

haxe.ds.StringMap.new = function()
  local self = _hx_new(haxe.ds.StringMap.prototype)
  haxe.ds.StringMap.super(self)
  return self
end
haxe.ds.StringMap.super = function(self)
  self.v = {}
  self.k = {}
end
_hxClasses["haxe.ds.StringMap"] = haxe.ds.StringMap
haxe.ds.StringMap.__name__ = {"haxe","ds","StringMap"}
haxe.ds.StringMap.__interfaces__ = {haxe.IMap}
haxe.ds.StringMap.prototype = _hx_a(
  'k', nil,
  'v', nil,
  'set', function(self,key,value)
    self.v[key] = value;
    self.k[key] = true;
  end,
  'get', function(self,key)
    do return self.v[key] end
  end,
  'exists', function(self,key)
    do return (self.k[key] or false) end
  end,
  'remove', function(self,key)
    if (not self.k[key]) then
      do return false end;
    end;
    self.v[key] = nil;
    self.k[key] = nil;
    do return true end
  end,
  'keys', function(self)
    local cur = _hx_tab_array({ }, 0);
    for _k,_v in pairs(self.k) do
			if(_v)then cur:push(_k) end
		end;
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self)
      local ret = cur:pop();
      do return ret end;
    end,hasNext=function(self)
      do return cur.length > 0 end;
    end}) end
  end,
  'iterator', function(self)
    local _gthis = self;
    local it = self:keys();
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self)
      do return it:hasNext() end;
    end,next=function(self)
      do return _gthis.v[it:next()] end;
    end}) end
  end,
  'toString', function(self)
    local s_length;
    local s_b = _hx_e();
    s_length = 0;
    local str = "{";
    _G.table.insert(s_b,str);
    s_length = s_length + str.length;
    local it = self:keys();
    local i = it;
    while (i:hasNext()) do
      local i1 = i:next();
      local str1 = Std.string(i1);
      _G.table.insert(s_b,str1);
      s_length = s_length + str1.length;
      local str2 = " => ";
      _G.table.insert(s_b,str2);
      s_length = s_length + str2.length;
      local str3 = Std.string(Std.string(self.v[i1]));
      _G.table.insert(s_b,str3);
      s_length = s_length + str3.length;
      if (it:hasNext()) then
        local str4 = ", ";
        _G.table.insert(s_b,str4);
        s_length = s_length + str4.length;
      end;
      end;
    local str5 = "}";
    _G.table.insert(s_b,str5);
    s_length = s_length + str5.length;
    do return _G.table.concat(s_b) end
  end
  ,'__class__',  haxe.ds.StringMap
)

haxe.ds.WeakMap.new = function()
  local self = _hx_new(haxe.ds.WeakMap.prototype)
  haxe.ds.WeakMap.super(self)
  return self
end
haxe.ds.WeakMap.super = function(self)
  _G.error("Not implemented for this platform",0);
end
_hxClasses["haxe.ds.WeakMap"] = haxe.ds.WeakMap
haxe.ds.WeakMap.__name__ = {"haxe","ds","WeakMap"}
haxe.ds.WeakMap.__interfaces__ = {haxe.IMap}
haxe.ds.WeakMap.prototype = _hx_a(
  'set', function(self,key,value)
  end,
  'get', function(self,key)
    do return nil end
  end,
  'exists', function(self,key)
    do return false end
  end,
  'remove', function(self,key)
    do return false end
  end,
  'keys', function(self)
    do return nil end
  end,
  'iterator', function(self)
    do return nil end
  end,
  'toString', function(self)
    do return nil end
  end
  ,'__class__',  haxe.ds.WeakMap
)

haxe.format.JsonParser.new = function(str)
  local self = _hx_new(haxe.format.JsonParser.prototype)
  haxe.format.JsonParser.super(self,str)
  return self
end
haxe.format.JsonParser.super = function(self,str)
  self.str = str;
  self.pos = 0;
end
_hxClasses["haxe.format.JsonParser"] = haxe.format.JsonParser
haxe.format.JsonParser.__name__ = {"haxe","format","JsonParser"}
haxe.format.JsonParser.parse = function(str)
  do return haxe.format.JsonParser.new(str):parseRec() end;
end
haxe.format.JsonParser.prototype = _hx_a(
  'str', nil,
  'pos', nil,
  'parseRec', function(self)
    while (true) do
      local index = (function()
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local c = _G.string.byte(self.str,index + 1);
      local c1 = c;
      if (c1) == 9 or (c1) == 10 or (c1) == 13 or (c1) == 32 then
      elseif (c1) == 34 then
        do return self:parseString() end;
      elseif (c1) == 45 or (c1) == 48 or (c1) == 49 or (c1) == 50 or (c1) == 51 or (c1) == 52 or (c1) == 53 or (c1) == 54 or (c1) == 55 or (c1) == 56 or (c1) == 57 then
        local c2 = c;
        local start = self.pos - 1;
        local minus = c2 == 45;
        local digit = not minus;
        local zero = c2 == 48;
        local point = false;
        local e = false;
        local pm = false;
        local _end = false;
        while (true) do
          local index1 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          c2 = _G.string.byte(self.str,index1 + 1);
          local c3 = c2;
          if (c3) == 43 or (c3) == 45 then
            if (not e or pm) then
              self:invalidNumber(start);
            end;
            digit = false;
            pm = true;
          elseif (c3) == 46 then
            if (minus or point) then
              self:invalidNumber(start);
            end;
            digit = false;
            point = true;
          elseif (c3) == 48 then
            if (zero and not point) then
              self:invalidNumber(start);
            end;
            if (minus) then
              minus = false;
              zero = true;
            end;
            digit = true;
          elseif (c3) == 49 or (c3) == 50 or (c3) == 51 or (c3) == 52 or (c3) == 53 or (c3) == 54 or (c3) == 55 or (c3) == 56 or (c3) == 57 then
            if (zero and not point) then
              self:invalidNumber(start);
            end;
            if (minus) then
              minus = false;
            end;
            digit = true;
            zero = false;
          elseif (c3) == 69 or (c3) == 101 then
            if ((minus or zero) or e) then
              self:invalidNumber(start);
            end;
            digit = false;
            e = true;else
          if (not digit) then
            self:invalidNumber(start);
          end;
          self.pos = self.pos - 1;
          _end = true; end;
          if (_end) then
            break;
          end;
          end;
        local f = Std.parseFloat(self.str:substr(start,self.pos - start));
        local i = Std.int(f);
        if (i == f) then
          do return i end;
        else
          do return f end;
        end;
      elseif (c1) == 91 then
        local arr = _hx_tab_array({ }, 0);
        local comma = nil;
        while (true) do
          local index2 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local c4 = _G.string.byte(self.str,index2 + 1);
          local c5 = c4;
          if (c5) == 9 or (c5) == 10 or (c5) == 13 or (c5) == 32 then
          elseif (c5) == 44 then
            if (comma) then
              comma = false;
            else
              self:invalidChar();
            end;
          elseif (c5) == 93 then
            if (comma == false) then
              self:invalidChar();
            end;
            do return arr end;else
          if (comma) then
            self:invalidChar();
          end;
          self.pos = self.pos - 1;
          arr:push(self:parseRec());
          comma = true; end;
          end;
      elseif (c1) == 102 then
        local save = self.pos;
        local tmp;
        local tmp1;
        local tmp2;
        local index3 = (function()
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index3 + 1) == 97) then
          local index4 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp2 = _G.string.byte(self.str,index4 + 1) ~= 108;
        else
          tmp2 = true;
        end;
        if (not tmp2) then
          local index5 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp1 = _G.string.byte(self.str,index5 + 1) ~= 115;
        else
          tmp1 = true;
        end;
        if (not tmp1) then
          local index6 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp = _G.string.byte(self.str,index6 + 1) ~= 101;
        else
          tmp = true;
        end;
        if (tmp) then
          self.pos = save;
          self:invalidChar();
        end;
        do return false end;
      elseif (c1) == 110 then
        local save1 = self.pos;
        local tmp3;
        local tmp4;
        local index7 = (function()
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index7 + 1) == 117) then
          local index8 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp4 = _G.string.byte(self.str,index8 + 1) ~= 108;
        else
          tmp4 = true;
        end;
        if (not tmp4) then
          local index9 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp3 = _G.string.byte(self.str,index9 + 1) ~= 108;
        else
          tmp3 = true;
        end;
        if (tmp3) then
          self.pos = save1;
          self:invalidChar();
        end;
        do return nil end;
      elseif (c1) == 116 then
        local save2 = self.pos;
        local tmp5;
        local tmp6;
        local index10 = (function()
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        if (_G.string.byte(self.str,index10 + 1) == 114) then
          local index11 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp6 = _G.string.byte(self.str,index11 + 1) ~= 117;
        else
          tmp6 = true;
        end;
        if (not tmp6) then
          local index12 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          tmp5 = _G.string.byte(self.str,index12 + 1) ~= 101;
        else
          tmp5 = true;
        end;
        if (tmp5) then
          self.pos = save2;
          self:invalidChar();
        end;
        do return true end;
      elseif (c1) == 123 then
        local obj = _hx_e();
        local field = nil;
        local comma1 = nil;
        while (true) do
          local index13 = (function()
          local _hx_obj = self;
          local _hx_fld = 'pos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local c6 = _G.string.byte(self.str,index13 + 1);
          local c7 = c6;
          if (c7) == 9 or (c7) == 10 or (c7) == 13 or (c7) == 32 then
          elseif (c7) == 34 then
            if (comma1) then
              self:invalidChar();
            end;
            field = self:parseString();
          elseif (c7) == 44 then
            if (comma1) then
              comma1 = false;
            else
              self:invalidChar();
            end;
          elseif (c7) == 58 then
            if (field == nil) then
              self:invalidChar();
            end;
            obj[field] = self:parseRec();
            field = nil;
            comma1 = true;
          elseif (c7) == 125 then
            if ((field ~= nil) or (comma1 == false)) then
              self:invalidChar();
            end;
            do return obj end;else
          self:invalidChar(); end;
          end;else
      self:invalidChar(); end;
      end;
  end,
  'parseString', function(self)
    local start = self.pos;
    local buf = nil;
    while (true) do
      local index = (function()
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local c = _G.string.byte(self.str,index + 1);
      if (c == 34) then
        break;
      end;
      if (c == 92) then
        if (buf == nil) then
          buf = StringBuf.new();
        end;
        local s = self.str;
        local len = (self.pos - start) - 1;
        local part = (function()
          local _hx_1
          if (len == nil) then
          _hx_1 = s:substr(start); else
          _hx_1 = s:substr(start,len); end
          return _hx_1
        end )();
        _G.table.insert(buf.b,part);
        local buf1 = buf;
        buf1.length = buf1.length + part.length;
        local index1 = (function()
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        c = _G.string.byte(self.str,index1 + 1);
        local c1 = c;
        if (c1) == 34 or (c1) == 47 or (c1) == 92 then
          _G.table.insert(buf.b,_G.string.char(c));
          local buf2 = buf;
          buf2.length = buf2.length + 1;
        elseif (c1) == 98 then
          _G.table.insert(buf.b,_G.string.char(8));
          local buf3 = buf;
          buf3.length = buf3.length + 1;
        elseif (c1) == 102 then
          _G.table.insert(buf.b,_G.string.char(12));
          local buf4 = buf;
          buf4.length = buf4.length + 1;
        elseif (c1) == 110 then
          _G.table.insert(buf.b,_G.string.char(10));
          local buf5 = buf;
          buf5.length = buf5.length + 1;
        elseif (c1) == 114 then
          _G.table.insert(buf.b,_G.string.char(13));
          local buf6 = buf;
          buf6.length = buf6.length + 1;
        elseif (c1) == 116 then
          _G.table.insert(buf.b,_G.string.char(9));
          local buf7 = buf;
          buf7.length = buf7.length + 1;
        elseif (c1) == 117 then
          local uc = Std.parseInt("0x" .. self.str:substr(self.pos,4));
          local tmp = self;
          tmp.pos = tmp.pos + 4;
          if (uc <= 127) then
            _G.table.insert(buf.b,_G.string.char(uc));
            local buf8 = buf;
            buf8.length = buf8.length + 1;
          else
            if (uc <= 2047) then
              _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(192,_hx_bit.arshift(uc,6))));
              local buf9 = buf;
              buf9.length = buf9.length + 1;
              _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
              local buf10 = buf;
              buf10.length = buf10.length + 1;
            else
              if (uc <= 65535) then
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(224,_hx_bit.arshift(uc,12))));
                local buf11 = buf;
                buf11.length = buf11.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,6),63))));
                local buf12 = buf;
                buf12.length = buf12.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
                local buf13 = buf;
                buf13.length = buf13.length + 1;
              else
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(240,_hx_bit.arshift(uc,18))));
                local buf14 = buf;
                buf14.length = buf14.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,12),63))));
                local buf15 = buf;
                buf15.length = buf15.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(_hx_bit.arshift(uc,6),63))));
                local buf16 = buf;
                buf16.length = buf16.length + 1;
                _G.table.insert(buf.b,_G.string.char(_hx_bit.bor(128,_hx_bit.band(uc,63))));
                local buf17 = buf;
                buf17.length = buf17.length + 1;
              end;
            end;
          end;else
        _G.error("Invalid escape sequence \\" .. _G.string.char(c) .. " at position " .. (self.pos - 1),0); end;
        start = self.pos;
      else
        if (c == nil) then
          _G.error("Unclosed string",0);
        end;
      end;
      end;
    if (buf == nil) then
      do return self.str:substr(start,(self.pos - start) - 1) end;
    else
      local s1 = self.str;
      local len1 = (self.pos - start) - 1;
      local part1 = (function()
        local _hx_2
        if (len1 == nil) then
        _hx_2 = s1:substr(start); else
        _hx_2 = s1:substr(start,len1); end
        return _hx_2
      end )();
      _G.table.insert(buf.b,part1);
      local buf18 = buf;
      buf18.length = buf18.length + part1.length;
      do return _G.table.concat(buf.b) end;
    end;
  end,
  'parseNumber', function(self,c)
    local start = self.pos - 1;
    local minus = c == 45;
    local digit = not minus;
    local zero = c == 48;
    local point = false;
    local e = false;
    local pm = false;
    local _end = false;
    while (true) do
      local index = (function()
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      c = _G.string.byte(self.str,index + 1);
      local c1 = c;
      if (c1) == 43 or (c1) == 45 then
        if (not e or pm) then
          self:invalidNumber(start);
        end;
        digit = false;
        pm = true;
      elseif (c1) == 46 then
        if (minus or point) then
          self:invalidNumber(start);
        end;
        digit = false;
        point = true;
      elseif (c1) == 48 then
        if (zero and not point) then
          self:invalidNumber(start);
        end;
        if (minus) then
          minus = false;
          zero = true;
        end;
        digit = true;
      elseif (c1) == 49 or (c1) == 50 or (c1) == 51 or (c1) == 52 or (c1) == 53 or (c1) == 54 or (c1) == 55 or (c1) == 56 or (c1) == 57 then
        if (zero and not point) then
          self:invalidNumber(start);
        end;
        if (minus) then
          minus = false;
        end;
        digit = true;
        zero = false;
      elseif (c1) == 69 or (c1) == 101 then
        if ((minus or zero) or e) then
          self:invalidNumber(start);
        end;
        digit = false;
        e = true;else
      if (not digit) then
        self:invalidNumber(start);
      end;
      self.pos = self.pos - 1;
      _end = true; end;
      if (_end) then
        break;
      end;
      end;
    local f = Std.parseFloat(self.str:substr(start,self.pos - start));
    local i = Std.int(f);
    if (i == f) then
      do return i end;
    else
      do return f end;
    end;
  end,
  'nextChar', function(self)
    local index = (function()
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    do return _G.string.byte(self.str,index + 1) end
  end,
  'invalidChar', function(self)
    self.pos = self.pos - 1;
    _G.error("Invalid char " .. _G.string.byte(self.str,self.pos + 1) .. " at position " .. self.pos,0);
  end,
  'invalidNumber', function(self,start)
    _G.error("Invalid number at position " .. start .. ": " .. self.str:substr(start,self.pos - start),0);
  end
  ,'__class__',  haxe.format.JsonParser
)

haxe.format.JsonPrinter.new = function(replacer,space)
  local self = _hx_new(haxe.format.JsonPrinter.prototype)
  haxe.format.JsonPrinter.super(self,replacer,space)
  return self
end
haxe.format.JsonPrinter.super = function(self,replacer,space)
  self.replacer = _hx_funcToField(replacer);
  self.indent = space;
  self.pretty = space ~= nil;
  self.nind = 0;
  self.buf = StringBuf.new();
end
_hxClasses["haxe.format.JsonPrinter"] = haxe.format.JsonPrinter
haxe.format.JsonPrinter.__name__ = {"haxe","format","JsonPrinter"}
haxe.format.JsonPrinter.print = function(o,replacer,space)
  local printer = haxe.format.JsonPrinter.new(replacer,space);
  printer:write("",o);
  do return _G.table.concat(printer.buf.b) end;
end
haxe.format.JsonPrinter.prototype = _hx_a(
  'buf', nil,
  'replacer', nil,
  'indent', nil,
  'pretty', nil,
  'nind', nil,
  'ipad', function(self)
    if (self.pretty) then
      local v = StringTools.lpad("",self.indent,self.nind * self.indent.length);
      local _this = self.buf;
      local str = Std.string(v);
      _G.table.insert(_this.b,str);
      local _this1 = _this;
      _this1.length = _this1.length + str.length;
    end;
  end,
  'newl', function(self)
    if (self.pretty) then
      local _this = self.buf;
      _G.table.insert(_this.b,_G.string.char(10));
      local _this1 = _this;
      _this1.length = _this1.length + 1;
    end;
  end,
  'write', function(self,k,v)
    if (self.replacer ~= nil) then
      v = self:replacer(k,v);
    end;
    local _g = Type.typeof(v);
    local _g1 = _g[1];
    if (_g1) == 0 then
      local _this = self.buf;
      local str = "null";
      _G.table.insert(_this.b,str);
      local _this1 = _this;
      _this1.length = _this1.length + str.length;
    elseif (_g1) == 1 then
      local _this2 = self.buf;
      local str1 = Std.string(v);
      _G.table.insert(_this2.b,str1);
      local _this3 = _this2;
      _this3.length = _this3.length + str1.length;
    elseif (_g1) == 2 then
      local _this4 = self.buf;
      local str2;
      local f = v;
      if ((f > -_G.math.huge) and (f < _G.math.huge)) then
        str2 = v;
      else
        str2 = "null";
      end;
      local str3 = Std.string(str2);
      _G.table.insert(_this4.b,str3);
      local _this5 = _this4;
      _this5.length = _this5.length + str3.length;
    elseif (_g1) == 3 then
      local _this6 = self.buf;
      local str4 = Std.string(v);
      _G.table.insert(_this6.b,str4);
      local _this7 = _this6;
      _this7.length = _this7.length + str4.length;
    elseif (_g1) == 4 then
      self:fieldsString(v,Reflect.fields(v));
    elseif (_g1) == 5 then
      local _this8 = self.buf;
      local str5 = "\"<fun>\"";
      _G.table.insert(_this8.b,str5);
      local _this9 = _this8;
      _this9.length = _this9.length + str5.length;
    elseif (_g1) == 6 then
      local c = _g[2];
      if (c == String) then
        self:quote(v);
      else
        if (c == Array) then
          local v1 = v;
          local _this10 = self.buf;
          _G.table.insert(_this10.b,_G.string.char(91));
          local _this11 = _this10;
          _this11.length = _this11.length + 1;
          local len = v1.length;
          local last = len - 1;
          local _g11 = 0;
          local _g2 = len;
          while (_g11 < _g2) do
            _g11 = _g11 + 1;
            local i = _g11 - 1;
            if (i > 0) then
              local _this12 = self.buf;
              _G.table.insert(_this12.b,_G.string.char(44));
              local _this13 = _this12;
              _this13.length = _this13.length + 1;
            else
              self.nind = self.nind + 1;
            end;
            if (self.pretty) then
              local _this14 = self.buf;
              _G.table.insert(_this14.b,_G.string.char(10));
              local _this15 = _this14;
              _this15.length = _this15.length + 1;
            end;
            if (self.pretty) then
              local v2 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
              local _this16 = self.buf;
              local str6 = Std.string(v2);
              _G.table.insert(_this16.b,str6);
              local _this17 = _this16;
              _this17.length = _this17.length + str6.length;
            end;
            self:write(i,v1[i]);
            if (i == last) then
              self.nind = self.nind - 1;
              if (self.pretty) then
                local _this18 = self.buf;
                _G.table.insert(_this18.b,_G.string.char(10));
                local _this19 = _this18;
                _this19.length = _this19.length + 1;
              end;
              if (self.pretty) then
                local v3 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
                local _this20 = self.buf;
                local str7 = Std.string(v3);
                _G.table.insert(_this20.b,str7);
                local _this21 = _this20;
                _this21.length = _this21.length + str7.length;
              end;
            end;
            end;
          local _this22 = self.buf;
          _G.table.insert(_this22.b,_G.string.char(93));
          local _this23 = _this22;
          _this23.length = _this23.length + 1;
        else
          if (c == haxe.ds.StringMap) then
            local v4 = v;
            local o = _hx_e();
            local k1 = v4:keys();
            while (k1:hasNext()) do
              local k2 = k1:next();
              o[k2] = v4.v[k2];
              end;
            self:fieldsString(o,Reflect.fields(o));
          else
            if (c == Date) then
              local v5 = v;
              self:quote(lua.Boot.dateStr(v5));
            else
              self:fieldsString(v,Reflect.fields(v));
            end;
          end;
        end;
      end;
    elseif (_g1) == 7 then
      local i1 = v[1];
      local _this24 = self.buf;
      local str8 = Std.string(i1);
      _G.table.insert(_this24.b,str8);
      local _this25 = _this24;
      _this25.length = _this25.length + str8.length;
    elseif (_g1) == 8 then
      local _this26 = self.buf;
      local str9 = "\"???\"";
      _G.table.insert(_this26.b,str9);
      local _this27 = _this26;
      _this27.length = _this27.length + str9.length; end;
  end,
  'objString', function(self,v)
    self:fieldsString(v,Reflect.fields(v));
  end,
  'fieldsString', function(self,v,fields)
    local _this = self.buf;
    _G.table.insert(_this.b,_G.string.char(123));
    local _this1 = _this;
    _this1.length = _this1.length + 1;
    local len = fields.length;
    local last = len - 1;
    local first = true;
    local _g1 = 0;
    local _g = len;
    local _hx_break_0 = false;
    while (_g1 < _g) do
      repeat
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local f = fields[i];
      local value = Reflect.field(v,f);
      if (Reflect.isFunction(value)) then
        break;
      end;
      if (first) then
        self.nind = self.nind + 1;
        first = false;
      else
        local _this2 = self.buf;
        _G.table.insert(_this2.b,_G.string.char(44));
        local _this3 = _this2;
        _this3.length = _this3.length + 1;
      end;
      if (self.pretty) then
        local _this4 = self.buf;
        _G.table.insert(_this4.b,_G.string.char(10));
        local _this5 = _this4;
        _this5.length = _this5.length + 1;
      end;
      if (self.pretty) then
        local v1 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
        local _this6 = self.buf;
        local str = Std.string(v1);
        _G.table.insert(_this6.b,str);
        local _this7 = _this6;
        _this7.length = _this7.length + str.length;
      end;
      self:quote(f);
      local _this8 = self.buf;
      _G.table.insert(_this8.b,_G.string.char(58));
      local _this9 = _this8;
      _this9.length = _this9.length + 1;
      if (self.pretty) then
        local _this10 = self.buf;
        _G.table.insert(_this10.b,_G.string.char(32));
        local _this11 = _this10;
        _this11.length = _this11.length + 1;
      end;
      self:write(f,value);
      if (i == last) then
        self.nind = self.nind - 1;
        if (self.pretty) then
          local _this12 = self.buf;
          _G.table.insert(_this12.b,_G.string.char(10));
          local _this13 = _this12;
          _this13.length = _this13.length + 1;
        end;
        if (self.pretty) then
          local v2 = StringTools.lpad("",self.indent,self.nind * self.indent.length);
          local _this14 = self.buf;
          local str1 = Std.string(v2);
          _G.table.insert(_this14.b,str1);
          local _this15 = _this14;
          _this15.length = _this15.length + str1.length;
        end;
      end;

    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    local _this16 = self.buf;
    _G.table.insert(_this16.b,_G.string.char(125));
    local _this17 = _this16;
    _this17.length = _this17.length + 1;
  end,
  'quote', function(self,s)
    local _this = self.buf;
    _G.table.insert(_this.b,_G.string.char(34));
    local _this1 = _this;
    _this1.length = _this1.length + 1;
    local i = 0;
    while (true) do
      i = i + 1;
      local c = _G.string.byte(s,(i - 1) + 1);
      if (c == nil) then
        break;
      end;
      local c1 = c;
      if (c1) == 8 then
        local _this2 = self.buf;
        local str = "\\b";
        _G.table.insert(_this2.b,str);
        local _this3 = _this2;
        _this3.length = _this3.length + str.length;
      elseif (c1) == 9 then
        local _this4 = self.buf;
        local str1 = "\\t";
        _G.table.insert(_this4.b,str1);
        local _this5 = _this4;
        _this5.length = _this5.length + str1.length;
      elseif (c1) == 10 then
        local _this6 = self.buf;
        local str2 = "\\n";
        _G.table.insert(_this6.b,str2);
        local _this7 = _this6;
        _this7.length = _this7.length + str2.length;
      elseif (c1) == 12 then
        local _this8 = self.buf;
        local str3 = "\\f";
        _G.table.insert(_this8.b,str3);
        local _this9 = _this8;
        _this9.length = _this9.length + str3.length;
      elseif (c1) == 13 then
        local _this10 = self.buf;
        local str4 = "\\r";
        _G.table.insert(_this10.b,str4);
        local _this11 = _this10;
        _this11.length = _this11.length + str4.length;
      elseif (c1) == 34 then
        local _this12 = self.buf;
        local str5 = "\\\"";
        _G.table.insert(_this12.b,str5);
        local _this13 = _this12;
        _this13.length = _this13.length + str5.length;
      elseif (c1) == 92 then
        local _this14 = self.buf;
        local str6 = "\\\\";
        _G.table.insert(_this14.b,str6);
        local _this15 = _this14;
        _this15.length = _this15.length + str6.length;else
      local _this16 = self.buf;
      _G.table.insert(_this16.b,_G.string.char(c));
      local _this17 = _this16;
      _this17.length = _this17.length + 1; end;
      end;
    local _this18 = self.buf;
    _G.table.insert(_this18.b,_G.string.char(34));
    local _this19 = _this18;
    _this19.length = _this19.length + 1;
  end
  ,'__class__',  haxe.format.JsonPrinter
)

haxe.io.Bytes.new = function(length,b)
  local self = _hx_new(haxe.io.Bytes.prototype)
  haxe.io.Bytes.super(self,length,b)
  return self
end
haxe.io.Bytes.super = function(self,length,b)
  self.length = length;
  self.b = b;
end
_hxClasses["haxe.io.Bytes"] = haxe.io.Bytes
haxe.io.Bytes.__name__ = {"haxe","io","Bytes"}
haxe.io.Bytes.alloc = function(length)
  local a = Array.new();
  local _g1 = 0;
  local _g = length;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    a:push(0);
    end;
  do return haxe.io.Bytes.new(length,a) end;
end
haxe.io.Bytes.ofString = function(s)
  local _g = _hx_tab_array({ }, 0);
  local _g2 = 0;
  local _g1 = s.length;
  while (_g2 < _g1) do
    _g2 = _g2 + 1;
    local c = _g2 - 1;
    _g:push(_G.string.byte(s,c + 1));
    end;
  local bytes = _g;
  do return haxe.io.Bytes.new(bytes.length,bytes) end;
end
haxe.io.Bytes.ofData = function(b)
  do return haxe.io.Bytes.new(b.length,b) end;
end
haxe.io.Bytes.fastGet = function(b,pos)
  do return b[pos] end;
end
haxe.io.Bytes.prototype = _hx_a(
  'length', nil,
  'b', nil,
  'get', function(self,pos)
    do return self.b[pos] end
  end,
  'set', function(self,pos,v)
    self.b[pos] = _hx_bit.band(v,255);
  end,
  'blit', function(self,pos,src,srcpos,len)
    if (((((pos < 0) or (srcpos < 0)) or (len < 0)) or ((pos + len) > self.length)) or ((srcpos + len) > src.length)) then
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b1 = self.b;
    local b2 = src.b;
    if ((b1 == b2) and (pos > srcpos)) then
      local i = len;
      while (i > 0) do
        i = i - 1;
        b1[i + pos] = b2[i + srcpos];
        end;
      do return end;
    end;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i1 = _g1 - 1;
      b1[i1 + pos] = b2[i1 + srcpos];
      end;
  end,
  'fill', function(self,pos,len,value)
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      pos = pos + 1;
      self.b[pos - 1] = _hx_bit.band(value,255);
      end;
  end,
  'sub', function(self,pos,len)
    if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    do return haxe.io.Bytes.new(len,self.b:slice(pos,pos + len)) end
  end,
  'compare', function(self,other)
    local b1 = self.b;
    local b2 = other.b;
    local len = (function()
      local _hx_1
      if (self.length < other.length) then
      _hx_1 = self.length; else
      _hx_1 = other.length; end
      return _hx_1
    end )();
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (b1[i] ~= b2[i]) then
        do return b1[i] - b2[i] end;
      end;
      end;
    do return self.length - other.length end
  end,
  'getDouble', function(self,pos)
    local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
    local tmp = _hx_bit_clamp((function()
      local _hx_1
      if ((_hx_bit.band(v,-2147483648)) ~= 0) then
      _hx_1 = _hx_bit.bor(v,-2147483648); else
      _hx_1 = v; end
      return _hx_1
    end )());
    local pos1 = pos + 4;
    local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos1],_hx_bit.lshift(self.b[pos1 + 1],8)),_hx_bit.lshift(self.b[pos1 + 2],16)),_hx_bit.lshift(self.b[pos1 + 3],24));
    do return haxe.io.FPHelper.i64ToDouble(tmp,_hx_bit_clamp((function()
      local _hx_2
      if ((_hx_bit.band(v1,-2147483648)) ~= 0) then
      _hx_2 = _hx_bit.bor(v1,-2147483648); else
      _hx_2 = v1; end
      return _hx_2
    end )())) end
  end,
  'getFloat', function(self,pos)
    local b = haxe.io.BytesInput.new(self,pos,4);
    do return b:readFloat() end
  end,
  'setDouble', function(self,pos,v)
    local i = haxe.io.FPHelper.doubleToI64(v);
    local v1 = i.low;
    self.b[pos] = _hx_bit.band(v1,255);
    self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v1,8),255);
    self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v1,16),255);
    self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v1,24),255);
    local pos1 = pos + 4;
    local v2 = i.high;
    self.b[pos1] = _hx_bit.band(v2,255);
    self.b[pos1 + 1] = _hx_bit.band(_hx_bit.arshift(v2,8),255);
    self.b[pos1 + 2] = _hx_bit.band(_hx_bit.arshift(v2,16),255);
    self.b[pos1 + 3] = _hx_bit.band(_hx_bit.rshift(v2,24),255);
  end,
  'setFloat', function(self,pos,v)
    local v1 = haxe.io.FPHelper.floatToI32(v);
    self.b[pos] = _hx_bit.band(v1,255);
    self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v1,8),255);
    self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v1,16),255);
    self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v1,24),255);
  end,
  'getUInt16', function(self,pos)
    do return _hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)) end
  end,
  'setUInt16', function(self,pos,v)
    self.b[pos] = _hx_bit.band(v,255);
    self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v,8),255);
  end,
  'getInt32', function(self,pos)
    local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
    do return _hx_bit_clamp((function()
      local _hx_1
      if ((_hx_bit.band(v,-2147483648)) ~= 0) then
      _hx_1 = _hx_bit.bor(v,-2147483648); else
      _hx_1 = v; end
      return _hx_1
    end )()) end
  end,
  'getInt64', function(self,pos)
    local pos1 = pos + 4;
    local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos1],_hx_bit.lshift(self.b[pos1 + 1],8)),_hx_bit.lshift(self.b[pos1 + 2],16)),_hx_bit.lshift(self.b[pos1 + 3],24));
    local high = _hx_bit_clamp((function()
      local _hx_1
      if ((_hx_bit.band(v,-2147483648)) ~= 0) then
      _hx_1 = _hx_bit.bor(v,-2147483648); else
      _hx_1 = v; end
      return _hx_1
    end )());
    local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
    local this1 = haxe._Int64.___Int64.new(high,_hx_bit_clamp((function()
      local _hx_2
      if ((_hx_bit.band(v1,-2147483648)) ~= 0) then
      _hx_2 = _hx_bit.bor(v1,-2147483648); else
      _hx_2 = v1; end
      return _hx_2
    end )()));
    do return this1 end
  end,
  'setInt32', function(self,pos,v)
    self.b[pos] = _hx_bit.band(v,255);
    self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v,8),255);
    self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v,16),255);
    self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v,24),255);
  end,
  'setInt64', function(self,pos,v)
    local v1 = v.low;
    self.b[pos] = _hx_bit.band(v1,255);
    self.b[pos + 1] = _hx_bit.band(_hx_bit.arshift(v1,8),255);
    self.b[pos + 2] = _hx_bit.band(_hx_bit.arshift(v1,16),255);
    self.b[pos + 3] = _hx_bit.band(_hx_bit.rshift(v1,24),255);
    local pos1 = pos + 4;
    local v2 = v.high;
    self.b[pos1] = _hx_bit.band(v2,255);
    self.b[pos1 + 1] = _hx_bit.band(_hx_bit.arshift(v2,8),255);
    self.b[pos1 + 2] = _hx_bit.band(_hx_bit.arshift(v2,16),255);
    self.b[pos1 + 3] = _hx_bit.band(_hx_bit.rshift(v2,24),255);
  end,
  'getString', function(self,pos,len)
    if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b = self.b.length;
    local begin = lua.Boot.__cast((function()
      local _hx_1
      if (Math.isNaN(pos) or Math.isNaN(b)) then
      _hx_1 = (0/0); else
      _hx_1 = _G.math.min(pos,b); end
      return _hx_1
    end )() , Int);
    local a = pos + len;
    local b1 = self.b.length;
    local _end = lua.Boot.__cast((function()
      local _hx_2
      if (Math.isNaN(a) or Math.isNaN(b1)) then
      _hx_2 = (0/0); else
      _hx_2 = _G.math.min(a,b1); end
      return _hx_2
    end )() , Int);
    local _g = _hx_tab_array({ }, 0);
    local _g2 = begin;
    local _g1 = _end;
    while (_g2 < _g1) do
      _g2 = _g2 + 1;
      local i = _g2 - 1;
      _g:push(_G.string.char(self.b[i]));
      end;
    do return _g:join("") end
  end,
  'readString', function(self,pos,len)
    do return self:getString(pos,len) end
  end,
  'toString', function(self)
    do return self:getString(0,self.length) end
  end,
  'toHex', function(self)
    local s_length;
    local s_b = _hx_e();
    s_length = 0;
    local chars = _hx_tab_array({ }, 0);
    local str = "0123456789abcdef";
    local _g1 = 0;
    local _g = str.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      chars:push(str:charCodeAt(i));
      end;
    local _g11 = 0;
    local _g2 = self.length;
    while (_g11 < _g2) do
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      local c = self.b[i1];
      _G.table.insert(s_b,_G.string.char(chars[_hx_bit.arshift(c,4)]));
      s_length = s_length + 1;
      _G.table.insert(s_b,_G.string.char(chars[_hx_bit.band(c,15)]));
      s_length = s_length + 1;
      end;
    do return _G.table.concat(s_b) end
  end,
  'getData', function(self)
    do return self.b end
  end
  ,'__class__',  haxe.io.Bytes
)

haxe.io.BytesBuffer.new = function()
  local self = _hx_new(haxe.io.BytesBuffer.prototype)
  haxe.io.BytesBuffer.super(self)
  return self
end
haxe.io.BytesBuffer.super = function(self)
  self.b = Array.new();
end
_hxClasses["haxe.io.BytesBuffer"] = haxe.io.BytesBuffer
haxe.io.BytesBuffer.__name__ = {"haxe","io","BytesBuffer"}
haxe.io.BytesBuffer.prototype = _hx_a(
  'b', nil,
  'get_length', function(self)
    do return self.b.length end
  end,
  'addByte', function(self,byte)
    self.b:push(byte);
  end,
  'add', function(self,src)
    local b1 = self.b;
    local b2 = src.b;
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self.b:push(b2[i]);
      end;
  end,
  'addString', function(self,v)
    local src = haxe.io.Bytes.ofString(v);
    local b1 = self.b;
    local b2 = src.b;
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self.b:push(b2[i]);
      end;
  end,
  'addInt32', function(self,v)
    self.b:push(_hx_bit.band(v,255));
    self.b:push(_hx_bit.band(_hx_bit.arshift(v,8),255));
    self.b:push(_hx_bit.band(_hx_bit.arshift(v,16),255));
    self.b:push(_hx_bit.rshift(v,24));
  end,
  'addInt64', function(self,v)
    self:addInt32(v.low);
    self:addInt32(v.high);
  end,
  'addFloat', function(self,v)
    self:addInt32(haxe.io.FPHelper.floatToI32(v));
  end,
  'addDouble', function(self,v)
    self:addInt64(haxe.io.FPHelper.doubleToI64(v));
  end,
  'addBytes', function(self,src,pos,len)
    if (((pos < 0) or (len < 0)) or ((pos + len) > src.length)) then
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b1 = self.b;
    local b2 = src.b;
    local _g1 = pos;
    local _g = pos + len;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self.b:push(b2[i]);
      end;
  end,
  'getBytes', function(self)
    local bytes = haxe.io.Bytes.new(self.b.length,self.b);
    self.b = nil;
    do return bytes end
  end
  ,'__class__',  haxe.io.BytesBuffer,
  '__properties__',  {get_length="get_length"}
)

haxe.io.Input.new = {}
_hxClasses["haxe.io.Input"] = haxe.io.Input
haxe.io.Input.__name__ = {"haxe","io","Input"}
haxe.io.Input.prototype = _hx_a(
  'bigEndian', nil,
  'readByte', function(self)
    _G.error("Not implemented",0);
  end,
  'readBytes', function(self,s,pos,len)
    local k = len;
    local b = s.b;
    if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function()

        while (k > 0) do
          b[pos] = self:readByte();
          pos = pos + 1;
          k = k - 1;
          end;
       return _hx_expected_result end)
     if not _hx_status then
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Eof) ) then
        local eof = _hx_1
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    do return len - k end
  end,
  'close', function(self)
  end,
  'set_bigEndian', function(self,b)
    self.bigEndian = b;
    do return b end
  end,
  'readAll', function(self,bufsize)
    if (bufsize == nil) then
      bufsize = 16384;
    end;
    local buf = haxe.io.Bytes.alloc(bufsize);
    local total = haxe.io.BytesBuffer.new();
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function()

        while (true) do
          local len = self:readBytes(buf,0,bufsize);
          if (len == 0) then
            _G.error(haxe.io.Error.Blocked,0);
          end;
          if ((len < 0) or (len > buf.length)) then
            _G.error(haxe.io.Error.OutsideBounds,0);
          end;
          local b1 = total.b;
          local b2 = buf.b;
          local _g1 = 0;
          local _g = len;
          while (_g1 < _g) do
            _g1 = _g1 + 1;
            local i = _g1 - 1;
            total.b:push(b2[i]);
            end;
          end;
       return _hx_expected_result end)
     if not _hx_status then
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Eof) ) then
        local e = _hx_1
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    do return total:getBytes() end
  end,
  'readFullBytes', function(self,s,pos,len)
    while (len > 0) do
      local k = self:readBytes(s,pos,len);
      if (k == 0) then
        _G.error(haxe.io.Error.Blocked,0);
      end;
      pos = pos + k;
      len = len - k;
      end;
  end,
  'read', function(self,nbytes)
    local s = haxe.io.Bytes.alloc(nbytes);
    local p = 0;
    while (nbytes > 0) do
      local k = self:readBytes(s,p,nbytes);
      if (k == 0) then
        _G.error(haxe.io.Error.Blocked,0);
      end;
      p = p + k;
      nbytes = nbytes - k;
      end;
    do return s end
  end,
  'readUntil', function(self,_end)
    local buf = haxe.io.BytesBuffer.new();
    local last;
    while (true) do
      last = self:readByte();
      if (not (last ~= _end)) then
        break;
      end;
      buf.b:push(last);
      end;
    do return buf:getBytes():toString() end
  end,
  'readLine', function(self)
    local buf = haxe.io.BytesBuffer.new();
    local last;
    local s;
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function()

        while (true) do
          last = self:readByte();
          if (not (last ~= 10)) then
            break;
          end;
          buf.b:push(last);
          end;
        s = buf:getBytes():toString();
        if (s:charCodeAt(s.length - 1) == 13) then
          s = s:substr(0,-1);
        end;
       return _hx_expected_result end)
     if not _hx_status then
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Eof) ) then
        local e = _hx_1
        s = buf:getBytes():toString();
        if (s.length == 0) then
          _G.error(e,0);
        end;
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    do return s end
  end,
  'readFloat', function(self)
    do return haxe.io.FPHelper.i32ToFloat(self:readInt32()) end
  end,
  'readDouble', function(self)
    local i1 = self:readInt32();
    local i2 = self:readInt32();
    if (self.bigEndian) then
      do return haxe.io.FPHelper.i64ToDouble(i2,i1) end;
    else
      do return haxe.io.FPHelper.i64ToDouble(i1,i2) end;
    end;
  end,
  'readInt8', function(self)
    local n = self:readByte();
    if (n >= 128) then
      do return n - 256 end;
    end;
    do return n end
  end,
  'readInt16', function(self)
    local ch1 = self:readByte();
    local ch2 = self:readByte();
    local n = (function()
      local _hx_1
      if (self.bigEndian) then
      _hx_1 = _hx_bit.bor(ch2,_hx_bit.lshift(ch1,8)); else
      _hx_1 = _hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)); end
      return _hx_1
    end )();
    if ((_hx_bit.band(n,32768)) ~= 0) then
      do return n - 65536 end;
    end;
    do return n end
  end,
  'readUInt16', function(self)
    local ch1 = self:readByte();
    local ch2 = self:readByte();
    if (self.bigEndian) then
      do return _hx_bit.bor(ch2,_hx_bit.lshift(ch1,8)) end;
    else
      do return _hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)) end;
    end;
  end,
  'readInt24', function(self)
    local ch1 = self:readByte();
    local ch2 = self:readByte();
    local ch3 = self:readByte();
    local n = (function()
      local _hx_1
      if (self.bigEndian) then
      _hx_1 = _hx_bit.bor(_hx_bit.bor(ch3,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch1,16)); else
      _hx_1 = _hx_bit.bor(_hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch3,16)); end
      return _hx_1
    end )();
    if ((_hx_bit.band(n,8388608)) ~= 0) then
      do return n - 16777216 end;
    end;
    do return n end
  end,
  'readUInt24', function(self)
    local ch1 = self:readByte();
    local ch2 = self:readByte();
    local ch3 = self:readByte();
    if (self.bigEndian) then
      do return _hx_bit.bor(_hx_bit.bor(ch3,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch1,16)) end;
    else
      do return _hx_bit.bor(_hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch3,16)) end;
    end;
  end,
  'readInt32', function(self)
    local ch1 = self:readByte();
    local ch2 = self:readByte();
    local ch3 = self:readByte();
    local ch4 = self:readByte();
    local n = (function()
      local _hx_1
      if (self.bigEndian) then
      _hx_1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(ch4,_hx_bit.lshift(ch3,8)),_hx_bit.lshift(ch2,16)),_hx_bit.lshift(ch1,24)); else
      _hx_1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch3,16)),_hx_bit.lshift(ch4,24)); end
      return _hx_1
    end )();
    do return _hx_bit_clamp(n) end
  end,
  'readString', function(self,len)
    local b = haxe.io.Bytes.alloc(len);
    self:readFullBytes(b,0,len);
    do return b:toString() end
  end
  ,'__class__',  haxe.io.Input,
  '__properties__',  {set_bigEndian="set_bigEndian"}
)

haxe.io.BytesInput.new = function(b,pos,len)
  local self = _hx_new(haxe.io.BytesInput.prototype)
  haxe.io.BytesInput.super(self,b,pos,len)
  return self
end
haxe.io.BytesInput.super = function(self,b,pos,len)
  if (pos == nil) then
    pos = 0;
  end;
  if (len == nil) then
    len = b.length - pos;
  end;
  if (((pos < 0) or (len < 0)) or ((pos + len) > b.length)) then
    _G.error(haxe.io.Error.OutsideBounds,0);
  end;
  self.b = b.b;
  self.pos = pos;
  self.len = len;
  self.totlen = len;
end
_hxClasses["haxe.io.BytesInput"] = haxe.io.BytesInput
haxe.io.BytesInput.__name__ = {"haxe","io","BytesInput"}
haxe.io.BytesInput.prototype = _hx_a(
  'b', nil,
  'pos', nil,
  'len', nil,
  'totlen', nil,
  'get_position', function(self)
    do return self.pos end
  end,
  'get_length', function(self)
    do return self.totlen end
  end,
  'set_position', function(self,p)
    if (p < 0) then
      p = 0;
    else
      if (p > self.totlen) then
        p = self.totlen;
      end;
    end;
    self.len = self.totlen - p;
    self.pos = p do return self.pos end
  end,
  'readByte', function(self)
    if (self.len == 0) then
      _G.error(haxe.io.Eof.new(),0);
    end;
    self.len = self.len - 1;
    do return self.b[(function()
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)()] end
  end,
  'readBytes', function(self,buf,pos,len)
    if (((pos < 0) or (len < 0)) or ((pos + len) > buf.length)) then
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    if ((self.len == 0) and (len > 0)) then
      _G.error(haxe.io.Eof.new(),0);
    end;
    if (self.len < len) then
      len = self.len;
    end;
    local b1 = self.b;
    local b2 = buf.b;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      b2[pos + i] = b1[self.pos + i];
      end;
    local tmp = self;
    tmp.pos = tmp.pos + len;
    local tmp1 = self;
    tmp1.len = tmp1.len - len;
    do return len end
  end
  ,'__class__',  haxe.io.BytesInput,
  '__properties__',  {get_length="get_length",set_position="set_position",get_position="get_position"}
)
haxe.io.BytesInput.__super__ = haxe.io.Input
setmetatable(haxe.io.BytesInput.prototype,{__index=haxe.io.Input.prototype})
setmetatable(haxe.io.BytesInput.prototype.__properties__,{__index=haxe.io.Input.prototype.__properties__})

haxe.io.Eof.new = function()
  local self = _hx_new(haxe.io.Eof.prototype)
  haxe.io.Eof.super(self)
  return self
end
haxe.io.Eof.super = function(self)
end
_hxClasses["haxe.io.Eof"] = haxe.io.Eof
haxe.io.Eof.__name__ = {"haxe","io","Eof"}
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self)
    do return "Eof" end
  end
  ,'__class__',  haxe.io.Eof
)
_hxClasses["haxe.io.Error"] = haxe.io.Error;
_hxClasses["haxe.io.Error"] = { __ename__ = {"haxe","io","Error"}, __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
haxe.io.Error = _hxClasses["haxe.io.Error"];
haxe.io.Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = haxe.io.Error},2)
rawset(haxe.io.Error.Blocked, 'toString', _estr)

haxe.io.Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = haxe.io.Error},2)
rawset(haxe.io.Error.Overflow, 'toString', _estr)

haxe.io.Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = haxe.io.Error},2)
rawset(haxe.io.Error.OutsideBounds, 'toString', _estr)

haxe.io.Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=haxe.io.Error}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.io.Error.__empty_constructs__ = _hx_tab_array({[0] = haxe.io.Error.Blocked,haxe.io.Error.Overflow,haxe.io.Error.OutsideBounds}, 3)

haxe.io.FPHelper.new = {}
_hxClasses["haxe.io.FPHelper"] = haxe.io.FPHelper
haxe.io.FPHelper.__name__ = {"haxe","io","FPHelper"}
haxe.io.FPHelper.i32ToFloat = function(i)
  local sign = 1 - (_hx_bit.lshift(_hx_bit.rshift(i,31),1));
  local exp = _hx_bit.band(_hx_bit.rshift(i,23),255);
  local sig = _hx_bit.band(i,8388607);
  if ((sig == 0) and (exp == 0)) then
    do return 0.0 end;
  end;
  do return (sign * (1 + (_G.math.pow(2,-23) * sig))) * _G.math.pow(2,exp - 127) end;
end
haxe.io.FPHelper.floatToI32 = function(f)
  if (f == 0) then
    do return 0 end;
  end;
  local af = (function()
    local _hx_1
    if (f < 0) then
    _hx_1 = -f; else
    _hx_1 = f; end
    return _hx_1
  end )();
  local exp = _G.math.floor(_G.math.log(af) / 0.6931471805599453);
  if (exp < -127) then
    exp = -127;
  else
    if (exp > 128) then
      exp = 128;
    end;
  end;
  local sig = _G.math.floor((((af / _G.math.pow(2,exp)) - 1) * 8388608) + 0.5);
  if ((sig == 8388608) and (exp < 128)) then
    sig = 0;
    exp = exp + 1;
  end;
  do return _hx_bit.bor(_hx_bit.bor(((function()
    local _hx_2
    if (f < 0) then
    _hx_2 = -2147483648; else
    _hx_2 = 0; end
    return _hx_2
  end )()),_hx_bit.lshift(exp + 127,23)),sig) end;
end
haxe.io.FPHelper.i64ToDouble = function(low,high)
  local sign = 1 - (_hx_bit.lshift(_hx_bit.rshift(high,31),1));
  local exp = (_hx_bit.band(_hx_bit.arshift(high,20),2047)) - 1023;
  local sig = (((_hx_bit.band(high,1048575)) * 4294967296.) + ((_hx_bit.rshift(low,31)) * 2147483648.)) + (_hx_bit.band(low,2147483647));
  if ((sig == 0) and (exp == -1023)) then
    do return 0.0 end;
  end;
  do return (sign * (1.0 + (_G.math.pow(2,-52) * sig))) * _G.math.pow(2,exp) end;
end
haxe.io.FPHelper.doubleToI64 = function(v)
  local i64 = haxe.io.FPHelper.i64tmp;
  if (v == 0) then
    i64.low = 0;
    i64.high = 0;
  else
    if (not ((v > -_G.math.huge) and (v < _G.math.huge))) then
      if (v > 0) then
        i64.low = 0;
        i64.high = 2146435072;
      else
        i64.low = 0;
        i64.high = -1048576;
      end;
    else
      local av = (function()
        local _hx_1
        if (v < 0) then
        _hx_1 = -v; else
        _hx_1 = v; end
        return _hx_1
      end )();
      local exp = _G.math.floor(_G.math.log(av) / 0.6931471805599453);
      local sig = _G.math.floor((((av / _G.math.pow(2,exp)) - 1) * 4503599627370496.) + 0.5);
      local sig_l = Std.int(sig);
      local sig_h = Std.int(sig / 4294967296.0);
      i64.low = sig_l;
      i64.high = _hx_bit.bor(_hx_bit.bor(((function()
        local _hx_2
        if (v < 0) then
        _hx_2 = -2147483648; else
        _hx_2 = 0; end
        return _hx_2
      end )()),_hx_bit.lshift(exp + 1023,20)),sig_h);
    end;
  end;
  do return i64 end;
end

haxe.io.Output.new = {}
_hxClasses["haxe.io.Output"] = haxe.io.Output
haxe.io.Output.__name__ = {"haxe","io","Output"}
haxe.io.Output.prototype = _hx_a(
  'bigEndian', nil,
  'writeByte', function(self,c)
    _G.error("Not implemented",0);
  end,
  'writeBytes', function(self,s,pos,len)
    if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b = s.b;
    local k = len;
    while (k > 0) do
      self:writeByte(b[pos]);
      pos = pos + 1;
      k = k - 1;
      end;
    do return len end
  end,
  'flush', function(self)
  end,
  'close', function(self)
  end,
  'set_bigEndian', function(self,b)
    self.bigEndian = b;
    do return b end
  end,
  'write', function(self,s)
    local l = s.length;
    local p = 0;
    while (l > 0) do
      local k = self:writeBytes(s,p,l);
      if (k == 0) then
        _G.error(haxe.io.Error.Blocked,0);
      end;
      p = p + k;
      l = l - k;
      end;
  end,
  'writeFullBytes', function(self,s,pos,len)
    while (len > 0) do
      local k = self:writeBytes(s,pos,len);
      pos = pos + k;
      len = len - k;
      end;
  end,
  'writeFloat', function(self,x)
    self:writeInt32(haxe.io.FPHelper.floatToI32(x));
  end,
  'writeDouble', function(self,x)
    local i64 = haxe.io.FPHelper.doubleToI64(x);
    if (self.bigEndian) then
      self:writeInt32(i64.high);
      self:writeInt32(i64.low);
    else
      self:writeInt32(i64.low);
      self:writeInt32(i64.high);
    end;
  end,
  'writeInt8', function(self,x)
    if ((x < -128) or (x >= 128)) then
      _G.error(haxe.io.Error.Overflow,0);
    end;
    self:writeByte(_hx_bit.band(x,255));
  end,
  'writeInt16', function(self,x)
    if ((x < -32768) or (x >= 32768)) then
      _G.error(haxe.io.Error.Overflow,0);
    end;
    self:writeUInt16(_hx_bit.band(x,65535));
  end,
  'writeUInt16', function(self,x)
    if ((x < 0) or (x >= 65536)) then
      _G.error(haxe.io.Error.Overflow,0);
    end;
    if (self.bigEndian) then
      self:writeByte(_hx_bit.arshift(x,8));
      self:writeByte(_hx_bit.band(x,255));
    else
      self:writeByte(_hx_bit.band(x,255));
      self:writeByte(_hx_bit.arshift(x,8));
    end;
  end,
  'writeInt24', function(self,x)
    if ((x < -8388608) or (x >= 8388608)) then
      _G.error(haxe.io.Error.Overflow,0);
    end;
    self:writeUInt24(_hx_bit.band(x,16777215));
  end,
  'writeUInt24', function(self,x)
    if ((x < 0) or (x >= 16777216)) then
      _G.error(haxe.io.Error.Overflow,0);
    end;
    if (self.bigEndian) then
      self:writeByte(_hx_bit.arshift(x,16));
      self:writeByte(_hx_bit.band(_hx_bit.arshift(x,8),255));
      self:writeByte(_hx_bit.band(x,255));
    else
      self:writeByte(_hx_bit.band(x,255));
      self:writeByte(_hx_bit.band(_hx_bit.arshift(x,8),255));
      self:writeByte(_hx_bit.arshift(x,16));
    end;
  end,
  'writeInt32', function(self,x)
    if (self.bigEndian) then
      self:writeByte(_hx_bit.rshift(x,24));
      self:writeByte(_hx_bit.band(_hx_bit.arshift(x,16),255));
      self:writeByte(_hx_bit.band(_hx_bit.arshift(x,8),255));
      self:writeByte(_hx_bit.band(x,255));
    else
      self:writeByte(_hx_bit.band(x,255));
      self:writeByte(_hx_bit.band(_hx_bit.arshift(x,8),255));
      self:writeByte(_hx_bit.band(_hx_bit.arshift(x,16),255));
      self:writeByte(_hx_bit.rshift(x,24));
    end;
  end,
  'prepare', function(self,nbytes)
  end,
  'writeInput', function(self,i,bufsize)
    if (bufsize == nil) then
      bufsize = 4096;
    end;
    local buf = haxe.io.Bytes.alloc(bufsize);
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function()

        while (true) do
          local len = i:readBytes(buf,0,bufsize);
          if (len == 0) then
            _G.error(haxe.io.Error.Blocked,0);
          end;
          local p = 0;
          while (len > 0) do
            local k = self:writeBytes(buf,p,len);
            if (k == 0) then
              _G.error(haxe.io.Error.Blocked,0);
            end;
            p = p + k;
            len = len - k;
            end;
          end;
       return _hx_expected_result end)
     if not _hx_status then
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Eof) ) then
        local e = _hx_1
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'writeString', function(self,s)
    local b = haxe.io.Bytes.ofString(s);
    self:writeFullBytes(b,0,b.length);
  end
  ,'__class__',  haxe.io.Output,
  '__properties__',  {set_bigEndian="set_bigEndian"}
)

haxe.io.Path.new = function(path)
  local self = _hx_new(haxe.io.Path.prototype)
  haxe.io.Path.super(self,path)
  return self
end
haxe.io.Path.super = function(self,path)
  local path1 = path;
  if (path1) == "." or (path1) == ".." then
    self.dir = path;
    self.file = "";
    do return end; end;
  local c1 = path:lastIndexOf("/");
  local c2 = path:lastIndexOf("\\");
  if (c1 < c2) then
    self.dir = path:substr(0,c2);
    path = path:substr(c2 + 1);
    self.backslash = true;
  else
    if (c2 < c1) then
      self.dir = path:substr(0,c1);
      path = path:substr(c1 + 1);
    else
      self.dir = nil;
    end;
  end;
  local cp = path:lastIndexOf(".");
  if (cp ~= -1) then
    self.ext = path:substr(cp + 1);
    self.file = path:substr(0,cp);
  else
    self.ext = nil;
    self.file = path;
  end;
end
_hxClasses["haxe.io.Path"] = haxe.io.Path
haxe.io.Path.__name__ = {"haxe","io","Path"}
haxe.io.Path.withoutExtension = function(path)
  local s = haxe.io.Path.new(path);
  s.ext = nil;
  do return s:toString() end;
end
haxe.io.Path.withoutDirectory = function(path)
  local s = haxe.io.Path.new(path);
  s.dir = nil;
  do return s:toString() end;
end
haxe.io.Path.directory = function(path)
  local s = haxe.io.Path.new(path);
  if (s.dir == nil) then
    do return "" end;
  end;
  do return s.dir end;
end
haxe.io.Path.extension = function(path)
  local s = haxe.io.Path.new(path);
  if (s.ext == nil) then
    do return "" end;
  end;
  do return s.ext end;
end
haxe.io.Path.withExtension = function(path,ext)
  local s = haxe.io.Path.new(path);
  s.ext = ext;
  do return s:toString() end;
end
haxe.io.Path.join = function(paths)
  local paths1 = paths:filter(function(s)
    if (s ~= nil) then
      do return s ~= "" end;
    else
      do return false end;
    end;
  end);
  if (paths1.length == 0) then
    do return "" end;
  end;
  local path = paths1[0];
  local _g1 = 1;
  local _g = paths1.length;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    path = haxe.io.Path.addTrailingSlash(path);
    path = path .. paths1[i];
    end;
  do return haxe.io.Path.normalize(path) end;
end
haxe.io.Path.normalize = function(path)
  local slash = "/";
  path = path:split("\\"):join(slash);
  if (path == slash) then
    do return slash end;
  end;
  local target = _hx_tab_array({ }, 0);
  local _g = 0;
  local _g1 = path:split(slash);
  while (_g < _g1.length) do
    local token = _g1[_g];
    _g = _g + 1;
    if (((token == "..") and (target.length > 0)) and (target[target.length - 1] ~= "..")) then
      target:pop();
    else
      if (token ~= ".") then
        target:push(token);
      end;
    end;
    end;
  local tmp = target:join(slash);
  local regex = EReg.new("([^:])/+","g");
  local result = regex:replace(tmp,"$1" .. slash);
  local acc_length;
  local acc_b = _hx_e();
  acc_length = 0;
  local colon = false;
  local slashes = false;
  local _g11 = 0;
  local _g2 = tmp.length;
  while (_g11 < _g2) do
    _g11 = _g11 + 1;
    local i = _g11 - 1;
    local _g21 = _G.string.byte(tmp,i + 1);
    local _g22 = _g21;
    if (_g22) == 47 then
      if (not colon) then
        slashes = true;
      else
        local i1 = _g21;
        colon = false;
        if (slashes) then
          local str = "/";
          _G.table.insert(acc_b,str);
          acc_length = acc_length + str.length;
          slashes = false;
        end;
        _G.table.insert(acc_b,_G.string.char(i1));
        acc_length = acc_length + 1;
      end;
    elseif (_g22) == 58 then
      local str1 = ":";
      _G.table.insert(acc_b,str1);
      acc_length = acc_length + str1.length;
      colon = true;else
    local i2 = _g21;
    colon = false;
    if (slashes) then
      local str2 = "/";
      _G.table.insert(acc_b,str2);
      acc_length = acc_length + str2.length;
      slashes = false;
    end;
    _G.table.insert(acc_b,_G.string.char(i2));
    acc_length = acc_length + 1; end;
    end;
  do return _G.table.concat(acc_b) end;
end
haxe.io.Path.addTrailingSlash = function(path)
  if (path.length == 0) then
    do return "/" end;
  end;
  local c1 = path:lastIndexOf("/");
  local c2 = path:lastIndexOf("\\");
  if (c1 < c2) then
    if (c2 ~= (path.length - 1)) then
      do return path .. "\\" end;
    else
      do return path end;
    end;
  else
    if (c1 ~= (path.length - 1)) then
      do return path .. "/" end;
    else
      do return path end;
    end;
  end;
end
haxe.io.Path.removeTrailingSlashes = function(path)
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function()

    while (true) do
      local _g = path:charCodeAt(path.length - 1);
      if (_g == nil) then
        _G.error("_hx__break__");
      else
        local _g1 = _g;
        if (_g1) == 47 or (_g1) == 92 then
          path = path:substr(0,-1);else
        _G.error("_hx__break__"); end;
      end;

  end
   return _hx_expected_result end)
   if not _hx_status then
   elseif _hx_result ~= _hx_expected_result then return _hx_result
  end;
    do return path end;
end
haxe.io.Path.isAbsolute = function(path)
  if (StringTools.startsWith(path,"/")) then
    do return true end;
  end;
  if (path:charAt(1) == ":") then
    do return true end;
  end;
  if (StringTools.startsWith(path,"\\\\")) then
    do return true end;
  end;
  do return false end;
end
haxe.io.Path.unescape = function(path)
  local regex = EReg.new("-x([0-9][0-9])","g");
  do return regex:map(path,function(regex1)
    do return _G.string.char(Std.parseInt(regex1:matched(1))) end;
  end) end;
end
haxe.io.Path.escape = function(path,allowSlashes)
  if (allowSlashes == nil) then
    allowSlashes = false;
  end;
  local regex = (function()
    local _hx_1
    if (allowSlashes) then
    _hx_1 = EReg.new("[^A-Za-z0-9_/\\\\\\.]","g"); else
    _hx_1 = EReg.new("[^A-Za-z0-9_\\.]","g"); end
    return _hx_1
  end )();
  do return regex:map(path,function(v)
    do return "-x" .. v:matched(0):charCodeAt(0) end;
  end) end;
end
haxe.io.Path.prototype = _hx_a(
  'dir', nil,
  'file', nil,
  'ext', nil,
  'backslash', nil,
  'toString', function(self)
    do return ((function()
      local _hx_1
      if (self.dir == nil) then
      _hx_1 = ""; else
      _hx_1 = self.dir .. ((function()
        local _hx_2
        if (self.backslash) then
        _hx_2 = "\\"; else
        _hx_2 = "/"; end
        return _hx_2
      end )()); end
      return _hx_1
    end )()) .. self.file .. ((function()
      local _hx_3
      if (self.ext == nil) then
      _hx_3 = ""; else
      _hx_3 = "." .. self.ext; end
      return _hx_3
    end )()) end
  end
  ,'__class__',  haxe.io.Path
)

haxe.macro.Compiler.new = {}
_hxClasses["haxe.macro.Compiler"] = haxe.macro.Compiler
haxe.macro.Compiler.__name__ = {"haxe","macro","Compiler"}
_hxClasses["haxe.macro.Constant"] = haxe.macro.Constant;
_hxClasses["haxe.macro.Constant"] = { __ename__ = {"haxe","macro","Constant"}, __constructs__ = _hx_tab_array({[0]="CInt","CFloat","CString","CIdent","CRegexp"},5)}
haxe.macro.Constant = _hxClasses["haxe.macro.Constant"];
haxe.macro.Constant.CInt = function(v) local _x = _hx_tab_array({[0]="CInt",0,v,__enum__=haxe.macro.Constant}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.Constant.CFloat = function(f) local _x = _hx_tab_array({[0]="CFloat",1,f,__enum__=haxe.macro.Constant}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.Constant.CString = function(s) local _x = _hx_tab_array({[0]="CString",2,s,__enum__=haxe.macro.Constant}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.Constant.CIdent = function(s) local _x = _hx_tab_array({[0]="CIdent",3,s,__enum__=haxe.macro.Constant}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.Constant.CRegexp = function(r,opt) local _x = _hx_tab_array({[0]="CRegexp",4,r,opt,__enum__=haxe.macro.Constant}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.Constant.__empty_constructs__ = _hx_tab_array({}, 0)
_hxClasses["haxe.macro.Binop"] = haxe.macro.Binop;
_hxClasses["haxe.macro.Binop"] = { __ename__ = {"haxe","macro","Binop"}, __constructs__ = _hx_tab_array({[0]="OpAdd","OpMult","OpDiv","OpSub","OpAssign","OpEq","OpNotEq","OpGt","OpGte","OpLt","OpLte","OpAnd","OpOr","OpXor","OpBoolAnd","OpBoolOr","OpShl","OpShr","OpUShr","OpMod","OpAssignOp","OpInterval","OpArrow"},23)}
haxe.macro.Binop = _hxClasses["haxe.macro.Binop"];
haxe.macro.Binop.OpAdd = _hx_tab_array({[0]="OpAdd",0,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpAdd, 'toString', _estr)

haxe.macro.Binop.OpMult = _hx_tab_array({[0]="OpMult",1,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpMult, 'toString', _estr)

haxe.macro.Binop.OpDiv = _hx_tab_array({[0]="OpDiv",2,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpDiv, 'toString', _estr)

haxe.macro.Binop.OpSub = _hx_tab_array({[0]="OpSub",3,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpSub, 'toString', _estr)

haxe.macro.Binop.OpAssign = _hx_tab_array({[0]="OpAssign",4,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpAssign, 'toString', _estr)

haxe.macro.Binop.OpEq = _hx_tab_array({[0]="OpEq",5,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpEq, 'toString', _estr)

haxe.macro.Binop.OpNotEq = _hx_tab_array({[0]="OpNotEq",6,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpNotEq, 'toString', _estr)

haxe.macro.Binop.OpGt = _hx_tab_array({[0]="OpGt",7,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpGt, 'toString', _estr)

haxe.macro.Binop.OpGte = _hx_tab_array({[0]="OpGte",8,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpGte, 'toString', _estr)

haxe.macro.Binop.OpLt = _hx_tab_array({[0]="OpLt",9,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpLt, 'toString', _estr)

haxe.macro.Binop.OpLte = _hx_tab_array({[0]="OpLte",10,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpLte, 'toString', _estr)

haxe.macro.Binop.OpAnd = _hx_tab_array({[0]="OpAnd",11,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpAnd, 'toString', _estr)

haxe.macro.Binop.OpOr = _hx_tab_array({[0]="OpOr",12,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpOr, 'toString', _estr)

haxe.macro.Binop.OpXor = _hx_tab_array({[0]="OpXor",13,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpXor, 'toString', _estr)

haxe.macro.Binop.OpBoolAnd = _hx_tab_array({[0]="OpBoolAnd",14,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpBoolAnd, 'toString', _estr)

haxe.macro.Binop.OpBoolOr = _hx_tab_array({[0]="OpBoolOr",15,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpBoolOr, 'toString', _estr)

haxe.macro.Binop.OpShl = _hx_tab_array({[0]="OpShl",16,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpShl, 'toString', _estr)

haxe.macro.Binop.OpShr = _hx_tab_array({[0]="OpShr",17,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpShr, 'toString', _estr)

haxe.macro.Binop.OpUShr = _hx_tab_array({[0]="OpUShr",18,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpUShr, 'toString', _estr)

haxe.macro.Binop.OpMod = _hx_tab_array({[0]="OpMod",19,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpMod, 'toString', _estr)

haxe.macro.Binop.OpAssignOp = function(op) local _x = _hx_tab_array({[0]="OpAssignOp",20,op,__enum__=haxe.macro.Binop}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.Binop.OpInterval = _hx_tab_array({[0]="OpInterval",21,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpInterval, 'toString', _estr)

haxe.macro.Binop.OpArrow = _hx_tab_array({[0]="OpArrow",22,__enum__ = haxe.macro.Binop},2)
rawset(haxe.macro.Binop.OpArrow, 'toString', _estr)

haxe.macro.Binop.__empty_constructs__ = _hx_tab_array({[0] = haxe.macro.Binop.OpAdd,haxe.macro.Binop.OpMult,haxe.macro.Binop.OpDiv,haxe.macro.Binop.OpSub,haxe.macro.Binop.OpAssign,haxe.macro.Binop.OpEq,haxe.macro.Binop.OpNotEq,haxe.macro.Binop.OpGt,haxe.macro.Binop.OpGte,haxe.macro.Binop.OpLt,haxe.macro.Binop.OpLte,haxe.macro.Binop.OpAnd,haxe.macro.Binop.OpOr,haxe.macro.Binop.OpXor,haxe.macro.Binop.OpBoolAnd,haxe.macro.Binop.OpBoolOr,haxe.macro.Binop.OpShl,haxe.macro.Binop.OpShr,haxe.macro.Binop.OpUShr,haxe.macro.Binop.OpMod,haxe.macro.Binop.OpInterval,haxe.macro.Binop.OpArrow}, 22)
_hxClasses["haxe.macro.Unop"] = haxe.macro.Unop;
_hxClasses["haxe.macro.Unop"] = { __ename__ = {"haxe","macro","Unop"}, __constructs__ = _hx_tab_array({[0]="OpIncrement","OpDecrement","OpNot","OpNeg","OpNegBits"},5)}
haxe.macro.Unop = _hxClasses["haxe.macro.Unop"];
haxe.macro.Unop.OpIncrement = _hx_tab_array({[0]="OpIncrement",0,__enum__ = haxe.macro.Unop},2)
rawset(haxe.macro.Unop.OpIncrement, 'toString', _estr)

haxe.macro.Unop.OpDecrement = _hx_tab_array({[0]="OpDecrement",1,__enum__ = haxe.macro.Unop},2)
rawset(haxe.macro.Unop.OpDecrement, 'toString', _estr)

haxe.macro.Unop.OpNot = _hx_tab_array({[0]="OpNot",2,__enum__ = haxe.macro.Unop},2)
rawset(haxe.macro.Unop.OpNot, 'toString', _estr)

haxe.macro.Unop.OpNeg = _hx_tab_array({[0]="OpNeg",3,__enum__ = haxe.macro.Unop},2)
rawset(haxe.macro.Unop.OpNeg, 'toString', _estr)

haxe.macro.Unop.OpNegBits = _hx_tab_array({[0]="OpNegBits",4,__enum__ = haxe.macro.Unop},2)
rawset(haxe.macro.Unop.OpNegBits, 'toString', _estr)

haxe.macro.Unop.__empty_constructs__ = _hx_tab_array({[0] = haxe.macro.Unop.OpIncrement,haxe.macro.Unop.OpDecrement,haxe.macro.Unop.OpNot,haxe.macro.Unop.OpNeg,haxe.macro.Unop.OpNegBits}, 5)
_hxClasses["haxe.macro.ExprDef"] = haxe.macro.ExprDef;
_hxClasses["haxe.macro.ExprDef"] = { __ename__ = {"haxe","macro","ExprDef"}, __constructs__ = _hx_tab_array({[0]="EConst","EArray","EBinop","EField","EParenthesis","EObjectDecl","EArrayDecl","ECall","ENew","EUnop","EVars","EFunction","EBlock","EFor","EIn","EIf","EWhile","ESwitch","ETry","EReturn","EBreak","EContinue","EUntyped","EThrow","ECast","EDisplay","EDisplayNew","ETernary","ECheckType","EMeta"},30)}
haxe.macro.ExprDef = _hxClasses["haxe.macro.ExprDef"];
haxe.macro.ExprDef.EConst = function(c) local _x = _hx_tab_array({[0]="EConst",0,c,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EArray = function(e1,e2) local _x = _hx_tab_array({[0]="EArray",1,e1,e2,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EBinop = function(op,e1,e2) local _x = _hx_tab_array({[0]="EBinop",2,op,e1,e2,__enum__=haxe.macro.ExprDef}, 5); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EField = function(e,field) local _x = _hx_tab_array({[0]="EField",3,e,field,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EParenthesis = function(e) local _x = _hx_tab_array({[0]="EParenthesis",4,e,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EObjectDecl = function(fields) local _x = _hx_tab_array({[0]="EObjectDecl",5,fields,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EArrayDecl = function(values) local _x = _hx_tab_array({[0]="EArrayDecl",6,values,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.ECall = function(e,params) local _x = _hx_tab_array({[0]="ECall",7,e,params,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.ENew = function(t,params) local _x = _hx_tab_array({[0]="ENew",8,t,params,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EUnop = function(op,postFix,e) local _x = _hx_tab_array({[0]="EUnop",9,op,postFix,e,__enum__=haxe.macro.ExprDef}, 5); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EVars = function(vars) local _x = _hx_tab_array({[0]="EVars",10,vars,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EFunction = function(name,f) local _x = _hx_tab_array({[0]="EFunction",11,name,f,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EBlock = function(exprs) local _x = _hx_tab_array({[0]="EBlock",12,exprs,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EFor = function(it,expr) local _x = _hx_tab_array({[0]="EFor",13,it,expr,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EIn = function(e1,e2) local _x = _hx_tab_array({[0]="EIn",14,e1,e2,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EIf = function(econd,eif,eelse) local _x = _hx_tab_array({[0]="EIf",15,econd,eif,eelse,__enum__=haxe.macro.ExprDef}, 5); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EWhile = function(econd,e,normalWhile) local _x = _hx_tab_array({[0]="EWhile",16,econd,e,normalWhile,__enum__=haxe.macro.ExprDef}, 5); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.ESwitch = function(e,cases,edef) local _x = _hx_tab_array({[0]="ESwitch",17,e,cases,edef,__enum__=haxe.macro.ExprDef}, 5); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.ETry = function(e,catches) local _x = _hx_tab_array({[0]="ETry",18,e,catches,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EReturn = function(e) local _x = _hx_tab_array({[0]="EReturn",19,e,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EBreak = _hx_tab_array({[0]="EBreak",20,__enum__ = haxe.macro.ExprDef},2)
rawset(haxe.macro.ExprDef.EBreak, 'toString', _estr)

haxe.macro.ExprDef.EContinue = _hx_tab_array({[0]="EContinue",21,__enum__ = haxe.macro.ExprDef},2)
rawset(haxe.macro.ExprDef.EContinue, 'toString', _estr)

haxe.macro.ExprDef.EUntyped = function(e) local _x = _hx_tab_array({[0]="EUntyped",22,e,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EThrow = function(e) local _x = _hx_tab_array({[0]="EThrow",23,e,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.ECast = function(e,t) local _x = _hx_tab_array({[0]="ECast",24,e,t,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EDisplay = function(e,isCall) local _x = _hx_tab_array({[0]="EDisplay",25,e,isCall,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EDisplayNew = function(t) local _x = _hx_tab_array({[0]="EDisplayNew",26,t,__enum__=haxe.macro.ExprDef}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.ETernary = function(econd,eif,eelse) local _x = _hx_tab_array({[0]="ETernary",27,econd,eif,eelse,__enum__=haxe.macro.ExprDef}, 5); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.ECheckType = function(e,t) local _x = _hx_tab_array({[0]="ECheckType",28,e,t,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.EMeta = function(s,e) local _x = _hx_tab_array({[0]="EMeta",29,s,e,__enum__=haxe.macro.ExprDef}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ExprDef.__empty_constructs__ = _hx_tab_array({[0] = haxe.macro.ExprDef.EBreak,haxe.macro.ExprDef.EContinue}, 2)
_hxClasses["haxe.macro.ComplexType"] = haxe.macro.ComplexType;
_hxClasses["haxe.macro.ComplexType"] = { __ename__ = {"haxe","macro","ComplexType"}, __constructs__ = _hx_tab_array({[0]="TPath","TFunction","TAnonymous","TParent","TExtend","TOptional"},6)}
haxe.macro.ComplexType = _hxClasses["haxe.macro.ComplexType"];
haxe.macro.ComplexType.TPath = function(p) local _x = _hx_tab_array({[0]="TPath",0,p,__enum__=haxe.macro.ComplexType}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ComplexType.TFunction = function(args,ret) local _x = _hx_tab_array({[0]="TFunction",1,args,ret,__enum__=haxe.macro.ComplexType}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ComplexType.TAnonymous = function(fields) local _x = _hx_tab_array({[0]="TAnonymous",2,fields,__enum__=haxe.macro.ComplexType}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ComplexType.TParent = function(t) local _x = _hx_tab_array({[0]="TParent",3,t,__enum__=haxe.macro.ComplexType}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ComplexType.TExtend = function(p,fields) local _x = _hx_tab_array({[0]="TExtend",4,p,fields,__enum__=haxe.macro.ComplexType}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ComplexType.TOptional = function(t) local _x = _hx_tab_array({[0]="TOptional",5,t,__enum__=haxe.macro.ComplexType}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ComplexType.__empty_constructs__ = _hx_tab_array({}, 0)
_hxClasses["haxe.macro.TypeParam"] = haxe.macro.TypeParam;
_hxClasses["haxe.macro.TypeParam"] = { __ename__ = {"haxe","macro","TypeParam"}, __constructs__ = _hx_tab_array({[0]="TPType","TPExpr"},2)}
haxe.macro.TypeParam = _hxClasses["haxe.macro.TypeParam"];
haxe.macro.TypeParam.TPType = function(t) local _x = _hx_tab_array({[0]="TPType",0,t,__enum__=haxe.macro.TypeParam}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.TypeParam.TPExpr = function(e) local _x = _hx_tab_array({[0]="TPExpr",1,e,__enum__=haxe.macro.TypeParam}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.TypeParam.__empty_constructs__ = _hx_tab_array({}, 0)
_hxClasses["haxe.macro.Access"] = haxe.macro.Access;
_hxClasses["haxe.macro.Access"] = { __ename__ = {"haxe","macro","Access"}, __constructs__ = _hx_tab_array({[0]="APublic","APrivate","AStatic","AOverride","ADynamic","AInline","AMacro"},7)}
haxe.macro.Access = _hxClasses["haxe.macro.Access"];
haxe.macro.Access.APublic = _hx_tab_array({[0]="APublic",0,__enum__ = haxe.macro.Access},2)
rawset(haxe.macro.Access.APublic, 'toString', _estr)

haxe.macro.Access.APrivate = _hx_tab_array({[0]="APrivate",1,__enum__ = haxe.macro.Access},2)
rawset(haxe.macro.Access.APrivate, 'toString', _estr)

haxe.macro.Access.AStatic = _hx_tab_array({[0]="AStatic",2,__enum__ = haxe.macro.Access},2)
rawset(haxe.macro.Access.AStatic, 'toString', _estr)

haxe.macro.Access.AOverride = _hx_tab_array({[0]="AOverride",3,__enum__ = haxe.macro.Access},2)
rawset(haxe.macro.Access.AOverride, 'toString', _estr)

haxe.macro.Access.ADynamic = _hx_tab_array({[0]="ADynamic",4,__enum__ = haxe.macro.Access},2)
rawset(haxe.macro.Access.ADynamic, 'toString', _estr)

haxe.macro.Access.AInline = _hx_tab_array({[0]="AInline",5,__enum__ = haxe.macro.Access},2)
rawset(haxe.macro.Access.AInline, 'toString', _estr)

haxe.macro.Access.AMacro = _hx_tab_array({[0]="AMacro",6,__enum__ = haxe.macro.Access},2)
rawset(haxe.macro.Access.AMacro, 'toString', _estr)

haxe.macro.Access.__empty_constructs__ = _hx_tab_array({[0] = haxe.macro.Access.APublic,haxe.macro.Access.APrivate,haxe.macro.Access.AStatic,haxe.macro.Access.AOverride,haxe.macro.Access.ADynamic,haxe.macro.Access.AInline,haxe.macro.Access.AMacro}, 7)
_hxClasses["haxe.macro.FieldType"] = haxe.macro.FieldType;
_hxClasses["haxe.macro.FieldType"] = { __ename__ = {"haxe","macro","FieldType"}, __constructs__ = _hx_tab_array({[0]="FVar","FFun","FProp"},3)}
haxe.macro.FieldType = _hxClasses["haxe.macro.FieldType"];
haxe.macro.FieldType.FVar = function(t,e) local _x = _hx_tab_array({[0]="FVar",0,t,e,__enum__=haxe.macro.FieldType}, 4); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.FieldType.FFun = function(f) local _x = _hx_tab_array({[0]="FFun",1,f,__enum__=haxe.macro.FieldType}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.FieldType.FProp = function(get,set,t,e) local _x = _hx_tab_array({[0]="FProp",2,get,set,t,e,__enum__=haxe.macro.FieldType}, 6); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.FieldType.__empty_constructs__ = _hx_tab_array({}, 0)
_hxClasses["haxe.macro.TypeDefKind"] = haxe.macro.TypeDefKind;
_hxClasses["haxe.macro.TypeDefKind"] = { __ename__ = {"haxe","macro","TypeDefKind"}, __constructs__ = _hx_tab_array({[0]="TDEnum","TDStructure","TDClass","TDAlias","TDAbstract"},5)}
haxe.macro.TypeDefKind = _hxClasses["haxe.macro.TypeDefKind"];
haxe.macro.TypeDefKind.TDEnum = _hx_tab_array({[0]="TDEnum",0,__enum__ = haxe.macro.TypeDefKind},2)
rawset(haxe.macro.TypeDefKind.TDEnum, 'toString', _estr)

haxe.macro.TypeDefKind.TDStructure = _hx_tab_array({[0]="TDStructure",1,__enum__ = haxe.macro.TypeDefKind},2)
rawset(haxe.macro.TypeDefKind.TDStructure, 'toString', _estr)

haxe.macro.TypeDefKind.TDClass = function(superClass,interfaces,isInterface) local _x = _hx_tab_array({[0]="TDClass",2,superClass,interfaces,isInterface,__enum__=haxe.macro.TypeDefKind}, 5); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.TypeDefKind.TDAlias = function(t) local _x = _hx_tab_array({[0]="TDAlias",3,t,__enum__=haxe.macro.TypeDefKind}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.TypeDefKind.TDAbstract = function(tthis,from,to) local _x = _hx_tab_array({[0]="TDAbstract",4,tthis,from,to,__enum__=haxe.macro.TypeDefKind}, 5); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.TypeDefKind.__empty_constructs__ = _hx_tab_array({[0] = haxe.macro.TypeDefKind.TDEnum,haxe.macro.TypeDefKind.TDStructure}, 2)

haxe.macro.Error.new = function(m,p)
  local self = _hx_new(haxe.macro.Error.prototype)
  haxe.macro.Error.super(self,m,p)
  return self
end
haxe.macro.Error.super = function(self,m,p)
  self.message = m;
  self.pos = p;
end
_hxClasses["haxe.macro.Error"] = haxe.macro.Error
haxe.macro.Error.__name__ = {"haxe","macro","Error"}
haxe.macro.Error.prototype = _hx_a(
  'message', nil,
  'pos', nil,
  'toString', function(self)
    do return self.message end
  end
  ,'__class__',  haxe.macro.Error
)
_hxClasses["haxe.macro.ImportMode"] = haxe.macro.ImportMode;
_hxClasses["haxe.macro.ImportMode"] = { __ename__ = {"haxe","macro","ImportMode"}, __constructs__ = _hx_tab_array({[0]="INormal","IAsName","IAll"},3)}
haxe.macro.ImportMode = _hxClasses["haxe.macro.ImportMode"];
haxe.macro.ImportMode.INormal = _hx_tab_array({[0]="INormal",0,__enum__ = haxe.macro.ImportMode},2)
rawset(haxe.macro.ImportMode.INormal, 'toString', _estr)

haxe.macro.ImportMode.IAsName = function(alias) local _x = _hx_tab_array({[0]="IAsName",1,alias,__enum__=haxe.macro.ImportMode}, 3); rawset(_x, 'toString', _estr); return _x; end
haxe.macro.ImportMode.IAll = _hx_tab_array({[0]="IAll",2,__enum__ = haxe.macro.ImportMode},2)
rawset(haxe.macro.ImportMode.IAll, 'toString', _estr)

haxe.macro.ImportMode.__empty_constructs__ = _hx_tab_array({[0] = haxe.macro.ImportMode.INormal,haxe.macro.ImportMode.IAll}, 2)

ink.random.RNG.new = function()
  local self = _hx_new(ink.random.RNG.prototype)
  ink.random.RNG.super(self)
  return self
end
ink.random.RNG.super = function(self)
  self._seed = 0;
end
_hxClasses["ink.random.RNG"] = ink.random.RNG
ink.random.RNG.__name__ = {"ink","random","RNG"}
ink.random.RNG.prototype = _hx_a(
  '_seed', nil,
  'getSeed', function(self)
    do return self._seed end
  end,
  'setSeed', function(self,seed)
    self._seed = seed;
  end,
  'random', function(self)
    _G.error("override for implementation",0);
  end,
  'randomFloat', function(self)
    _G.error("override for implementation",0);
  end,
  'randomRange', function(self,min,max)
    local l = min - .4999;
    local h = max + .4999;
    do return _G.math.floor((l + ((h - l) * self:randomFloat())) + 0.5) end
  end,
  'randomFloatRange', function(self,min,max)
    do return min + ((max - min) * self:randomFloat()) end
  end,
  'randomSym', function(self,range)
    local l = -range - .4999;
    local h = range + .4999;
    do return _G.math.floor((l + ((h - l) * self:randomFloat())) + 0.5) end
  end,
  'randomFloatSym', function(self,range)
    local min = -range;
    do return min + ((range - min) * self:randomFloat()) end
  end
  ,'__class__',  ink.random.RNG
)

ink.random.ParkMiller.new = function(seed)
  local self = _hx_new(ink.random.ParkMiller.prototype)
  ink.random.ParkMiller.super(self,seed)
  return self
end
ink.random.ParkMiller.super = function(self,seed)
  if (seed == nil) then
    seed = 1;
  end;
  ink.random.RNG.super(self);
  self:setSeed(seed);
end
_hxClasses["ink.random.ParkMiller"] = ink.random.ParkMiller
ink.random.ParkMiller.__name__ = {"ink","random","ParkMiller"}
ink.random.ParkMiller.prototype = _hx_a(
  '_fseed', nil,
  'setSeed', function(self,seed)
    ink.random.RNG.prototype.setSeed(self,seed);
    self._fseed = seed;
  end,
  'random', function(self)
    self._fseed = _G.math.fmod(self._fseed * 16807., 2147483647.);
    do return self._fseed end
  end,
  'randomFloat', function(self)
    do return self:random() / 2147483647. end
  end
  ,'__class__',  ink.random.ParkMiller
)
ink.random.ParkMiller.__super__ = ink.random.RNG
setmetatable(ink.random.ParkMiller.prototype,{__index=ink.random.RNG.prototype})

ink.random.Limits.new = {}
_hxClasses["ink.random.Limits"] = ink.random.Limits
ink.random.Limits.__name__ = {"ink","random","Limits"}

ink.runtime.Assert.new = {}
_hxClasses["ink.runtime.Assert"] = ink.runtime.Assert
ink.runtime.Assert.__name__ = {"ink","runtime","Assert"}
ink.runtime.Assert.bool = function(result,error)
  if (not result) then
    _G.error(error,0);
  end;
end

ink.runtime.CallStack.new = function()
  local self = _hx_new(ink.runtime.CallStack.prototype)
  ink.runtime.CallStack.super(self)
  return self
end
ink.runtime.CallStack.super = function(self)
end
_hxClasses["ink.runtime.CallStack"] = ink.runtime.CallStack
ink.runtime.CallStack.__name__ = {"ink","runtime","CallStack"}
ink.runtime.CallStack.createCallStack = function(rootContentContainer)
  local me = ink.runtime.CallStack.new();
  me:setupCallStack(rootContentContainer);
  do return me end;
end
ink.runtime.CallStack.createCallStack2 = function(toCopy)
  local me = ink.runtime.CallStack.new();
  me:setupCallStack2(toCopy);
  do return me end;
end
ink.runtime.CallStack.prototype = _hx_a(
  'elements', nil,
  'get_elements', function(self)
    do return self:get_callStack() end
  end,
  'currentElement', nil,
  'get_currentElement', function(self)
    do return self:get_callStack()[self:get_callStack().length - 1] end
  end,
  'currentElementIndex', nil,
  'get_currentElementIndex', function(self)
    do return self:get_callStack().length - 1 end
  end,
  'get_currentThread', function(self)
    do return self._threads:last() end
  end,
  'set_currentThread', function(self,value)
    if (self._threads.length ~= 1) then
      _G.error("Shouldn't be directly setting the current thread when we have a stack of them",0);
    end;
    self._threads:clear();
    self._threads:add(value);
    do return value end
  end,
  'canPop', nil,
  'get_canPop', function(self)
    do return self:get_callStack().length > 1 end
  end,
  'setupCallStack', function(self,rootContentContainer)
    self._threads = List.new();
    self._threads:add(ink.runtime.Thread.new());
    self._threads:first().callstack:push(ink.runtime.Element.new(0,rootContentContainer,0));
  end,
  'setupCallStack2', function(self,toCopy)
    self._threads = List.new();
    local i_head = toCopy._threads.h;
    while (i_head ~= nil) do
      local val = i_head.item;
      i_head = i_head.next;
      local otherThread = val;
      self._threads:add(otherThread:Copy());
      end;
  end,
  'SetJsonToken', function(self,jObject,storyContext)
    self._threads:clear();
    local jThreads = Reflect.field(jObject,"threads");
    local _g1 = 0;
    local _g = jThreads.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local jThreadTok = jThreads[i];
      local jThreadObj = jThreadTok;
      local thread = ink.runtime.Thread.create(jThreadObj,storyContext);
      self._threads:add(thread);
      end;
    self._threadCounter = Reflect.field(jObject,"threadCounter");
  end,
  'GetJsonToken', function(self)
    local jObject = _hx_e();
    local jThreads = _hx_tab_array({ }, 0);
    local i_head = self._threads.h;
    while (i_head ~= nil) do
      local val = i_head.item;
      i_head = i_head.next;
      local thread = val;
      jThreads:push(thread:get_jsonToken());
      end;
    jObject.threads = jThreads;
    jObject.threadCounter = self._threadCounter;
    do return jObject end
  end,
  'PushThread', function(self)
    local newThread = self:get_currentThread():Copy();
    newThread.threadIndex = self._threadCounter;
    self._threadCounter = self._threadCounter + 1;
    self._threads:add(newThread);
  end,
  'PopThread', function(self)
    if (self:get_canPopThread()) then
      self._threads:remove(self:get_currentThread());
    else
      _G.error(ink.runtime.SystemException.new("Can't pop thread"),0);
    end;
  end,
  'canPopThread', nil,
  'get_canPopThread', function(self)
    do return self._threads.length > 1 end
  end,
  'Push', function(self,type)
    self:get_callStack():push(ink.runtime.Element.new(type,self:get_currentElement().currentContainer,self:get_currentElement().currentContentIndex,false));
  end,
  'CanPop', function(self,type)
    if (not self:get_canPop()) then
      do return false end;
    end;
    if (type == nil) then
      do return true end;
    end;
    do return self:get_currentElement().type == type end
  end,
  'Pop', function(self,type)
    if (self:CanPop(type)) then
      self:get_callStack():pop();
      do return end;
    else
      _G.error(ink.runtime.SystemException.new("Mismatched push/pop in Callstack"),0);
    end;
  end,
  'GetTemporaryVariableWithName', function(self,name,contextIndex)
    if (contextIndex == nil) then
      contextIndex = -1;
    end;
    if (contextIndex == -1) then
      contextIndex = self:get_currentElementIndex() + 1;
    end;
    local varValue = nil;
    local contextElement = self:get_callStack()[contextIndex - 1];
    local map = contextElement.temporaryVariables;
    varValue = map.v[name];
    if (varValue ~= nil) then
      do return varValue end;
    else
      do return nil end;
    end;
  end,
  'SetTemporaryVariable', function(self,name,value,declareNew,contextIndex)
    if (contextIndex == nil) then
      contextIndex = -1;
    end;
    if (contextIndex == -1) then
      contextIndex = self:get_currentElementIndex() + 1;
    end;
    local contextElement = self:get_callStack()[contextIndex - 1];
    local tmp;
    if (not declareNew) then
      local this1 = contextElement.temporaryVariables;
      tmp = not (this1.k[name] or false);
    else
      tmp = false;
    end;
    if (tmp) then
      _G.error(ink.runtime.StoryException.new("Could not find temporary variable to set: " .. name),0);
    end;
    local _this = contextElement.temporaryVariables;
    _this.v[name] = value;
    _this.k[name] = true;
  end,
  'ContextForVariableNamed', function(self,name)
    local this1 = self:get_currentElement().temporaryVariables;
    if ((this1.k[name] or false)) then
      do return self:get_currentElementIndex() + 1 end;
    else
      do return 0 end;
    end;
  end,
  'ThreadWithIndex', function(self,index)
    do return ink.runtime.LibUtil.findForList(self._threads,function(t)
      do return t.threadIndex == index end;
    end) end
  end,
  'callStack', nil,
  'get_callStack', function(self)
    do return self:get_currentThread().callstack end
  end,
  '_threads', nil,
  '_threadCounter', nil
  ,'__class__',  ink.runtime.CallStack,
  '__properties__',  {get_callStack="get_callStack",get_canPopThread="get_canPopThread",get_canPop="get_canPop",set_currentThread="set_currentThread",get_currentThread="get_currentThread",get_currentElementIndex="get_currentElementIndex",get_currentElement="get_currentElement",get_elements="get_elements"}
)

ink.runtime.Element.new = function(type,container,contentIndex,inExpressionEvaluation)
  local self = _hx_new(ink.runtime.Element.prototype)
  ink.runtime.Element.super(self,type,container,contentIndex,inExpressionEvaluation)
  return self
end
ink.runtime.Element.super = function(self,type,container,contentIndex,inExpressionEvaluation)
  if (inExpressionEvaluation == nil) then
    inExpressionEvaluation = false;
  end;
  self.currentContainer = container;
  self.currentContentIndex = contentIndex;
  self.inExpressionEvaluation = inExpressionEvaluation;
  self.temporaryVariables = haxe.ds.StringMap.new();
  self.type = type;
end
_hxClasses["ink.runtime.Element"] = ink.runtime.Element
ink.runtime.Element.__name__ = {"ink","runtime","Element"}
ink.runtime.Element.prototype = _hx_a(
  'currentContainer', nil,
  'currentContentIndex', nil,
  'inExpressionEvaluation', nil,
  'temporaryVariables', nil,
  'type', nil,
  'get_currentObject', function(self)
    if ((self.currentContainer ~= nil) and (self.currentContentIndex < self.currentContainer._content.length)) then
      do return self.currentContainer._content[self.currentContentIndex] end;
    end;
    do return nil end
  end,
  'set_currentObject', function(self,value)
    local currentObj = value;
    if (currentObj == nil) then
      self.currentContainer = nil;
      self.currentContentIndex = 0;
      do return nil end;
    end;
    local obj = currentObj.parent;
    self.currentContainer = (function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (self.currentContainer ~= nil) then
      self.currentContentIndex = self.currentContainer._content:indexOf(currentObj);
    end;
    if ((self.currentContainer == nil) or (self.currentContentIndex == -1)) then
      self.currentContainer = (function()
        local _hx_2
        if (lua.Boot.__instanceof(currentObj,ink.runtime.Container)) then
        _hx_2 = currentObj; else
        _hx_2 = nil; end
        return _hx_2
      end )();
      self.currentContentIndex = 0;
    end;
    do return self.currentContainer._content[self.currentContentIndex] end
  end,
  'Copy', function(self)
    local copy = ink.runtime.Element.new(self.type,self.currentContainer,self.currentContentIndex,self.inExpressionEvaluation);
    local clone = ink.runtime.LibUtil.cloneStrMap(self.temporaryVariables);
    copy.temporaryVariables = clone;
    do return copy end
  end
  ,'__class__',  ink.runtime.Element,
  '__properties__',  {set_currentObject="set_currentObject",get_currentObject="get_currentObject"}
)

ink.runtime.Thread.new = function()
  local self = _hx_new(ink.runtime.Thread.prototype)
  ink.runtime.Thread.super(self)
  return self
end
ink.runtime.Thread.super = function(self)
  self.callstack = Array.new();
end
_hxClasses["ink.runtime.Thread"] = ink.runtime.Thread
ink.runtime.Thread.__name__ = {"ink","runtime","Thread"}
ink.runtime.Thread.create = function(jThreadObj,storyContext)
  local me = ink.runtime.Thread.new();
  me:setup(jThreadObj,storyContext);
  do return me end;
end
ink.runtime.Thread.prototype = _hx_a(
  'callstack', nil,
  'threadIndex', nil,
  'previousContentObject', nil,
  'setup', function(self,jThreadObj,storyContext)
    self.threadIndex = Std.int(Reflect.field(jThreadObj,"threadIndex"));
    local jThreadCallstack = Reflect.field(jThreadObj,"callstack");
    local _g1 = 0;
    local _g = jThreadCallstack.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local jElTok = jThreadCallstack[i];
      local jElementObj = jElTok;
      local pushPopType = Reflect.field(jElementObj,"type");
      local currentContainer = nil;
      local contentIndex = 0;
      local currentContainerPathStr = nil;
      local currentContainerPathStrToken = Reflect.field(jElementObj,"cPath");
      if (currentContainerPathStrToken ~= nil) then
        currentContainerPathStr = Std.string(currentContainerPathStrToken);
        currentContainer = ink.runtime.LibUtil.asNoInline(storyContext:ContentAtPath(ink.runtime.Path.createFromString(currentContainerPathStr)),ink.runtime.Container);
        contentIndex = Std.int(Reflect.field(jElementObj,"idx"));
      end;
      local inExpressionEvaluation = Reflect.field(jElementObj,"exp");
      local el = ink.runtime.Element.new(pushPopType,currentContainer,contentIndex,inExpressionEvaluation);
      local jObjTemps = Reflect.field(jElementObj,"temp");
      el.temporaryVariables = ink.runtime.Json.JObjectToDictionaryRuntimeObjs(jObjTemps);
      self.callstack:push(el);
      end;
    local prevContentObjPath = Reflect.field(jThreadObj,"previousContentObject");
    if (prevContentObjPath ~= nil) then
      local prevPath = ink.runtime.Path.createFromString(Std.string(prevContentObjPath));
      self.previousContentObject = storyContext:ContentAtPath(prevPath);
    end;
  end,
  'Copy', function(self)
    local copy = ink.runtime.Thread.new();
    copy.threadIndex = self.threadIndex;
    local _g1 = 0;
    local _g = self.callstack.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local e = self.callstack[i];
      copy.callstack:push(e:Copy());
      end;
    copy.previousContentObject = self.previousContentObject;
    do return copy end
  end,
  'jsonToken', nil,
  'get_jsonToken', function(self)
    local threadJObj = _hx_e();
    local jThreadCallstack = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g = self.callstack.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local el = self.callstack[i];
      local jObj = _hx_e();
      if (el.currentContainer ~= nil) then
        jObj.cPath = el.currentContainer:get_path():get_componentsString();
        jObj.idx = el.currentContentIndex;
      end;
      jObj.exp = el.inExpressionEvaluation;
      jObj.type = el.type;
      jObj.temp = ink.runtime.Json.DictionaryRuntimeObjsToJObject(el.temporaryVariables);
      jThreadCallstack:push(jObj);
      end;
    threadJObj.callstack = jThreadCallstack;
    threadJObj.threadIndex = self.threadIndex;
    if (self.previousContentObject ~= nil) then
      threadJObj.previousContentObject = Std.string(self.previousContentObject:get_path());
    end;
    do return threadJObj end
  end
  ,'__class__',  ink.runtime.Thread,
  '__properties__',  {get_jsonToken="get_jsonToken"}
)

ink.runtime.RObject.new = function()
  local self = _hx_new(ink.runtime.RObject.prototype)
  ink.runtime.RObject.super(self)
  return self
end
ink.runtime.RObject.super = function(self)
end
_hxClasses["ink.runtime.RObject"] = ink.runtime.RObject
ink.runtime.RObject.__name__ = {"ink","runtime","RObject"}
ink.runtime.RObject.EQUALS = function(a,b)
  do return a == b end;
end
ink.runtime.RObject.notEquals = function(a,b)
  do return a ~= b end;
end
ink.runtime.RObject.prototype = _hx_a(
  'parent', nil,
  'get_debugMetadata', function(self)
    if (self._debugMetadata == nil) then
      if (self.parent ~= nil) then
        do return self.parent:get_debugMetadata() end;
      end;
    end;
    do return self._debugMetadata end
  end,
  'set_debugMetadata', function(self,value)
    self._debugMetadata = value do return self._debugMetadata end
  end,
  '_debugMetadata', nil,
  'DebugLineNumberOfPath', function(self,path)
    if (path == nil) then
      do return nil end;
    end;
    local root = self:get_rootContentContainer();
    if (root ~= nil) then
      local targetContent = root:ContentAtPath(path);
      if (targetContent ~= nil) then
        local dm = targetContent:get_debugMetadata();
        if (dm ~= nil) then
          do return dm.startLineNumber end;
        end;
      end;
    end;
    do return nil end
  end,
  'path', nil,
  'get_path', function(self)
    if (self._path == nil) then
      if (self.parent == nil) then
        self._path = ink.runtime.Path.new();
      else
        local comps = haxe.ds.GenericStack.new();
        local child = self;
        local obj = child.parent;
        local container = (function()
          local _hx_1
          if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
          _hx_1 = obj; else
          _hx_1 = nil; end
          return _hx_1
        end )();
        while (container ~= nil) do
          local namedChild = (function()
            local _hx_2
            if (lua.Boot.__instanceof(child,ink.runtime.INamedContent)) then
            _hx_2 = child; else
            _hx_2 = nil; end
            return _hx_2
          end )();
          if ((namedChild ~= nil) and namedChild:get_hasValidName()) then
            comps.head = haxe.ds.GenericCell.new(ink.runtime.Component.createFromName(namedChild.name),comps.head);
          else
            comps.head = haxe.ds.GenericCell.new(ink.runtime.Component.createFromIndex(container._content:indexOf(child)),comps.head);
          end;
          child = container;
          local obj1 = container.parent;
          if (lua.Boot.__instanceof(obj1,ink.runtime.Container)) then
            container = obj1;
          else
            container = nil;
          end;
          end;
        self._path = ink.runtime.Path.createFromComponentStack(comps);
      end;
    end;
    do return self._path end
  end,
  '_path', nil,
  'ResolvePath', function(self,path)
    if (path.isRelative) then
      local nearestContainer = (function()
        local _hx_1
        if (lua.Boot.__instanceof(self,ink.runtime.Container)) then
        _hx_1 = self; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if (nearestContainer == nil) then
        if (self.parent == nil) then
          _G.error("Can't resolve relative path because we don't have a parent",0);
        end;
        local obj = self.parent;
        if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
          nearestContainer = obj;
        else
          nearestContainer = nil;
        end;
        if (nearestContainer == nil) then
          _G.error("Expected parent to be a container",0);
        end;
        if (not path.components[0]:get_isParent()) then
          _G.error("Is parent assertion failed",0);
        end;
        path = path:get_tail();
      end;
      do return nearestContainer:ContentAtPath(path) end;
    else
      do return self:get_rootContentContainer():ContentAtPath(path) end;
    end;
  end,
  'ConvertPathToRelative', function(self,globalPath)
    local ownPath = self:get_path();
    local minPathLength = ink.runtime.LibUtil.minI(globalPath.components.length,ownPath.components.length);
    local lastSharedPathCompIndex = -1;
    local _g1 = 0;
    local _g = minPathLength;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local ownComp = ownPath.components[i];
      local otherComp = globalPath.components[i];
      if (ownComp:Equals(otherComp)) then
        lastSharedPathCompIndex = i;
      else
        break;
      end;
      end;
    if (lastSharedPathCompIndex == -1) then
      do return globalPath end;
    end;
    local numUpwardsMoves = (ownPath.components.length - 1) - lastSharedPathCompIndex;
    local newPathComps = Array.new();
    local _g11 = 0;
    local _g2 = numUpwardsMoves;
    while (_g11 < _g2) do
      _g11 = _g11 + 1;
      local up = _g11 - 1;
      newPathComps:push(ink.runtime.Component.ToParent());
      end;
    local _g12 = lastSharedPathCompIndex + 1;
    local _g3 = globalPath.components.length;
    while (_g12 < _g3) do
      _g12 = _g12 + 1;
      local down = _g12 - 1;
      newPathComps:push(globalPath.components[down]);
      end;
    local relativePath = ink.runtime.Path.createFromComponents(newPathComps,true);
    do return relativePath end
  end,
  'CompactPathString', function(self,otherPath)
    local globalPathStr = nil;
    local relativePathStr = nil;
    if (otherPath.isRelative) then
      relativePathStr = otherPath:get_componentsString();
      globalPathStr = self:get_path():PathByAppendingPath(otherPath):get_componentsString();
    else
      local relativePath = self:ConvertPathToRelative(otherPath);
      relativePathStr = relativePath:get_componentsString();
      globalPathStr = otherPath:get_componentsString();
    end;
    if (relativePathStr.length < globalPathStr.length) then
      do return relativePathStr end;
    else
      do return globalPathStr end;
    end;
  end,
  'rootContentContainer', nil,
  'get_rootContentContainer', function(self)
    local ancestor = self;
    while (ancestor.parent ~= nil) do
      ancestor = ancestor.parent;
      end;
    do return (function()
      local _hx_1
      if (lua.Boot.__instanceof(ancestor,ink.runtime.Container)) then
      _hx_1 = ancestor; else
      _hx_1 = nil; end
      return _hx_1
    end )() end
  end,
  'Copy', function(self)
    _G.error(ink.runtime.SystemNotImplementedException.new(Type.typeof(self)[0] .. " doesn't support copying"),0);
  end,
  'SetChildReturnValue', function(self,obj,value)
    if (obj ~= nil) then
      obj.parent = nil;
    end;
    obj = value;
    if (obj ~= nil) then
      obj.parent = self;
    end;
    do return value end
  end,
  'Equals', function(self,obj)
    do return obj == self end
  end
  ,'__class__',  ink.runtime.RObject,
  '__properties__',  {get_rootContentContainer="get_rootContentContainer",get_path="get_path",set_debugMetadata="set_debugMetadata",get_debugMetadata="get_debugMetadata"}
)

ink.runtime.Choice.new = function()
  local self = _hx_new(ink.runtime.Choice.prototype)
  ink.runtime.Choice.super(self)
  return self
end
ink.runtime.Choice.super = function(self)
  ink.runtime.RObject.super(self);
end
_hxClasses["ink.runtime.Choice"] = ink.runtime.Choice
ink.runtime.Choice.__name__ = {"ink","runtime","Choice"}
ink.runtime.Choice.create = function(choice)
  local me = ink.runtime.Choice.new();
  me.choicePoint = choice;
  do return me end;
end
ink.runtime.Choice.prototype = _hx_a(
  'text', nil,
  'pathStringOnChoice', nil,
  'get_pathStringOnChoice', function(self)
    do return self.choicePoint:get_pathStringOnChoice() end
  end,
  'index', nil,
  'choicePoint', nil,
  'threadAtGeneration', nil,
  'originalThreadIndex', nil,
  'originalChoicePath', nil
  ,'__class__',  ink.runtime.Choice,
  '__properties__',  {get_pathStringOnChoice="get_pathStringOnChoice"}
)
ink.runtime.Choice.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.Choice.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.Choice.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.ChoicePoint.new = function()
  local self = _hx_new(ink.runtime.ChoicePoint.prototype)
  ink.runtime.ChoicePoint.super(self)
  return self
end
ink.runtime.ChoicePoint.super = function(self)
  ink.runtime.RObject.super(self);
  self.onceOnly = true;
end
_hxClasses["ink.runtime.ChoicePoint"] = ink.runtime.ChoicePoint
ink.runtime.ChoicePoint.__name__ = {"ink","runtime","ChoicePoint"}
ink.runtime.ChoicePoint.createOnceOnly = function(onceOnly)
  local me = ink.runtime.ChoicePoint.new();
  me.onceOnly = onceOnly;
  do return me end;
end
ink.runtime.ChoicePoint.prototype = _hx_a(
  'pathOnChoice', nil,
  'choiceTarget', nil,
  'get_choiceTarget', function(self)
    do return ink.runtime.LibUtil.asNoInline(self:ResolvePath(self.pathOnChoice),ink.runtime.Container) end
  end,
  'get_pathStringOnChoice', function(self)
    do return self:CompactPathString(self.pathOnChoice) end
  end,
  'set_pathStringOnChoice', function(self,value)
    self.pathOnChoice = ink.runtime.Path.createFromString(value);
    do return value end
  end,
  'hasCondition', nil,
  'hasStartContent', nil,
  'hasChoiceOnlyContent', nil,
  'onceOnly', nil,
  'isInvisibleDefault', nil,
  'get_flags', function(self)
    local flags = 0;
    if (self.hasCondition) then
      flags = _hx_bit.bor(flags,1);
    end;
    if (self.hasStartContent) then
      flags = _hx_bit.bor(flags,2);
    end;
    if (self.hasChoiceOnlyContent) then
      flags = _hx_bit.bor(flags,4);
    end;
    if (self.isInvisibleDefault) then
      flags = _hx_bit.bor(flags,8);
    end;
    if (self.onceOnly) then
      flags = _hx_bit.bor(flags,16);
    end;
    do return flags end
  end,
  'set_flags', function(self,value)
    local flags = 0;
    flags = _hx_bit.bor(flags,((function()
      local _hx_1
      if ((function()
      self.hasCondition = (_hx_bit.band(value,1)) > 0; return self.hasCondition end)()) then
      _hx_1 = 1; else
      _hx_1 = 0; end
      return _hx_1
    end )()));
    flags = _hx_bit.bor(flags,((function()
      local _hx_2
      if ((function()
      self.hasStartContent = (_hx_bit.band(value,2)) > 0; return self.hasStartContent end)()) then
      _hx_2 = 2; else
      _hx_2 = 0; end
      return _hx_2
    end )()));
    flags = _hx_bit.bor(flags,((function()
      local _hx_3
      if ((function()
      self.hasChoiceOnlyContent = (_hx_bit.band(value,4)) > 0; return self.hasChoiceOnlyContent end)()) then
      _hx_3 = 4; else
      _hx_3 = 0; end
      return _hx_3
    end )()));
    flags = _hx_bit.bor(flags,((function()
      local _hx_4
      if ((function()
      self.isInvisibleDefault = (_hx_bit.band(value,8)) > 0; return self.isInvisibleDefault end)()) then
      _hx_4 = 8; else
      _hx_4 = 0; end
      return _hx_4
    end )()));
    flags = _hx_bit.bor(flags,((function()
      local _hx_5
      if ((function()
      self.onceOnly = (_hx_bit.band(value,16)) > 0; return self.onceOnly end)()) then
      _hx_5 = 16; else
      _hx_5 = 0; end
      return _hx_5
    end )()));
    do return flags end
  end,
  'toString', function(self)
    local targetLineNum = self:DebugLineNumberOfPath(self.pathOnChoice);
    local targetString = self.pathOnChoice:toString();
    if (targetLineNum ~= nil) then
      targetString = " line " .. Std.string(targetLineNum);
    end;
    do return "Choice: -> " .. targetString end
  end
  ,'__class__',  ink.runtime.ChoicePoint,
  '__properties__',  {set_flags="set_flags",get_flags="get_flags",set_pathStringOnChoice="set_pathStringOnChoice",get_pathStringOnChoice="get_pathStringOnChoice",get_choiceTarget="get_choiceTarget"}
)
ink.runtime.ChoicePoint.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.ChoicePoint.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.ChoicePoint.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.Cloner.new = function()
  local self = _hx_new(ink.runtime.Cloner.prototype)
  ink.runtime.Cloner.super(self)
  return self
end
ink.runtime.Cloner.super = function(self)
  self.stringMapCloner = ink.runtime.MapCloner.new(self,haxe.ds.StringMap);
  self.intMapCloner = ink.runtime.MapCloner.new(self,haxe.ds.IntMap);
  self.classHandles = haxe.ds.StringMap.new();
  local _this = self.classHandles;
  _this.v["String"] = _hx_bind(self,self.returnString);
  _this.k["String"] = true;
  local _this1 = self.classHandles;
  _this1.v["Array"] = _hx_bind(self,self.cloneArray);
  _this1.k["Array"] = true;
  local value = (function() local __=self.stringMapCloner; return _hx_bind(__,__.clone) end)();
  local _this2 = self.classHandles;
  _this2.v["haxe.ds.StringMap"] = value;
  _this2.k["haxe.ds.StringMap"] = true;
  local value1 = (function() local __=self.intMapCloner; return _hx_bind(__,__.clone) end)();
  local _this3 = self.classHandles;
  _this3.v["haxe.ds.IntMap"] = value1;
  _this3.k["haxe.ds.IntMap"] = true;
end
_hxClasses["ink.runtime.Cloner"] = ink.runtime.Cloner
ink.runtime.Cloner.__name__ = {"ink","runtime","Cloner"}
ink.runtime.Cloner.prototype = _hx_a(
  'cache', nil,
  'classHandles', nil,
  'stringMapCloner', nil,
  'intMapCloner', nil,
  'returnString', function(self,v)
    do return v end
  end,
  'clone', function(self,v)
    self.cache = haxe.ds.ObjectMap.new();
    local outcome = self:_clone(v);
    self.cache = nil;
    do return outcome end
  end,
  '_clone', function(self,v)
    if (Type.getClassName(v) ~= nil) then
      do return v end;
    end;
    local _g = Type.typeof(v);
    local _g1 = _g[1];
    if (_g1) == 0 then
      do return nil end;
    elseif (_g1) == 1 then
      do return v end;
    elseif (_g1) == 2 then
      do return v end;
    elseif (_g1) == 3 then
      do return v end;
    elseif (_g1) == 4 then
      do return self:handleAnonymous(v) end;
    elseif (_g1) == 5 then
      do return nil end;
    elseif (_g1) == 6 then
      local c = _g[2];
      if (self.cache.k[v] == nil) then
        local _this = self.cache;
        local value = self:handleClass(c,v);
        _this.h[v] = value;
        _this.k[v] = true;
      end;
      do return self.cache.h[v] end;
    elseif (_g1) == 7 then
      local e = _g[2];
      do return v end;
    elseif (_g1) == 8 then
      do return nil end; end;
  end,
  'handleAnonymous', function(self,v)
    local properties = Reflect.fields(v);
    local anonymous = _hx_e();
    local _g1 = 0;
    local _g = properties.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local property = properties[i];
      local tmp;
      anonymous[property] = self:_clone((function()
        local _hx_1
        if (v == nil) then
        _hx_1 = nil; elseif ((v.__properties__ ~= nil) and (Reflect.field(v,"get_" .. property) ~= nil)) then
        _hx_1 = Reflect.callMethod(v,Reflect.field(v,"get_" .. property),_hx_tab_array({ }, 0)); else
        _hx_1 = Reflect.field(v,property); end
        return _hx_1
      end )());
      end;
    do return anonymous end
  end,
  'handleClass', function(self,c,inValue)
    local this1 = self.classHandles;
    local key = Type.getClassName(c);
    local handle = this1.v[key];
    if (handle == nil) then
      handle = _hx_bind(self,self.cloneClass);
    end;
    do return handle(inValue) end
  end,
  'cloneArray', function(self,inValue)
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = inValue;
    while (_g1 < _g2.length) do
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(i);
      end;
    local array = _g;
    local _g11 = 0;
    local _g3 = array.length;
    while (_g11 < _g3) do
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      array[i1] = self:_clone(array[i1]);
      end;
    do return array end
  end,
  'cloneClass', function(self,inValue)
    local outValue = Type.createEmptyInstance(Type.getClass(inValue));
    local fields = Reflect.fields(inValue);
    local _g1 = 0;
    local _g = fields.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local field = fields[i];
      local tmp;
      local property = (function()
        local _hx_1
        if (inValue == nil) then
        _hx_1 = nil; elseif ((inValue.__properties__ ~= nil) and (Reflect.field(inValue,"get_" .. field) ~= nil)) then
        _hx_1 = Reflect.callMethod(inValue,Reflect.field(inValue,"get_" .. field),_hx_tab_array({ }, 0)); else
        _hx_1 = Reflect.field(inValue,field); end
        return _hx_1
      end )();
      outValue[field] = self:_clone(property);
      end;
    do return outValue end
  end
  ,'__class__',  ink.runtime.Cloner
)

ink.runtime.CountFlags.new = {}
_hxClasses["ink.runtime.CountFlags"] = ink.runtime.CountFlags
ink.runtime.CountFlags.__name__ = {"ink","runtime","CountFlags"}

ink.runtime.INamedContent.new = {}
_hxClasses["ink.runtime.INamedContent"] = ink.runtime.INamedContent
ink.runtime.INamedContent.__name__ = {"ink","runtime","INamedContent"}
ink.runtime.INamedContent.prototype = _hx_a(
  'get_hasValidName', nil,
  'name', nil,
  'hasValidName', nil
  ,'__class__',  ink.runtime.INamedContent,
  '__properties__',  {get_hasValidName="get_hasValidName"}
)

ink.runtime.Container.new = function()
  local self = _hx_new(ink.runtime.Container.prototype)
  ink.runtime.Container.super(self)
  return self
end
ink.runtime.Container.super = function(self)
  ink.runtime.RObject.super(self);
  self._content = Array.new();
  self.namedContent = haxe.ds.StringMap.new();
end
_hxClasses["ink.runtime.Container"] = ink.runtime.Container
ink.runtime.Container.__name__ = {"ink","runtime","Container"}
ink.runtime.Container.__interfaces__ = {ink.runtime.INamedContent}
ink.runtime.Container.prototype = _hx_a(
  'name', nil,
  'get_content', function(self)
    do return self._content end
  end,
  'set_content', function(self,value)
    self:AddContentList(value);
    do return self._content end
  end,
  '_content', nil,
  'namedContent', nil,
  'get_namedOnlyContent', function(self)
    local namedOnlyContent = haxe.ds.StringMap.new();
    local k = self.namedContent:keys();
    while (k:hasNext()) do
      local k1 = k:next();
      local this1 = self.namedContent;
      local value = this1.v[k1];
      namedOnlyContent.v[k1] = value;
      namedOnlyContent.k[k1] = true;
      end;
    local _g1 = 0;
    local _g = self._content.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local c = self._content[i];
      local named = (function()
        local _hx_1
        if (lua.Boot.__instanceof(c,ink.runtime.INamedContent)) then
        _hx_1 = c; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if ((named ~= nil) and named:get_hasValidName()) then
        namedOnlyContent:remove(named.name);
      end;
      end;
    if (not namedOnlyContent:iterator():hasNext()) then
      namedOnlyContent = nil;
    end;
    do return namedOnlyContent end
  end,
  'set_namedOnlyContent', function(self,value)
    local existingNamedOnly = self:get_namedOnlyContent();
    if (existingNamedOnly ~= nil) then
      local k = existingNamedOnly:keys();
      while (k:hasNext()) do
        local k1 = k:next();
        self.namedContent:remove(k1);
        end;
    end;
    if (value == nil) then
      do return existingNamedOnly end;
    end;
    local k2 = value:keys();
    while (k2:hasNext()) do
      local k3 = k2:next();
      local obj = value.v[k3];
      local named = (function()
        local _hx_1
        if (lua.Boot.__instanceof(obj,ink.runtime.INamedContent)) then
        _hx_1 = obj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if (named ~= nil) then
        self:AddToNamedContentOnly(named);
      end;
      end;
    do return value end
  end,
  'visitsShouldBeCounted', nil,
  'turnIndexShouldBeCounted', nil,
  'countingAtStartOnly', nil,
  'get_countFlags', function(self)
    local flags = 0;
    if (self.visitsShouldBeCounted) then
      flags = _hx_bit.bor(flags,1);
    end;
    if (self.turnIndexShouldBeCounted) then
      flags = _hx_bit.bor(flags,2);
    end;
    if (self.countingAtStartOnly) then
      flags = _hx_bit.bor(flags,4);
    end;
    if (flags == 4) then
      flags = 0;
    end;
    do return flags end
  end,
  'set_countFlags', function(self,value)
    local flag = value;
    if ((_hx_bit.band(flag,1)) > 0) then
      self.visitsShouldBeCounted = true;
    end;
    if ((_hx_bit.band(flag,2)) > 0) then
      self.turnIndexShouldBeCounted = true;
    end;
    if ((_hx_bit.band(flag,4)) > 0) then
      self.countingAtStartOnly = true;
    end;
    do return value end
  end,
  'hasValidName', nil,
  'get_hasValidName', function(self)
    if (self.name ~= nil) then
      do return self.name.length > 0 end;
    else
      do return false end;
    end;
  end,
  'AddToNamedContentOnly', function(self,namedContentObj)
    if (not lua.Boot.__instanceof(namedContentObj,ink.runtime.RObject)) then
      _G.error("Can only add Runtime.Objects to a Runtime.Container",0);
    end;
    local runtimeObj = namedContentObj;
    runtimeObj.parent = self;
    local key = namedContentObj.name;
    local _this = self.namedContent;
    _this.v[key] = namedContentObj;
    _this.k[key] = true;
  end,
  'AddContent', function(self,contentObj)
    self._content:push(contentObj);
    if (contentObj.parent ~= nil) then
      _G.error(ink.runtime.SystemException.new("content is already in " .. Std.string(contentObj.parent)),0);
    end;
    contentObj.parent = self;
    self:TryAddNamedContent(contentObj);
  end,
  'AddContentList', function(self,contentList)
    local _g = 0;
    while (_g < contentList.length) do
      local c = contentList[_g];
      _g = _g + 1;
      self:AddContent(c);
      end;
  end,
  'InsertContent', function(self,contentObj,index)
    local _this = self._content;
    local pos = index;
    if (pos > _this.length) then
      pos = _this.length;
    end;
    if (pos < 0) then
      pos = _this.length + pos;
      if (pos < 0) then
        pos = 0;
      end;
    end;
    local cur_len = _this.length;
    while (cur_len > pos) do
      _this[cur_len] = _this[cur_len - 1];
      cur_len = cur_len - 1;
      end;
    _this[pos] = contentObj;
    if (contentObj.parent ~= nil) then
      _G.error(ink.runtime.SystemException.new("content is already in " .. Std.string(contentObj.parent)),0);
    end;
    contentObj.parent = self;
    self:TryAddNamedContent(contentObj);
  end,
  'TryAddNamedContent', function(self,contentObj)
    local namedContentObj = (function()
      local _hx_1
      if (lua.Boot.__instanceof(contentObj,ink.runtime.INamedContent)) then
      _hx_1 = contentObj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if ((namedContentObj ~= nil) and namedContentObj:get_hasValidName()) then
      self:AddToNamedContentOnly(namedContentObj);
    end;
  end,
  'AddContentsOfContainer', function(self,otherContainer)
    ink.runtime.LibUtil.addRangeForArray(self._content,otherContainer._content);
    local _g = 0;
    local _g1 = otherContainer._content;
    while (_g < _g1.length) do
      local obj = _g1[_g];
      _g = _g + 1;
      obj.parent = self;
      self:TryAddNamedContent(obj);
      end;
  end,
  'ContentWithPathComponent', function(self,component)
    if (component:get_isIndex()) then
      if ((component.index >= 0) and (component.index < self._content.length)) then
        do return self._content[component.index] end;
      else
        do return nil end;
      end;
    else
      if (component:get_isParent()) then
        do return self.parent end;
      else
        local foundContent = nil;
        local map = self.namedContent;
        local prop = component.name;
        foundContent = map.v[prop];
        if (foundContent ~= nil) then
          do return foundContent end;
        else
          _G.error(ink.runtime.StoryException.new("Content '" .. component.name .. "' not found at path: '" .. Std.string(self:get_path()) .. "'"),0);
        end;
      end;
    end;
  end,
  'ContentAtPath', function(self,path,partialPathLength)
    if (partialPathLength == nil) then
      partialPathLength = -1;
    end;
    if (partialPathLength == -1) then
      partialPathLength = path.components.length;
    end;
    local currentContainer = self;
    local currentObj = self;
    local _g1 = 0;
    local _g = partialPathLength;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local comp = path.components[i];
      if (currentContainer == nil) then
        _G.error(ink.runtime.SystemException.new("Path continued, but previous object wasn't a container: " .. Std.string(currentObj)),0);
      end;
      currentObj = currentContainer:ContentWithPathComponent(comp);
      currentContainer = (function()
        local _hx_1
        if (lua.Boot.__instanceof(currentObj,ink.runtime.Container)) then
        _hx_1 = currentObj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      end;
    do return currentObj end
  end,
  'BuildStringOfHierarchy', function(self,sb,indentation,pointedObj)
    local appendIndentation = function()
      local spacesPerIndent = 4;
      local _g1 = 0;
      local _g = spacesPerIndent * indentation;
      while (_g1 < _g) do
        _g1 = _g1 + 1;
        local i = _g1 - 1;
        local str = " ";
        _G.table.insert(sb.b,str);
        local sb1 = sb;
        sb1.length = sb1.length + str.length;
        end;
    end;
    appendIndentation();
    local str1 = "[";
    _G.table.insert(sb.b,str1);
    local sb2 = sb;
    sb2.length = sb2.length + str1.length;
    if (self:get_hasValidName()) then
      local str2 = Std.string(" (" .. self.name .. ")");
      _G.table.insert(sb.b,str2);
      local sb3 = sb;
      sb3.length = sb3.length + str2.length;
    end;
    if (self == pointedObj) then
      local str3 = "  <---";
      _G.table.insert(sb.b,str3);
      local sb4 = sb;
      sb4.length = sb4.length + str3.length;
    end;
    local str4 = "\n";
    _G.table.insert(sb.b,str4);
    local sb5 = sb;
    sb5.length = sb5.length + str4.length;
    indentation = indentation + 1;
    local _g11 = 0;
    local _g2 = self._content.length;
    while (_g11 < _g2) do
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      local obj = self._content[i1];
      if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
        local container = obj;
        container:BuildStringOfHierarchy(sb,indentation,pointedObj);
      else
        appendIndentation();
        if (lua.Boot.__instanceof(obj,ink.runtime.StringValue)) then
          local str5 = "\"";
          _G.table.insert(sb.b,str5);
          local sb6 = sb;
          sb6.length = sb6.length + str5.length;
          local str6 = Std.string(StringTools.replace(Std.string(obj),"\n","\\n"));
          _G.table.insert(sb.b,str6);
          local sb7 = sb;
          sb7.length = sb7.length + str6.length;
          local str7 = "\"";
          _G.table.insert(sb.b,str7);
          local sb8 = sb;
          sb8.length = sb8.length + str7.length;
        else
          local str8 = Std.string(Std.string(obj));
          _G.table.insert(sb.b,str8);
          local sb9 = sb;
          sb9.length = sb9.length + str8.length;
        end;
      end;
      if (i1 ~= (self._content.length - 1)) then
        local str9 = ",";
        _G.table.insert(sb.b,str9);
        local sb10 = sb;
        sb10.length = sb10.length + str9.length;
      end;
      if (not lua.Boot.__instanceof(obj,ink.runtime.Container) and (obj == pointedObj)) then
        local str10 = "  <---";
        _G.table.insert(sb.b,str10);
        local sb11 = sb;
        sb11.length = sb11.length + str10.length;
      end;
      local str11 = "\n";
      _G.table.insert(sb.b,str11);
      local sb12 = sb;
      sb12.length = sb12.length + str11.length;
      end;
    local onlyNamed = haxe.ds.StringMap.new();
    local k = self.namedContent:keys();
    local _hx_break_0 = false;
    while (k:hasNext()) do
      repeat
      local k1 = k:next();
      local this1 = self.namedContent;
      if (self._content:indexOf(this1.v[k1]) >= 0) then
        break;
      else
        local this2 = self.namedContent;
        local value = this2.v[k1];
        onlyNamed.v[k1] = value;
        onlyNamed.k[k1] = true;
      end;

    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    if (onlyNamed:iterator():hasNext()) then
      appendIndentation();
      local str12 = Std.string("-- named: --" .. "\n");
      _G.table.insert(sb.b,str12);
      local sb13 = sb;
      sb13.length = sb13.length + str12.length;
      local k2 = onlyNamed:keys();
      while (k2:hasNext()) do
        local k3 = k2:next();
        local objV = onlyNamed.v[k3];
        if (not lua.Boot.__instanceof(objV,ink.runtime.Container)) then
          _G.error("Can only print out named Containers",0);
        end;
        local container1 = objV;
        container1:BuildStringOfHierarchy(sb,indentation,pointedObj);
        local str13 = "\n";
        _G.table.insert(sb.b,str13);
        local sb14 = sb;
        sb14.length = sb14.length + str13.length;
        end;
    end;
    indentation = indentation - 1;
    appendIndentation();
    local str14 = "]";
    _G.table.insert(sb.b,str14);
    local sb15 = sb;
    sb15.length = sb15.length + str14.length;
  end,
  'BuildStringOfHierarchyVirtual', function(self)
    local sb = StringBuf.new();
    self:BuildStringOfHierarchy(sb,0,nil);
    do return _G.table.concat(sb.b) end
  end
  ,'__class__',  ink.runtime.Container,
  '__properties__',  {get_hasValidName="get_hasValidName",set_countFlags="set_countFlags",get_countFlags="get_countFlags",set_namedOnlyContent="set_namedOnlyContent",get_namedOnlyContent="get_namedOnlyContent",set_content="set_content",get_content="get_content"}
)
ink.runtime.Container.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.Container.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.Container.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.ControlCommand.new = function()
  local self = _hx_new(ink.runtime.ControlCommand.prototype)
  ink.runtime.ControlCommand.super(self)
  return self
end
ink.runtime.ControlCommand.super = function(self)
  ink.runtime.RObject.super(self);
  self.commandType = -1;
end
_hxClasses["ink.runtime.ControlCommand"] = ink.runtime.ControlCommand
ink.runtime.ControlCommand.__name__ = {"ink","runtime","ControlCommand"}
ink.runtime.ControlCommand.createFromCommandType = function(commandType)
  local me = ink.runtime.ControlCommand.new();
  me.commandType = commandType;
  do return me end;
end
ink.runtime.ControlCommand.EvalStart = function()
  do return ink.runtime.ControlCommand.createFromCommandType(0) end;
end
ink.runtime.ControlCommand.EvalOutput = function()
  do return ink.runtime.ControlCommand.createFromCommandType(1) end;
end
ink.runtime.ControlCommand.EvalEnd = function()
  do return ink.runtime.ControlCommand.createFromCommandType(2) end;
end
ink.runtime.ControlCommand.Duplicate = function()
  do return ink.runtime.ControlCommand.createFromCommandType(3) end;
end
ink.runtime.ControlCommand.PopEvaluatedValue = function()
  do return ink.runtime.ControlCommand.createFromCommandType(4) end;
end
ink.runtime.ControlCommand.PopFunction = function()
  do return ink.runtime.ControlCommand.createFromCommandType(5) end;
end
ink.runtime.ControlCommand.PopTunnel = function()
  do return ink.runtime.ControlCommand.createFromCommandType(6) end;
end
ink.runtime.ControlCommand.BeginString = function()
  do return ink.runtime.ControlCommand.createFromCommandType(7) end;
end
ink.runtime.ControlCommand.EndString = function()
  do return ink.runtime.ControlCommand.createFromCommandType(8) end;
end
ink.runtime.ControlCommand.NoOp = function()
  do return ink.runtime.ControlCommand.createFromCommandType(9) end;
end
ink.runtime.ControlCommand.ChoiceCount = function()
  do return ink.runtime.ControlCommand.createFromCommandType(10) end;
end
ink.runtime.ControlCommand.TurnsSince = function()
  do return ink.runtime.ControlCommand.createFromCommandType(11) end;
end
ink.runtime.ControlCommand.VisitIndex = function()
  do return ink.runtime.ControlCommand.createFromCommandType(12) end;
end
ink.runtime.ControlCommand.SequenceShuffleIndex = function()
  do return ink.runtime.ControlCommand.createFromCommandType(13) end;
end
ink.runtime.ControlCommand.StartThread = function()
  do return ink.runtime.ControlCommand.createFromCommandType(14) end;
end
ink.runtime.ControlCommand.Done = function()
  do return ink.runtime.ControlCommand.createFromCommandType(15) end;
end
ink.runtime.ControlCommand.End = function()
  do return ink.runtime.ControlCommand.createFromCommandType(16) end;
end
ink.runtime.ControlCommand.prototype = _hx_a(
  'commandType', nil,
  'Copy', function(self)
    do return ink.runtime.ControlCommand.createFromCommandType(self.commandType) end
  end,
  'ToString', function(self)
    do return Std.string(self.commandType) end
  end,
  'toString', function(self)
    do return Std.string(self.commandType) end
  end
  ,'__class__',  ink.runtime.ControlCommand
)
ink.runtime.ControlCommand.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.ControlCommand.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.ControlCommand.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.DebugMetadata.new = function()
  local self = _hx_new(ink.runtime.DebugMetadata.prototype)
  ink.runtime.DebugMetadata.super(self)
  return self
end
ink.runtime.DebugMetadata.super = function(self)
  self.sourceName = nil;
  self.fileName = nil;
  self.endLineNumber = 0;
  self.startLineNumber = 0;
end
_hxClasses["ink.runtime.DebugMetadata"] = ink.runtime.DebugMetadata
ink.runtime.DebugMetadata.__name__ = {"ink","runtime","DebugMetadata"}
ink.runtime.DebugMetadata.prototype = _hx_a(
  'startLineNumber', nil,
  'endLineNumber', nil,
  'fileName', nil,
  'sourceName', nil,
  'toString', function(self)
    if (self.fileName ~= nil) then
      do return "line " .. self.startLineNumber .. " of " .. self.fileName end;
    else
      do return "line " .. self.startLineNumber end;
    end;
  end
  ,'__class__',  ink.runtime.DebugMetadata
)

ink.runtime.Divert.new = function()
  local self = _hx_new(ink.runtime.Divert.prototype)
  ink.runtime.Divert.super(self)
  return self
end
ink.runtime.Divert.super = function(self)
  ink.runtime.RObject.super(self);
  self.pushesToStack = false;
end
_hxClasses["ink.runtime.Divert"] = ink.runtime.Divert
ink.runtime.Divert.__name__ = {"ink","runtime","Divert"}
ink.runtime.Divert.createFromPushType = function(stackPushType)
  local me = ink.runtime.Divert.new();
  me.pushesToStack = true;
  me.stackPushType = stackPushType;
  do return me end;
end
ink.runtime.Divert.prototype = _hx_a(
  'get_targetPath', function(self)
    if ((self._targetPath ~= nil) and self._targetPath.isRelative) then
      local targetObj = self:get_targetContent();
      if (targetObj ~= nil) then
        self._targetPath = targetObj:get_path();
      end;
    end;
    do return self._targetPath end
  end,
  'set_targetPath', function(self,value)
    self._targetPath = value;
    self._targetContent = nil;
    do return value end
  end,
  '_targetPath', nil,
  'targetContent', nil,
  'get_targetContent', function(self)
    if (self._targetContent == nil) then
      self._targetContent = self:ResolvePath(self._targetPath);
    end;
    do return self._targetContent end
  end,
  '_targetContent', nil,
  'get_targetPathString', function(self)
    local result;
    if (self:get_targetPath() == nil) then
      do return nil end;
    end;
    result = self:CompactPathString(self:get_targetPath());
    do return result end
  end,
  'set_targetPathString', function(self,value)
    if (value == nil) then
      self:set_targetPath(nil);
    else
      self:set_targetPath(ink.runtime.Path.createFromString(value));
    end;
    do return value end
  end,
  'variableDivertName', nil,
  'hasVariableTarget', nil,
  'get_hasVariableTarget', function(self)
    do return self.variableDivertName ~= nil end
  end,
  'pushesToStack', nil,
  'stackPushType', nil,
  'isExternal', nil,
  'externalArgs', nil,
  'isConditional', nil,
  'Equals', function(self,obj)
    local otherDivert = (function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.Divert)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (otherDivert ~= nil) then
      if (self:get_hasVariableTarget() == otherDivert:get_hasVariableTarget()) then
        if (self:get_hasVariableTarget()) then
          do return self.variableDivertName == otherDivert.variableDivertName end;
        else
          do return self:get_targetPath():Equals(otherDivert:get_targetPath()) end;
        end;
      end;
    end;
    do return false end
  end,
  'toString', function(self)
    if (self:get_hasVariableTarget()) then
      do return "Divert(variable: " .. self.variableDivertName .. ")" end;
    else
      if (self:get_targetPath() == nil) then
        do return "Divert(null)" end;
      else
        local sb_length;
        local sb_b = _hx_e();
        sb_length = 0;
        local targetStr = self:get_targetPath():toString();
        local targetLineNum = self:DebugLineNumberOfPath(self:get_targetPath());
        if (targetLineNum ~= nil) then
          targetStr = "line " .. Std.string(targetLineNum);
        end;
        local str = "Divert";
        _G.table.insert(sb_b,str);
        sb_length = sb_length + str.length;
        if (self.pushesToStack) then
          if (self.stackPushType == 1) then
            local str1 = " function";
            _G.table.insert(sb_b,str1);
            sb_length = sb_length + str1.length;
          else
            local str2 = " tunnel";
            _G.table.insert(sb_b,str2);
            sb_length = sb_length + str2.length;
          end;
        end;
        local str3 = " (";
        _G.table.insert(sb_b,str3);
        sb_length = sb_length + str3.length;
        local str4 = Std.string(targetStr);
        _G.table.insert(sb_b,str4);
        sb_length = sb_length + str4.length;
        local str5 = ")";
        _G.table.insert(sb_b,str5);
        sb_length = sb_length + str5.length;
        do return _G.table.concat(sb_b) end;
      end;
    end;
  end
  ,'__class__',  ink.runtime.Divert,
  '__properties__',  {get_hasVariableTarget="get_hasVariableTarget",set_targetPathString="set_targetPathString",get_targetPathString="get_targetPathString",get_targetContent="get_targetContent",set_targetPath="set_targetPath",get_targetPath="get_targetPath"}
)
ink.runtime.Divert.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.Divert.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.Divert.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})
_hxClasses["ink.runtime.GlueType"] = ink.runtime.GlueType;
_hxClasses["ink.runtime.GlueType"] = { __ename__ = {"ink","runtime","GlueType"}, __constructs__ = _hx_tab_array({[0]="Bidirectional","Left","Right"},3)}
ink.runtime.GlueType = _hxClasses["ink.runtime.GlueType"];
ink.runtime.GlueType.Bidirectional = _hx_tab_array({[0]="Bidirectional",0,__enum__ = ink.runtime.GlueType},2)
rawset(ink.runtime.GlueType.Bidirectional, 'toString', _estr)

ink.runtime.GlueType.Left = _hx_tab_array({[0]="Left",1,__enum__ = ink.runtime.GlueType},2)
rawset(ink.runtime.GlueType.Left, 'toString', _estr)

ink.runtime.GlueType.Right = _hx_tab_array({[0]="Right",2,__enum__ = ink.runtime.GlueType},2)
rawset(ink.runtime.GlueType.Right, 'toString', _estr)

ink.runtime.GlueType.__empty_constructs__ = _hx_tab_array({[0] = ink.runtime.GlueType.Bidirectional,ink.runtime.GlueType.Left,ink.runtime.GlueType.Right}, 3)

ink.runtime.Glue.new = function(type)
  local self = _hx_new(ink.runtime.Glue.prototype)
  ink.runtime.Glue.super(self,type)
  return self
end
ink.runtime.Glue.super = function(self,type)
  ink.runtime.RObject.super(self);
  self.glueType = type;
end
_hxClasses["ink.runtime.Glue"] = ink.runtime.Glue
ink.runtime.Glue.__name__ = {"ink","runtime","Glue"}
ink.runtime.Glue.prototype = _hx_a(
  'glueType', nil,
  'isLeft', nil,
  'get_isLeft', function(self)
    do return self.glueType == ink.runtime.GlueType.Left end
  end,
  'isBi', nil,
  'get_isBi', function(self)
    do return self.glueType == ink.runtime.GlueType.Bidirectional end
  end,
  'isRight', nil,
  'get_isRight', function(self)
    do return self.glueType == ink.runtime.GlueType.Right end
  end,
  'toString', function(self)
    local _g = self.glueType;
    local _g1 = _g[1];
    if (_g1) == 0 then
      do return "BidirGlue" end;
    elseif (_g1) == 1 then
      do return "LeftGlue" end;
    elseif (_g1) == 2 then
      do return "RightGlue" end; end;
  end
  ,'__class__',  ink.runtime.Glue,
  '__properties__',  {get_isRight="get_isRight",get_isBi="get_isBi",get_isLeft="get_isLeft"}
)
ink.runtime.Glue.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.Glue.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.Glue.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.HashSet.new = function()
  local self = _hx_new(ink.runtime.HashSet.prototype)
  ink.runtime.HashSet.super(self)
  return self
end
ink.runtime.HashSet.super = function(self)
  self.map = haxe.ds.ObjectMap.new();
end
_hxClasses["ink.runtime.HashSet"] = ink.runtime.HashSet
ink.runtime.HashSet.__name__ = {"ink","runtime","HashSet"}
ink.runtime.HashSet.prototype = _hx_a(
  'map', nil,
  'add', function(self,key)
    local _this = self.map;
    _this.h[key] = true;
    _this.k[key] = true;
  end,
  'keys', function(self)
    do return self.map:keys() end
  end,
  'contains', function(self,key)
    do return self.map.k[key] ~= nil end
  end
  ,'__class__',  ink.runtime.HashSet
)

ink.runtime.HashSetString.new = function()
  local self = _hx_new(ink.runtime.HashSetString.prototype)
  ink.runtime.HashSetString.super(self)
  return self
end
ink.runtime.HashSetString.super = function(self)
  self.map = haxe.ds.StringMap.new();
end
_hx_exports["ink"]["runtime"]["HashSetString"] = ink.runtime.HashSetString
_hxClasses["ink.runtime.HashSetString"] = ink.runtime.HashSetString
ink.runtime.HashSetString.__name__ = {"ink","runtime","HashSetString"}
ink.runtime.HashSetString.prototype = _hx_a(
  'map', nil,
  'add', function(self,key)
    local _this = self.map;
    _this.v[key] = true;
    _this.k[key] = true;
  end,
  'keys', function(self)
    do return self.map:keys() end
  end,
  'contains', function(self,key)
    local _this = self.map;
    do return _this.v[key] end
  end,
  'clone', function(self)
    local c = ink.runtime.HashSetString.new();
    local p = self:keys();
    while (p:hasNext()) do
      local p1 = p:next();
      c:add(p1);
      end;
    do return c end
  end
  ,'__class__',  ink.runtime.HashSetString
)

ink.runtime.IEquatable.new = {}
_hxClasses["ink.runtime.IEquatable"] = ink.runtime.IEquatable
ink.runtime.IEquatable.__name__ = {"ink","runtime","IEquatable"}
ink.runtime.IEquatable.prototype = _hx_a(
  'Equals', nil
  ,'__class__',  ink.runtime.IEquatable
)

ink.runtime.IProxy.new = {}
_hxClasses["ink.runtime.IProxy"] = ink.runtime.IProxy
ink.runtime.IProxy.__name__ = {"ink","runtime","IProxy"}
ink.runtime.IProxy.prototype = _hx_a(
  'field', nil,
  'setField', nil
  ,'__class__',  ink.runtime.IProxy
)

ink.runtime.SystemException.new = function(msg)
  local self = _hx_new(ink.runtime.SystemException.prototype)
  ink.runtime.SystemException.super(self,msg)
  return self
end
ink.runtime.SystemException.super = function(self,msg)
  self.msg = msg;
end
_hxClasses["ink.runtime.SystemException"] = ink.runtime.SystemException
ink.runtime.SystemException.__name__ = {"ink","runtime","SystemException"}
ink.runtime.SystemException.prototype = _hx_a(
  'msg', nil,
  'toString', function(self)
    do return Type.getClassName(Type.getClass(self)) .. ":: " .. self.msg end
  end
  ,'__class__',  ink.runtime.SystemException
)

ink.runtime.Json.new = {}
_hxClasses["ink.runtime.Json"] = ink.runtime.Json
ink.runtime.Json.__name__ = {"ink","runtime","Json"}
ink.runtime.Json.ListToJArray = function(serialisables)
  local jArray = Array.new();
  local _g_head = serialisables.h;
  while (_g_head ~= nil) do
    local val = _g_head.item;
    _g_head = _g_head.next;
    local s = val;
    jArray:push(ink.runtime.Json.RuntimeObjectToJToken(s));
    end;
  do return jArray end;
end
ink.runtime.Json.ArrayToJArray = function(serialisables)
  local jArray = Array.new();
  local _g = 0;
  while (_g < serialisables.length) do
    local s = serialisables[_g];
    _g = _g + 1;
    jArray:push(ink.runtime.Json.RuntimeObjectToJToken(s));
    end;
  do return jArray end;
end
ink.runtime.Json.JArrayToRuntimeObjList = function(jArray,skipLast)
  if (skipLast == nil) then
    skipLast = false;
  end;
  local count = jArray.length;
  if (skipLast) then
    count = count - 1;
  end;
  local list = List.new();
  local _g1 = 0;
  local _g = count;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local jTok = jArray[i];
    local obj = ink.runtime.Json.JTokenToRuntimeObject(jTok);
    local runtimeObj = (function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.RObject)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    list:add(runtimeObj);
    end;
  do return list end;
end
ink.runtime.Json.JArrayToRuntimeObjArray = function(jArray,skipLast)
  if (skipLast == nil) then
    skipLast = false;
  end;
  local count = jArray.length;
  if (skipLast) then
    count = count - 1;
  end;
  local list = Array.new();
  local _g1 = 0;
  local _g = count;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local jTok = jArray[i];
    local obj = ink.runtime.Json.JTokenToRuntimeObject(jTok);
    local runtimeObj = (function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.RObject)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    list:push(runtimeObj);
    end;
  do return list end;
end
ink.runtime.Json.DictionaryRuntimeObjsToJObject = function(dictionary)
  local jsonObj = _hx_e();
  local k = dictionary:keys();
  while (k:hasNext()) do
    local k1 = k:next();
    local obj = dictionary.v[k1];
    local runtimeObj = (function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.RObject)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (runtimeObj ~= nil) then
      jsonObj[k1] = ink.runtime.Json.RuntimeObjectToJToken(runtimeObj);
    end;
    end;
  do return jsonObj end;
end
ink.runtime.Json.JObjectToDictionaryRuntimeObjs = function(jObject)
  local dict = haxe.ds.StringMap.new();
  local _g = 0;
  local _g1 = Reflect.fields(jObject);
  while (_g < _g1.length) do
    local k = _g1[_g];
    _g = _g + 1;
    local value = ink.runtime.Json.JTokenToRuntimeObject(Reflect.field(jObject,k));
    dict.v[k] = value;
    dict.k[k] = true;
    end;
  do return dict end;
end
ink.runtime.Json.JObjectToIntDictionary = function(jObject)
  local dict = haxe.ds.StringMap.new();
  local _g = 0;
  local _g1 = Reflect.fields(jObject);
  while (_g < _g1.length) do
    local k = _g1[_g];
    _g = _g + 1;
    local value = Std.int(Reflect.field(jObject,k));
    dict.v[k] = value;
    dict.k[k] = true;
    end;
  do return dict end;
end
ink.runtime.Json.IntDictionaryToJObject = function(dict)
  local jObj = _hx_e();
  local k = dict:keys();
  while (k:hasNext()) do
    local k1 = k:next();
    jObj[k1] = dict.v[k1];
    end;
  do return jObj end;
end
ink.runtime.Json.JTokenToRuntimeObject = function(token)
  if (lua.Boot.__instanceof(token,Int) or lua.Boot.__instanceof(token,Float)) then
    do return ink.runtime.Value.Create(token) end;
  end;
  if (lua.Boot.__instanceof(token,String)) then
    local str = Std.string(token);
    local firstChar = str:charAt(0);
    if (firstChar == "^") then
      do return ink.runtime.StringValue.new(str:substring(1)) end;
    else
      if (((firstChar == "\n") and (str.length == 1)) or (token == "\n")) then
        do return ink.runtime.StringValue.new("\n") end;
      end;
    end;
    if (str == "<>") then
      do return ink.runtime.Glue.new(ink.runtime.GlueType.Bidirectional) end;
    else
      if (str == "G<") then
        do return ink.runtime.Glue.new(ink.runtime.GlueType.Left) end;
      else
        if (str == "G>") then
          do return ink.runtime.Glue.new(ink.runtime.GlueType.Right) end;
        end;
      end;
    end;
    local _g1 = 0;
    local _g = ink.runtime.Json._controlCommandNames.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local cmdName = ink.runtime.Json._controlCommandNames[i];
      if (str == cmdName) then
        local cmdType = i;
        do return ink.runtime.ControlCommand.createFromCommandType(i) end;
      end;
      end;
    if (ink.runtime.NativeFunctionCall.CallExistsWithName(str)) then
      do return ink.runtime.NativeFunctionCall.CallWithName(str) end;
    end;
    if (str == "->->") then
      do return ink.runtime.ControlCommand.PopTunnel() end;
    else
      if (str == "~ret") then
        do return ink.runtime.ControlCommand.PopFunction() end;
      end;
    end;
    if (str == "void") then
      do return ink.runtime.VoidObj.new() end;
    end;
    haxe.Log.trace("Failed to resolve String type!",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Json.hx",lineNumber=214,className="ink.runtime.Json",methodName="JTokenToRuntimeObject"}));
  end;
  if (lua.Boot.__instanceof(token,Array)) then
    do return ink.runtime.Json.JArrayToContainer(token) end;
  end;
  if (Type.typeof(token) == ValueType.TObject) then
    local obj = token;
    local propValue = Reflect.field(obj,"^->");
    if (propValue ~= nil) then
      do return ink.runtime.DivertTargetValue.new(ink.runtime.Path.createFromString(Std.string(propValue))) end;
    end;
    propValue = Reflect.field(obj,"^var");
    if (propValue ~= nil) then
      local varPtr = ink.runtime.VariablePointerValue.new(Std.string(propValue));
      propValue = Reflect.field(obj,"ci");
      if (propValue ~= nil) then
        varPtr.contextIndex = Std.int(propValue);
      end;
      do return varPtr end;
    end;
    local isDivert = false;
    local pushesToStack = false;
    local divPushType = 1;
    local external = false;
    propValue = Reflect.field(obj,"->");
    if (propValue ~= nil) then
      isDivert = true;
    else
      propValue = Reflect.field(obj,"f()");
      if (propValue ~= nil) then
        isDivert = true;
        pushesToStack = true;
        divPushType = 1;
      else
        propValue = Reflect.field(obj,"->t->");
        if (propValue ~= nil) then
          isDivert = true;
          pushesToStack = true;
          divPushType = 0;
        else
          propValue = Reflect.field(obj,"x()");
          if (propValue ~= nil) then
            isDivert = true;
            external = true;
            pushesToStack = false;
            divPushType = 1;
          end;
        end;
      end;
    end;
    if (isDivert) then
      local divert = ink.runtime.Divert.new();
      divert.pushesToStack = pushesToStack;
      divert.stackPushType = divPushType;
      divert.isExternal = external;
      local target = Std.string(propValue);
      propValue = Reflect.field(obj,"var");
      if (propValue ~= nil) then
        divert.variableDivertName = target;
      else
        divert:set_targetPathString(target);
      end;
      propValue = Reflect.field(obj,"c");
      divert.isConditional = propValue ~= nil;
      if (external) then
        propValue = Reflect.field(obj,"exArgs");
        if (propValue ~= nil) then
          divert.externalArgs = Std.int(propValue);
        end;
      end;
      do return divert end;
    end;
    propValue = Reflect.field(obj,"*");
    if (propValue ~= nil) then
      local choice = ink.runtime.ChoicePoint.new();
      choice:set_pathStringOnChoice(Std.string(propValue));
      propValue = Reflect.field(obj,"flg");
      if (propValue ~= nil) then
        choice:set_flags(Std.int(propValue));
      end;
      do return choice end;
    end;
    propValue = Reflect.field(obj,"VAR?");
    if (propValue ~= nil) then
      do return ink.runtime.VariableReference.create(Std.string(propValue)) end;
    else
      propValue = Reflect.field(obj,"CNT?");
      if (propValue ~= nil) then
        local readCountVarRef = ink.runtime.VariableReference.new();
        readCountVarRef:set_pathStringForCount(Std.string(propValue));
        do return readCountVarRef end;
      end;
    end;
    local isVarAss = false;
    local isGlobalVar = false;
    propValue = Reflect.field(obj,"VAR=");
    if (propValue ~= nil) then
      isVarAss = true;
      isGlobalVar = true;
    else
      propValue = Reflect.field(obj,"temp=");
      if (propValue ~= nil) then
        isVarAss = true;
        isGlobalVar = false;
      end;
    end;
    if (isVarAss) then
      local varName = Std.string(propValue);
      propValue = Reflect.field(obj,"re");
      local isNewDecl = propValue == nil;
      local varAss = ink.runtime.VariableAssignment.new(varName,isNewDecl);
      varAss.isGlobal = isGlobalVar;
      do return varAss end;
    end;
    if (Reflect.field(obj,"originalChoicePath") ~= nil) then
      do return ink.runtime.Json.JObjectToChoice(obj) end;
    end;
    haxe.Log.trace("Failed to resolve TObject type!",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Json.hx",lineNumber=334,className="ink.runtime.Json",methodName="JTokenToRuntimeObject"}));
  end;
  if (token == nil) then
    do return nil end;
  end;
  _G.error(ink.runtime.SystemException.new("Failed to convert token to runtime object: " .. Std.string(token) .. " :: " .. Std.string(Type.typeof(token))),0);
end
ink.runtime.Json.RuntimeObjectToJToken = function(obj)
  local container = (function()
    local _hx_1
    if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
    _hx_1 = obj; else
    _hx_1 = nil; end
    return _hx_1
  end )();
  if (container ~= nil) then
    do return ink.runtime.Json.ContainerToJArray(container) end;
  end;
  local divert = (function()
    local _hx_2
    if (lua.Boot.__instanceof(obj,ink.runtime.Divert)) then
    _hx_2 = obj; else
    _hx_2 = nil; end
    return _hx_2
  end )();
  if (divert ~= nil) then
    local divTypeKey = "->";
    if (divert.isExternal) then
      divTypeKey = "x()";
    else
      if (divert.pushesToStack) then
        if (divert.stackPushType == 1) then
          divTypeKey = "f()";
        else
          if (divert.stackPushType == 0) then
            divTypeKey = "->t->";
          end;
        end;
      end;
    end;
    local targetStr;
    if (divert:get_hasVariableTarget()) then
      targetStr = divert.variableDivertName;
    else
      targetStr = divert:get_targetPathString();
    end;
    local jObj = _hx_e();
    jObj[divTypeKey] = targetStr;
    if (divert:get_hasVariableTarget()) then
      jObj.var = true;
    end;
    if (divert.isConditional) then
      jObj.c = true;
    end;
    if (divert.externalArgs and divert.externalArgs > 0) then
      jObj.exArgs = divert.externalArgs;
    end;
    do return jObj end;
  end;
  local choicePoint = (function()
    local _hx_3
    if (lua.Boot.__instanceof(obj,ink.runtime.ChoicePoint)) then
    _hx_3 = obj; else
    _hx_3 = nil; end
    return _hx_3
  end )();
  if (choicePoint ~= nil) then
    local jObj1 = _hx_e();
    jObj1["*"] = choicePoint:get_pathStringOnChoice();
    jObj1.flg = choicePoint:get_flags();
    do return jObj1 end;
  end;
  local intVal = (function()
    local _hx_4
    if (lua.Boot.__instanceof(obj,ink.runtime.IntValue)) then
    _hx_4 = obj; else
    _hx_4 = nil; end
    return _hx_4
  end )();
  if (intVal ~= nil) then
    do return intVal.value end;
  end;
  local floatVal = (function()
    local _hx_5
    if (lua.Boot.__instanceof(obj,ink.runtime.FloatValue)) then
    _hx_5 = obj; else
    _hx_5 = nil; end
    return _hx_5
  end )();
  if (floatVal ~= nil) then
    do return floatVal.value end;
  end;
  local strVal = (function()
    local _hx_6
    if (lua.Boot.__instanceof(obj,ink.runtime.StringValue)) then
    _hx_6 = obj; else
    _hx_6 = nil; end
    return _hx_6
  end )();
  if (strVal ~= nil) then
    if (strVal.isNewline) then
      do return "\n" end;
    else
      do return "^" .. strVal.value end;
    end;
  end;
  local divTargetVal = (function()
    local _hx_7
    if (lua.Boot.__instanceof(obj,ink.runtime.DivertTargetValue)) then
    _hx_7 = obj; else
    _hx_7 = nil; end
    return _hx_7
  end )();
  if (divTargetVal ~= nil) then
    local divTargetJsonObj = _hx_e();
    divTargetJsonObj["^->"] = divTargetVal.value:get_componentsString();
    do return divTargetJsonObj end;
  end;
  local varPtrVal = (function()
    local _hx_8
    if (lua.Boot.__instanceof(obj,ink.runtime.VariablePointerValue)) then
    _hx_8 = obj; else
    _hx_8 = nil; end
    return _hx_8
  end )();
  if (varPtrVal ~= nil) then
    local varPtrJsonObj = _hx_e();
    varPtrJsonObj["^var"] = varPtrVal.value;
    varPtrJsonObj.ci = varPtrVal.contextIndex;
    do return varPtrJsonObj end;
  end;
  local glue = (function()
    local _hx_9
    if (lua.Boot.__instanceof(obj,ink.runtime.Glue)) then
    _hx_9 = obj; else
    _hx_9 = nil; end
    return _hx_9
  end )();
  if (glue ~= nil) then
    if (glue:get_isBi()) then
      do return "<>" end;
    else
      if (glue:get_isLeft()) then
        do return "G<" end;
      else
        do return "G>" end;
      end;
    end;
  end;
  local controlCmd = (function()
    local _hx_10
    if (lua.Boot.__instanceof(obj,ink.runtime.ControlCommand)) then
    _hx_10 = obj; else
    _hx_10 = nil; end
    return _hx_10
  end )();
  if (controlCmd ~= nil) then
    do return ink.runtime.Json._controlCommandNames[controlCmd.commandType] end;
  end;
  local nativeFunc = (function()
    local _hx_11
    if (lua.Boot.__instanceof(obj,ink.runtime.NativeFunctionCall)) then
    _hx_11 = obj; else
    _hx_11 = nil; end
    return _hx_11
  end )();
  if (nativeFunc ~= nil) then
    do return nativeFunc._name end;
  end;
  local varRef = (function()
    local _hx_12
    if (lua.Boot.__instanceof(obj,ink.runtime.VariableReference)) then
    _hx_12 = obj; else
    _hx_12 = nil; end
    return _hx_12
  end )();
  if (varRef ~= nil) then
    local jObj2 = _hx_e();
    local readCountPath = varRef:get_pathStringForCount();
    if (readCountPath ~= nil) then
      jObj2["CNT?"] = readCountPath;
    else
      jObj2["VAR?"] = varRef.name;
    end;
    do return jObj2 end;
  end;
  local varAss = (function()
    local _hx_13
    if (lua.Boot.__instanceof(obj,ink.runtime.VariableAssignment)) then
    _hx_13 = obj; else
    _hx_13 = nil; end
    return _hx_13
  end )();
  if (varAss ~= nil) then
    local key = (function()
      local _hx_14
      if (varAss.isGlobal) then
      _hx_14 = "VAR="; else
      _hx_14 = "temp="; end
      return _hx_14
    end )();
    local jObj3 = _hx_e();
    jObj3[key] = varAss.variableName;
    if (not varAss.isNewDeclaration) then
      jObj3.re = true;
    end;
    do return jObj3 end;
  end;
  local voidObj = (function()
    local _hx_15
    if (lua.Boot.__instanceof(obj,ink.runtime.VoidObj)) then
    _hx_15 = obj; else
    _hx_15 = nil; end
    return _hx_15
  end )();
  if (voidObj ~= nil) then
    do return "void" end;
  end;
  local choice = (function()
    local _hx_16
    if (lua.Boot.__instanceof(obj,ink.runtime.Choice)) then
    _hx_16 = obj; else
    _hx_16 = nil; end
    return _hx_16
  end )();
  if (choice ~= nil) then
    do return ink.runtime.Json.ChoiceToJObject(choice) end;
  end;
  _G.error(ink.runtime.SystemException.new("Failed to convert runtime object to Json token: " .. Std.string(obj)),0);
end
ink.runtime.Json.ContainerToJArray = function(container)
  local serialisables = container._content;
  local jArray = Array.new();
  local _g = 0;
  while (_g < serialisables.length) do
    local s = serialisables[_g];
    _g = _g + 1;
    jArray:push(ink.runtime.Json.RuntimeObjectToJToken(s));
    end;
  local jArray1 = jArray;
  local namedOnlyContent = container:get_namedOnlyContent();
  local countFlags = container:get_countFlags();
  if ((((namedOnlyContent ~= nil) and namedOnlyContent:iterator():hasNext()) or (countFlags > 0)) or (container.name ~= nil)) then
    local terminatingObj;
    if (namedOnlyContent ~= nil) then
      terminatingObj = ink.runtime.Json.DictionaryRuntimeObjsToJObject(namedOnlyContent);
      local _g1 = 0;
      local _g11 = Reflect.fields(terminatingObj);
      while (_g1 < _g11.length) do
        local p = _g11[_g1];
        _g1 = _g1 + 1;
        local namedContentObj = Reflect.field(terminatingObj,p);
        local obj = Reflect.field(terminatingObj,p);
        local subContainerJArray = (function()
          local _hx_1
          if (lua.Boot.__instanceof(obj,Array)) then
          _hx_1 = obj; else
          _hx_1 = nil; end
          return _hx_1
        end )();
        if (subContainerJArray ~= nil) then
          local attrJObj = subContainerJArray[subContainerJArray.length - 1];
          if (attrJObj ~= nil) then
            Reflect.deleteField(attrJObj,"#n");
            if (Reflect.fields(attrJObj).length == 0) then
              subContainerJArray[subContainerJArray.length - 1] = nil;
            end;
          end;
        end;
        end;
    else
      terminatingObj = _hx_e();
    end;
    if (countFlags > 0) then
      terminatingObj["#f"] = countFlags;
    end;
    if (container.name ~= nil) then
      terminatingObj["#n"] = container.name;
    end;
    jArray1:push(terminatingObj);
  else
    jArray1:push(nil);
  end;
  do return jArray1 end;
end
ink.runtime.Json.JArrayToContainer = function(jArray)
  local container = ink.runtime.Container.new();
  container:AddContentList(ink.runtime.Json.JArrayToRuntimeObjArray(jArray,true));
  local terminatingObj = jArray[jArray.length - 1];
  if (terminatingObj ~= nil) then
    local namedOnlyContent = haxe.ds.StringMap.new();
    local _g = 0;
    local _g1 = Reflect.fields(terminatingObj);
    while (_g < _g1.length) do
      local k = _g1[_g];
      _g = _g + 1;
      if (k == "#f") then
        container:set_countFlags(Std.int(Reflect.field(terminatingObj,k)));
      else
        if (k == "#n") then
          container.name = Std.string(Reflect.field(terminatingObj,k));
        else
          local namedContentItem = ink.runtime.Json.JTokenToRuntimeObject(Reflect.field(terminatingObj,k));
          local namedSubContainer = (function()
            local _hx_1
            if (lua.Boot.__instanceof(namedContentItem,ink.runtime.Container)) then
            _hx_1 = namedContentItem; else
            _hx_1 = nil; end
            return _hx_1
          end )();
          if (namedSubContainer ~= nil) then
            namedSubContainer.name = k;
          end;
          namedOnlyContent.v[k] = namedContentItem;
          namedOnlyContent.k[k] = true;
        end;
      end;
      end;
    container:set_namedOnlyContent(namedOnlyContent);
  end;
  do return container end;
end
ink.runtime.Json.JObjectToChoice = function(jObj)
  local choice = ink.runtime.Choice.new();
  choice.text = Std.string(Reflect.field(jObj,"text"));
  choice.index = Std.int(Reflect.field(jObj,"index"));
  choice.originalChoicePath = Std.string(Reflect.field(jObj,"originalChoicePath"));
  choice.originalThreadIndex = Std.int(Reflect.field(jObj,"originalThreadIndex"));
  do return choice end;
end
ink.runtime.Json.ChoiceToJObject = function(choice)
  local jObj = _hx_o({__fields__={text=true,index=true,originalChoicePath=true,originalThreadIndex=true},text=choice.text,index=choice.index,originalChoicePath=choice.originalChoicePath,originalThreadIndex=choice.originalThreadIndex});
  do return jObj end;
end

ink.runtime.LibUtil.new = {}
_hxClasses["ink.runtime.LibUtil"] = ink.runtime.LibUtil
ink.runtime.LibUtil.__name__ = {"ink","runtime","LibUtil"}
ink.runtime.LibUtil.validInt = function(val)
  if (val ~= nil) then
    do return not Math.isNaN(val) end;
  else
    do return false end;
  end;
end
ink.runtime.LibUtil.as = function(obj,type)
  if (lua.Boot.__instanceof(obj,type)) then
    do return obj end;
  else
    do return nil end;
  end;
end
ink.runtime.LibUtil.asNoInline = function(obj,type)
  if (lua.Boot.__instanceof(obj,type)) then
    do return obj end;
  else
    do return nil end;
  end;
end
ink.runtime.LibUtil.tryParseFloat = function(val)
  do return Std.parseFloat(val) end;
end
ink.runtime.LibUtil.tryParseInt = function(val)
  do return Std.parseInt(val) end;
end
ink.runtime.LibUtil.tryGetValue = function(map,prop)
  do return map.v[prop] end;
end
ink.runtime.LibUtil.tryGetValueINamedContent = function(map,prop)
  do return map.v[prop] end;
end
ink.runtime.LibUtil.jTokenToStringMap = function(token)
  local strMap = haxe.ds.StringMap.new();
  local _g = 0;
  local _g1 = Reflect.fields(token);
  while (_g < _g1.length) do
    local f = _g1[_g];
    _g = _g + 1;
    local value = Reflect.field(token,f);
    strMap.v[f] = value;
    strMap.k[f] = true;
    end;
  do return strMap end;
end
ink.runtime.LibUtil.cloneStrMap = function(map)
  local cMap = haxe.ds.StringMap.new();
  local c = map:keys();
  while (c:hasNext()) do
    local c1 = c:next();
    local value = map.v[c1];
    cMap.v[c1] = value;
    cMap.k[c1] = true;
    end;
  do return cMap end;
end
ink.runtime.LibUtil.cloneStrIntMap = function(map)
  local cMap = haxe.ds.StringMap.new();
  local c = map:keys();
  while (c:hasNext()) do
    local c1 = c:next();
    local value = map.v[c1];
    cMap.v[c1] = value;
    cMap.k[c1] = true;
    end;
  do return cMap end;
end
ink.runtime.LibUtil.cloneObjMap = function(map)
  local cMap = haxe.ds.ObjectMap.new();
  local c = map:keys();
  while (c:hasNext()) do
    local c1 = c:next();
    cMap.h[c1] = map.h[c1];
    cMap.k[c1] = true;
    end;
  do return cMap end;
end
ink.runtime.LibUtil.listIndexOf = function(list,obj)
  local count = 0;
  local _g_head = list.h;
  while (_g_head ~= nil) do
    local val = _g_head.item;
    _g_head = _g_head.next;
    local l = val;
    if (l == obj) then
      do return count end;
    end;
    count = count + 1;
    end;
  do return -1 end;
end
ink.runtime.LibUtil.arrayToList = function(arr)
  local list = List.new();
  local _g = 0;
  while (_g < arr.length) do
    local val = arr[_g];
    _g = _g + 1;
    list:add(val);
    end;
  do return list end;
end
ink.runtime.LibUtil.getArrayItemAtIndex = function(arr,index)
  do return arr[index] end;
end
ink.runtime.LibUtil.getListItemAtIndex = function(list,index)
  if ((index < 0) or (index >= list.length)) then
    do return nil end;
  end;
  local iter_head = list.h;
  local _g1 = 0;
  local _g = index;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local val = iter_head.item;
    iter_head = iter_head.next;
    end;
  local val1 = iter_head.item;
  iter_head = iter_head.next;
  do return val1 end;
end
ink.runtime.LibUtil.tryGetValueDynamic = function(obj,prop)
  do return Reflect.field(obj,prop) end;
end
ink.runtime.LibUtil.clearArray = function(arr)
  arr:splice(0,arr.length);
end
ink.runtime.LibUtil.arraySequenceEquals = function(arr1,arr2)
  if (arr1.length ~= arr2.length) then
    do return false end;
  end;
  local _g1 = 0;
  local _g = arr1.length;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    if (not arr1[i]:Equals(arr2[i])) then
      do return false end;
    end;
    end;
  do return true end;
end
ink.runtime.LibUtil.addRangeForList = function(list,toAdd)
  local _g_head = toAdd.h;
  while (_g_head ~= nil) do
    local val = _g_head.item;
    _g_head = _g_head.next;
    local i = val;
    list:add(i);
    end;
end
ink.runtime.LibUtil.addRangeForArray = function(list,toAdd)
  local _g1 = 0;
  local _g = toAdd.length;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    list:push(toAdd[i]);
    end;
end
ink.runtime.LibUtil.findForList = function(list,f)
  local _g_head = list.h;
  while (_g_head ~= nil) do
    local val = _g_head.item;
    _g_head = _g_head.next;
    local i = val;
    if (f(i)) then
      do return i end;
    end;
    end;
  do return nil end;
end
ink.runtime.LibUtil.minI = function(a,b)
  if (a < b) then
    do return a end;
  else
    do return b end;
  end;
end
ink.runtime.LibUtil.maxI = function(a,b)
  if (a >= b) then
    do return a end;
  else
    do return b end;
  end;
end
ink.runtime.LibUtil.minI_ = function(a,b)
  if (a < b) then
    do return a end;
  else
    do return b end;
  end;
end
ink.runtime.LibUtil.maxI_ = function(a,b)
  if (a >= b) then
    do return a end;
  else
    do return b end;
  end;
end
ink.runtime.LibUtil.removeArrayItemAtIndex = function(arr,index)
  arr:splice(index,1);
end

ink.runtime.MapCloner.new = function(cloner,type)
  local self = _hx_new(ink.runtime.MapCloner.prototype)
  ink.runtime.MapCloner.super(self,cloner,type)
  return self
end
ink.runtime.MapCloner.super = function(self,cloner,type)
  self.cloner = cloner;
  self.type = type;
  self.noArgs = _hx_tab_array({ }, 0);
end
_hxClasses["ink.runtime.MapCloner"] = ink.runtime.MapCloner
ink.runtime.MapCloner.__name__ = {"ink","runtime","MapCloner"}
ink.runtime.MapCloner.prototype = _hx_a(
  'cloner', nil,
  'type', nil,
  'noArgs', nil,
  'clone', function(self,inValue)
    local inMap = inValue;
    local map = Type.createInstance(self.type,self.noArgs);
    local key = inMap:keys();
    while (key:hasNext()) do
      local key1 = key:next();
      map:set(key1,self.cloner:_clone(inMap:get(key1)));
      end;
    do return map end
  end
  ,'__class__',  ink.runtime.MapCloner
)

ink.runtime.NativeFunctionCall.new = function()
  local self = _hx_new(ink.runtime.NativeFunctionCall.prototype)
  ink.runtime.NativeFunctionCall.super(self)
  return self
end
ink.runtime.NativeFunctionCall.super = function(self)
  ink.runtime.RObject.super(self);
  ink.runtime.NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
end
_hxClasses["ink.runtime.NativeFunctionCall"] = ink.runtime.NativeFunctionCall
ink.runtime.NativeFunctionCall.__name__ = {"ink","runtime","NativeFunctionCall"}
ink.runtime.NativeFunctionCall.CallWithName = function(functionName)
  do return ink.runtime.NativeFunctionCall.createFromName(functionName) end;
end
ink.runtime.NativeFunctionCall.CallExistsWithName = function(functionName)
  ink.runtime.NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
  local this1 = ink.runtime.NativeFunctionCall._nativeFunctions;
  do return (this1.k[functionName] or false) end;
end
ink.runtime.NativeFunctionCall.createFromName = function(name)
  local me = ink.runtime.NativeFunctionCall.new();
  me:set_name(name);
  do return me end;
end
ink.runtime.NativeFunctionCall.createFromNameAndNumParams = function(name,numberOfParamters)
  local me = ink.runtime.NativeFunctionCall.new();
  me._isPrototype = true;
  me:set_name(name);
  me:set_numberOfParameters(numberOfParamters);
  do return me end;
end
ink.runtime.NativeFunctionCall.GenerateNativeFunctionsIfNecessary = function()
  if (ink.runtime.NativeFunctionCall._nativeFunctions == nil) then
    ink.runtime.NativeFunctionCall._nativeFunctions = haxe.ds.StringMap.new();
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("+",function(x,y)
      do return x + y end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("-",function(x1,y1)
      do return x1 - y1 end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("*",function(x2,y2)
      do return x2 * y2 end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("/",function(x3,y3)
      do return Std.int(x3 / y3) end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("%",function(x4,y4)
      do return _G.math.fmod(x4, y4) end;
    end);
    ink.runtime.NativeFunctionCall.AddIntUnaryOp("~",function(x5)
      do return -x5 end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("==",function(x6,y5)
      if (x6 == y5) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp(">",function(x7,y6)
      if (x7 > y6) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("<",function(x8,y7)
      if (x8 < y7) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp(">=",function(x9,y8)
      if (x9 >= y8) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("<=",function(x10,y9)
      if (x10 <= y9) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("!=",function(x11,y10)
      if (x11 ~= y10) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntUnaryOp("!",function(x12)
      if (x12 == 0) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("&&",function(x13,y11)
      if ((x13 ~= 0) and (y11 ~= 0)) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("||",function(x14,y12)
      if ((x14 ~= 0) or (y12 ~= 0)) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("MAX",function(x15,y13)
      if (x15 >= y13) then
        do return x15 end;
      else
        do return y13 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddIntBinaryOp("MIN",function(x16,y14)
      if (x16 < y14) then
        do return x16 end;
      else
        do return y14 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("+",function(x17,y15)
      do return x17 + y15 end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("-",function(x18,y16)
      do return x18 - y16 end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("*",function(x19,y17)
      do return x19 * y17 end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("/",function(x20,y18)
      do return x20 / y18 end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("%",function(x21,y19)
      do return _G.math.fmod(x21, y19) end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatUnaryOp("~",function(x22)
      do return -x22 end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("==",function(x23,y20)
      if (x23 == y20) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp(">",function(x24,y21)
      if (x24 > y21) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("<",function(x25,y22)
      if (x25 < y22) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp(">=",function(x26,y23)
      if (x26 >= y23) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("<=",function(x27,y24)
      if (x27 <= y24) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("!=",function(x28,y25)
      if (x28 ~= y25) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatUnaryOp("!",function(x29)
      if (x29 == 0.0) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("&&",function(x30,y26)
      if ((x30 ~= 0.0) and (y26 ~= 0.0)) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("||",function(x31,y27)
      if ((x31 ~= 0.0) or (y27 ~= 0.0)) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("MAX",function(x32,y28)
      if (Math.isNaN(x32) or Math.isNaN(y28)) then
        do return (0/0) end;
      else
        do return _G.math.max(x32,y28) end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddFloatBinaryOp("MIN",function(x33,y29)
      if (Math.isNaN(x33) or Math.isNaN(y29)) then
        do return (0/0) end;
      else
        do return _G.math.min(x33,y29) end;
      end;
    end);
    ink.runtime.NativeFunctionCall.AddStringBinaryOpConcat("+",function(x34,y30)
      do return x34 .. y30 end;
    end);
    ink.runtime.NativeFunctionCall.AddStringBinaryOp("==",function(x35,y31)
      if (x35 == y31) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end);
    local divertTargetsEqual = function(d1,d2)
      if (d1:Equals(d2)) then
        do return 1 end;
      else
        do return 0 end;
      end;
    end;
    ink.runtime.NativeFunctionCall.AddOpToNativeFunc("==",2,3,divertTargetsEqual);
  end;
end
ink.runtime.NativeFunctionCall.AddOpToNativeFunc = function(name,args,valType,op)
  local nativeFunc = nil;
  local this1 = ink.runtime.NativeFunctionCall._nativeFunctions;
  nativeFunc = this1.v[name];
  if (nativeFunc == nil) then
    nativeFunc = ink.runtime.NativeFunctionCall.createFromNameAndNumParams(name,args);
    local _this = ink.runtime.NativeFunctionCall._nativeFunctions;
    _this.v[name] = nativeFunc;
    _this.k[name] = true;
  end;
  nativeFunc:AddOpFuncForType(valType,op);
end
ink.runtime.NativeFunctionCall.AddIntBinaryOp = function(name,op)
  ink.runtime.NativeFunctionCall.AddOpToNativeFunc(name,2,0,op);
end
ink.runtime.NativeFunctionCall.AddIntUnaryOp = function(name,op)
  ink.runtime.NativeFunctionCall.AddOpToNativeFunc(name,1,0,op);
end
ink.runtime.NativeFunctionCall.AddFloatBinaryOp = function(name,op)
  ink.runtime.NativeFunctionCall.AddOpToNativeFunc(name,2,1,op);
end
ink.runtime.NativeFunctionCall.AddStringBinaryOp = function(name,op)
  ink.runtime.NativeFunctionCall.AddOpToNativeFunc(name,2,2,op);
end
ink.runtime.NativeFunctionCall.AddStringBinaryOpConcat = function(name,op)
  ink.runtime.NativeFunctionCall.AddOpToNativeFunc(name,2,2,op);
end
ink.runtime.NativeFunctionCall.AddFloatUnaryOp = function(name,op)
  ink.runtime.NativeFunctionCall.AddOpToNativeFunc(name,1,1,op);
end
ink.runtime.NativeFunctionCall._nativeFunctions = nil
ink.runtime.NativeFunctionCall.prototype = _hx_a(
  'get_name', function(self)
    do return self._name end
  end,
  'set_name', function(self,value)
    self._name = value;
    if (not self._isPrototype) then
      local this1 = ink.runtime.NativeFunctionCall._nativeFunctions;
      local key = self._name;
      self._prototype = this1.v[key];
    end;
    do return self._name end
  end,
  '_name', nil,
  'get_numberOfParameters', function(self)
    if (self._prototype ~= nil) then
      do return self._prototype:get_numberOfParameters() end;
    else
      do return self._numberOfParameters end;
    end;
  end,
  'set_numberOfParameters', function(self,value)
    self._numberOfParameters = value do return self._numberOfParameters end
  end,
  '_numberOfParameters', nil,
  'Call', function(self,parameters)
    if (self._prototype ~= nil) then
      do return self._prototype:Call(parameters) end;
    end;
    if (self:get_numberOfParameters() ~= parameters.length) then
      _G.error(ink.runtime.SystemException.new("Unexpected number of parameters"),0);
    end;
    local _g_head = parameters.h;
    while (_g_head ~= nil) do
      local val = _g_head.item;
      _g_head = _g_head.next;
      local p = val;
      if (lua.Boot.__instanceof(p,ink.runtime.VoidObj)) then
        _G.error(ink.runtime.StoryException.new("Attempting to perform operation on a void value. Did you forget to 'return' a value from a function you called here?"),0);
      end;
      end;
    local coercedParams = self:CoerceValuesToSingleType(parameters);
    local coercedType = coercedParams:first():get_valueType();
    if (coercedType == 0) then
      do return self:CallParamList(coercedParams) end;
    else
      if (coercedType == 1) then
        do return self:CallParamList(coercedParams) end;
      else
        if (coercedType == 2) then
          do return self:CallParamList(coercedParams) end;
        else
          if (coercedType == 3) then
            do return self:CallParamList(coercedParams) end;
          end;
        end;
      end;
    end;
    do return nil end
  end,
  'CallParamList', function(self,parametersOfSingleType)
    local param1 = parametersOfSingleType:first();
    local valType = param1:get_valueType();
    local val1 = param1;
    local paramCount = parametersOfSingleType.length;
    if ((paramCount == 2) or (paramCount == 1)) then
      local opForTypeObj = nil;
      opForTypeObj = self._operationFuncs.h[valType];
      if (opForTypeObj == nil) then
        _G.error(ink.runtime.StoryException.new("Can not perform operation '" .. self._name .. "' on " .. valType),0);
      end;
      if (paramCount == 2) then
        local iter_head = parametersOfSingleType.h;
        local val = iter_head.item;
        iter_head = iter_head.next;
        local val2 = iter_head.item;
        iter_head = iter_head.next;
        local param2 = val2;
        local val21 = param2;
        local opForType = opForTypeObj;
        local resultVal = opForType(val1.value,val21.value);
        do return ink.runtime.Value.Create(resultVal) end;
      else
        local opForType1 = opForTypeObj;
        local resultVal1 = opForType1(val1.value);
        do return ink.runtime.Value.Create(resultVal1) end;
      end;
    else
      _G.error(ink.runtime.SystemException.new("Unexpected number of parameters to NativeFunctionCall: " .. parametersOfSingleType.length),0);
    end;
  end,
  'CoerceValuesToSingleType', function(self,parametersIn)
    local valType = 0;
    local valTypeInt = valType;
    local _g_head = parametersIn.h;
    while (_g_head ~= nil) do
      local val = _g_head.item;
      _g_head = _g_head.next;
      local obj = val;
      local val1 = obj;
      local valValueType = val1:get_valueType();
      if (valValueType > valTypeInt) then
        valType = val1:get_valueType();
      end;
      end;
    local parametersOut = List.new();
    local _g_head1 = parametersIn.h;
    while (_g_head1 ~= nil) do
      local val2 = _g_head1.item;
      _g_head1 = _g_head1.next;
      local v = val2;
      local val3 = v;
      local castedValue = val3:Cast(valType);
      parametersOut:add(castedValue);
      end;
    do return parametersOut end
  end,
  '_setupNameAndNumParams', function(self,name,numberOfParamters)
    self._isPrototype = true;
    self:set_name(name);
    self:set_numberOfParameters(numberOfParamters);
  end,
  'AddOpFuncForType', function(self,valType,op)
    if (self._operationFuncs == nil) then
      self._operationFuncs = haxe.ds.IntMap.new();
    end;
    self._operationFuncs.h[valType] = op;
  end,
  'toString', function(self)
    do return "Native '" .. self._name .. "'" end
  end,
  '_prototype', nil,
  '_isPrototype', nil,
  '_operationFuncs', nil
  ,'__class__',  ink.runtime.NativeFunctionCall,
  '__properties__',  {set_numberOfParameters="set_numberOfParameters",get_numberOfParameters="get_numberOfParameters",set_name="set_name",get_name="get_name"}
)
ink.runtime.NativeFunctionCall.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.NativeFunctionCall.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.NativeFunctionCall.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.Path.new = function()
  local self = _hx_new(ink.runtime.Path.prototype)
  ink.runtime.Path.super(self)
  return self
end
ink.runtime.Path.super = function(self)
  ink.runtime.RObject.super(self);
  self.components = Array.new();
end
_hxClasses["ink.runtime.Path"] = ink.runtime.Path
ink.runtime.Path.__name__ = {"ink","runtime","Path"}
ink.runtime.Path.__interfaces__ = {ink.runtime.IEquatable}
ink.runtime.Path.__properties__ = {get_self="get_self"}
ink.runtime.Path.createFromHeadAndTail = function(head,tail)
  local me = ink.runtime.Path.new();
  me.components:push(head);
  ink.runtime.LibUtil.addRangeForArray(me.components,tail.components);
  do return me end;
end
ink.runtime.Path.createFromComponents = function(components,relative)
  if (relative == nil) then
    relative = false;
  end;
  local me = ink.runtime.Path.new();
  ink.runtime.LibUtil.addRangeForArray(me.components,components);
  me.isRelative = relative;
  do return me end;
end
ink.runtime.Path.createFromComponentStack = function(components,relative)
  if (relative == nil) then
    relative = false;
  end;
  local me = ink.runtime.Path.new();
  local c = components:iterator();
  while (c:hasNext()) do
    local c1 = c:next();
    me.components:push(c1);
    end;
  me.isRelative = relative;
  do return me end;
end
ink.runtime.Path.createFromString = function(componentsString)
  local me = ink.runtime.Path.new();
  me:set_componentsString(componentsString);
  do return me end;
end
ink.runtime.Path["self"] = nil
ink.runtime.Path.get_self = function()
  local path = ink.runtime.Path.new();
  path.isRelative = true;
  do return path end;
end
ink.runtime.Path.prototype = _hx_a(
  'PathByAppendingPath', function(self,pathToAppend)
    local p = ink.runtime.Path.new();
    local upwardMoves = 0;
    local _g1 = 0;
    local _g = pathToAppend.components.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (pathToAppend.components[i]:get_isParent()) then
        upwardMoves = upwardMoves + 1;
      else
        break;
      end;
      end;
    local _g11 = 0;
    local _g2 = self.components.length - upwardMoves;
    while (_g11 < _g2) do
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      p.components:push(self.components[i1]);
      end;
    local _g12 = upwardMoves;
    local _g3 = pathToAppend.components.length;
    while (_g12 < _g3) do
      _g12 = _g12 + 1;
      local i2 = _g12 - 1;
      p.components:push(pathToAppend.components[i2]);
      end;
    do return p end
  end,
  'components', nil,
  'isRelative', nil,
  'head', nil,
  'get_head', function(self)
    if (self.components.length > 0) then
      do return self.components[0] end;
    else
      do return nil end;
    end;
  end,
  'tail', nil,
  'get_tail', function(self)
    if (self.components.length >= 2) then
      local tailComps = self.components:slice(1,self.components.length);
      do return ink.runtime.Path.createFromComponents(tailComps) end;
    else
      do return ink.runtime.Path.get_self() end;
    end;
  end,
  'length', nil,
  'get_length', function(self)
    do return self.components.length end
  end,
  'lastComponent', nil,
  'get_lastComponent', function(self)
    if (self.components.length > 0) then
      do return self.components[self.components.length - 1] end;
    else
      do return nil end;
    end;
  end,
  'containsNamedComponent', nil,
  'get_containsNamedComponent', function(self)
    local _g = 0;
    local _g1 = self.components;
    while (_g < _g1.length) do
      local comp = _g1[_g];
      _g = _g + 1;
      if (not comp:get_isIndex()) then
        do return true end;
      end;
      end;
    do return false end
  end,
  'get_componentsString', function(self)
    local compsStr = self.components:join(".");
    if (self.isRelative) then
      do return "." .. compsStr end;
    else
      do return compsStr end;
    end;
  end,
  'set_componentsString', function(self,value)
    local arr = self.components;
    arr:splice(0,arr.length);
    local componentsStr = value;
    if ((componentsStr == "") or (componentsStr == nil)) then
      do return value end;
    end;
    if (componentsStr:charAt(0) == ".") then
      self.isRelative = true;
      componentsStr = componentsStr:substring(1);
    else
      self.isRelative = false;
    end;
    local componentStrings = componentsStr:split(".");
    local _g = 0;
    while (_g < componentStrings.length) do
      local str = componentStrings[_g];
      _g = _g + 1;
      local index = Std.parseInt(str);
      if ((index ~= nil) and not Math.isNaN(index)) then
        self.components:push(ink.runtime.Component.createFromIndex(index));
      else
        self.components:push(ink.runtime.Component.createFromName(str));
      end;
      end;
    do return value end
  end,
  'toString', function(self)
    do return self:get_componentsString() end
  end,
  'Equals', function(self,obj)
    do return self:EqualsPath((function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.Path)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )()) end
  end,
  'EqualsPath', function(self,otherPath)
    if (otherPath == nil) then
      do return false end;
    end;
    if (otherPath.components.length ~= self.components.length) then
      do return false end;
    end;
    if (otherPath.isRelative ~= self.isRelative) then
      do return false end;
    end;
    do return ink.runtime.LibUtil.arraySequenceEquals(otherPath.components,self.components) end
  end
  ,'__class__',  ink.runtime.Path,
  '__properties__',  {set_componentsString="set_componentsString",get_componentsString="get_componentsString",get_containsNamedComponent="get_containsNamedComponent",get_lastComponent="get_lastComponent",get_length="get_length",get_tail="get_tail",get_head="get_head"}
)
ink.runtime.Path.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.Path.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.Path.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.Component.new = function()
  local self = _hx_new(ink.runtime.Component.prototype)
  ink.runtime.Component.super(self)
  return self
end
ink.runtime.Component.super = function(self)
end
_hxClasses["ink.runtime.Component"] = ink.runtime.Component
ink.runtime.Component.__name__ = {"ink","runtime","Component"}
ink.runtime.Component.__interfaces__ = {ink.runtime.IEquatable}
ink.runtime.Component.createFromIndex = function(index)
  local me = ink.runtime.Component.new();
  if (index < 0) then
    _G.error("assertion failed index >=0",0);
  end;
  me.index = index;
  me.name = nil;
  do return me end;
end
ink.runtime.Component.createFromName = function(name)
  local me = ink.runtime.Component.new();
  if (not ((name ~= nil) and (name.length > 0))) then
    _G.error("assertion failed:name != null && name.Length > 0",0);
  end;
  me.name = name;
  me.index = -1;
  do return me end;
end
ink.runtime.Component.ToParent = function()
  do return ink.runtime.Component.createFromName(ink.runtime.Path.parentId) end;
end
ink.runtime.Component.prototype = _hx_a(
  'index', nil,
  'name', nil,
  'isIndex', nil,
  'get_isIndex', function(self)
    do return self.index >= 0 end
  end,
  'isParent', nil,
  'get_isParent', function(self)
    do return self.name == ink.runtime.Path.parentId end
  end,
  'toString', function(self)
    if (self:get_isIndex()) then
      do return Std.string(self.index) end;
    else
      do return self.name end;
    end;
  end,
  'Equals', function(self,obj)
    do return self:EqualsComponent((function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.Component)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )()) end
  end,
  'EqualsComponent', function(self,otherComp)
    if ((otherComp ~= nil) and (otherComp:get_isIndex() == self:get_isIndex())) then
      if (self:get_isIndex()) then
        do return self.index == otherComp.index end;
      else
        do return self.name == otherComp.name end;
      end;
    end;
    do return false end
  end
  ,'__class__',  ink.runtime.Component,
  '__properties__',  {get_isParent="get_isParent",get_isIndex="get_isIndex"}
)

ink.runtime.Story.new = function(jsonString)
  local self = _hx_new(ink.runtime.Story.prototype)
  ink.runtime.Story.super(self,jsonString)
  return self
end
ink.runtime.Story.super = function(self,jsonString)
  ink.runtime.RObject.super(self);
  self._mainContentContainer = nil;
  self._externals = haxe.ds.StringMap.new();
  local rootObject = haxe.Json.parse(jsonString);
  local versionObj = Reflect.field(rootObject,"inkVersion");
  if (versionObj == nil) then
    _G.error(ink.runtime.SystemException.new("ink version number not found. Are you sure it's a valid .ink.json file?"),0);
  end;
  local formatFromFile = Std.int(versionObj);
  if (formatFromFile > 12) then
    _G.error(ink.runtime.SystemException.new("Version of ink used to build story was newer than the current verison of the engine"),0);
  else
    if (formatFromFile < 12) then
      _G.error(ink.runtime.SystemException.new("Version of ink used to build story is too old to be loaded by this verison of the engine"),0);
    else
      if (formatFromFile ~= 12) then
        haxe.Log.trace("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Story.hx",lineNumber=108,className="ink.runtime.Story",methodName="new"}));
      end;
    end;
  end;
  local rootToken = Reflect.field(rootObject,"root");
  if (rootToken == nil) then
    _G.error(ink.runtime.SystemException.new("Root node for ink not found. Are you sure it's a valid .ink.json file?"),0);
  end;
  local obj = ink.runtime.Json.JTokenToRuntimeObject(rootToken);
  self._mainContentContainer = (function()
    local _hx_1
    if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
    _hx_1 = obj; else
    _hx_1 = nil; end
    return _hx_1
  end )();
  self:ResetState();
end
_hx_exports["ink"]["runtime"]["Story"] = ink.runtime.Story
_hxClasses["ink.runtime.Story"] = ink.runtime.Story
ink.runtime.Story.__name__ = {"ink","runtime","Story"}
ink.runtime.Story.createFromContainer = function(contentContainer)
  local me = Type.createEmptyInstance(ink.runtime.Story);
  me._mainContentContainer = contentContainer;
  me._externals = haxe.ds.StringMap.new();
  do return me end;
end
ink.runtime.Story.prototype = _hx_a(
  'currentChoices', nil,
  'get_currentChoices', function(self)
    local choices = Array.new();
    local _g_head = self._state.currentChoices.h;
    while (_g_head ~= nil) do
      local val = _g_head.item;
      _g_head = _g_head.next;
      local c = val;
      if (not c.choicePoint.isInvisibleDefault) then
        c.index = choices.length;
        choices:push(c);
      end;
      end;
    do return choices end
  end,
  'currentText', nil,
  'get_currentText', function(self)
    do return self._state:get_currentText() end
  end,
  'currentErrors', nil,
  'get_currentErrors', function(self)
    do return self._state.currentErrors end
  end,
  'hasErrorThrow', nil,
  'get_hasErrorThrow', function(self)
    do return self._state:get_hasError() end
  end,
  'variablesState', nil,
  'get_variablesState', function(self)
    do return self._state.variablesState end
  end,
  'state', nil,
  'get_state', function(self)
    do return self._state end
  end,
  '_state', nil,
  'setupFromContainer', function(self,contentContainer)
    self._mainContentContainer = contentContainer;
    self._externals = haxe.ds.StringMap.new();
  end,
  'ToJsonString', function(self)
    local rootContainerJsonList = ink.runtime.Json.RuntimeObjectToJToken(self._mainContentContainer);
    do return haxe.Json.stringify(_hx_o({__fields__={inkVersion=true,root=true},inkVersion=12,root=rootContainerJsonList})) end
  end,
  'ResetState', function(self)
    self._state = ink.runtime.StoryState.new(self);
    self._state.variablesState:ObserveVariableChange(_hx_bind(self,self.VariableStateDidChangeEvent));
    self:ResetGlobals();
  end,
  'ResetErrors', function(self)
    self._state:ResetErrors();
  end,
  'ResetCallstack', function(self)
    self._state:ForceEndFlow();
  end,
  'ResetGlobals', function(self)
    local this1 = self._mainContentContainer.namedContent;
    if ((this1.k["global decl"] or false)) then
      local originalPath = self._state:get_currentPath();
      self:ChoosePathString("global decl");
      self:ContinueInternal();
      self._state:set_currentPath(originalPath);
    end;
  end,
  'BuildStringOfHierarchy', function(self)
    local sb = StringBuf.new();
    self:get_mainContentContainer():BuildStringOfHierarchy(sb,0,self._state:get_currentContentObject());
    do return _G.table.concat(sb.b) end
  end,
  'NextContent', function(self)
    self._state:set_previousContentObject(self._state:get_currentContentObject());
    if (self._state.divertedTargetObject ~= nil) then
      self._state:set_currentContentObject(self._state.divertedTargetObject);
      self._state.divertedTargetObject = nil;
      self:VisitChangedContainersDueToDivert();
      if (self._state:get_currentContentObject() ~= nil) then
        do return end;
      end;
    end;
    local successfulPointerIncrement = self:IncrementContentPointer();
    if (not successfulPointerIncrement) then
      local didPop = false;
      if (self._state.callStack:CanPop(1)) then
        self._state.callStack:Pop(1);
        if (self._state:get_inExpressionEvaluation()) then
          self._state:PushEvaluationStack(ink.runtime.VoidObj.new());
        end;
        didPop = true;
      else
        if (self._state.callStack:get_canPopThread()) then
          self._state.callStack:PopThread();
          didPop = true;
        end;
      end;
      if (didPop and (self._state:get_currentContentObject() ~= nil)) then
        self:NextContent();
      end;
    end;
  end,
  'IncrementContentPointer', function(self)
    local successfulIncrement = true;
    local currEl = self._state.callStack:get_currentElement();
    currEl.currentContentIndex = currEl.currentContentIndex + 1;
    while (currEl.currentContentIndex >= currEl.currentContainer._content.length) do
      successfulIncrement = false;
      local obj = currEl.currentContainer.parent;
      local nextAncestor = (function()
        local _hx_1
        if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
        _hx_1 = obj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if (nextAncestor == nil) then
        break;
      end;
      local indexInAncestor = nextAncestor._content:indexOf(currEl.currentContainer);
      if (indexInAncestor == -1) then
        break;
      end;
      currEl.currentContainer = nextAncestor;
      currEl.currentContentIndex = indexInAncestor + 1;
      successfulIncrement = true;
      end;
    if (not successfulIncrement) then
      currEl.currentContainer = nil;
    end;
    do return successfulIncrement end
  end,
  'TryFollowDefaultInvisibleChoice', function(self)
    local allChoices = self._state.currentChoices;
    local invisibleChoices = allChoices:filter(function(c)
      do return c.choicePoint.isInvisibleDefault end;
    end);
    if ((invisibleChoices.length == 0) or (allChoices.length > invisibleChoices.length)) then
      do return false end;
    end;
    local choice = invisibleChoices:first();
    self:ChoosePath(choice.choicePoint:get_choiceTarget():get_path());
    do return true end
  end,
  'VisitCountForContainer', function(self,container)
    if (not container.visitsShouldBeCounted) then
      self:ErrorThrow("Read count for target (" .. container.name .. " - on " .. Std.string(container:get_debugMetadata()) .. ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
      do return 0 end;
    end;
    local count = 0;
    local containerPathStr = container:get_path():toString();
    local this1 = self._state.visitCounts;
    local tryCount = this1.v[containerPathStr];
    if ((tryCount ~= nil) and not Math.isNaN(tryCount)) then
      count = tryCount;
    end;
    do return count end
  end,
  'IncrementVisitCountForContainer', function(self,container)
    local count = 0;
    local containerPathStr = container:get_path():toString();
    local this1 = self._state.visitCounts;
    local tryCount = this1.v[containerPathStr];
    if ((tryCount ~= nil) and not Math.isNaN(tryCount)) then
      count = tryCount;
    end;
    count = count + 1;
    local _this = self._state.visitCounts;
    _this.v[containerPathStr] = count;
    _this.k[containerPathStr] = true;
  end,
  'RecordTurnIndexVisitToContainer', function(self,container)
    local containerPathStr = container:get_path():toString();
    local value = self._state.currentTurnIndex;
    local _this = self._state.turnIndices;
    _this.v[containerPathStr] = value;
    _this.k[containerPathStr] = true;
  end,
  'TurnsSinceForContainer', function(self,container)
    if (not container.turnIndexShouldBeCounted) then
      self:ErrorThrow("TURNS_SINCE() for target (" .. container.name .. " - on " .. Std.string(container:get_debugMetadata()) .. ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
    end;
    local containerPathStr = container:get_path():toString();
    local this1 = self._state.turnIndices;
    local index = this1.v[containerPathStr];
    if ((index ~= nil) and not Math.isNaN(index)) then
      do return self._state.currentTurnIndex - index end;
    else
      do return -1 end;
    end;
  end,
  'NextSequenceShuffleIndex', function(self)
    local obj = self._state:PopEvaluationStack();
    local numElementsIntVal = (function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.IntValue)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (numElementsIntVal == nil) then
      self:ErrorThrow("expected number of elements in sequence for shuffle index");
      do return 0 end;
    end;
    local seqContainer = self._state:get_currentContainer();
    local numElements = numElementsIntVal.value;
    local obj1 = self._state:PopEvaluationStack();
    local seqCountVal = (function()
      local _hx_2
      if (lua.Boot.__instanceof(obj1,ink.runtime.IntValue)) then
      _hx_2 = obj1; else
      _hx_2 = nil; end
      return _hx_2
    end )();
    local seqCount = seqCountVal.value;
    local loopIndex = Std.int(seqCount / numElements);
    local iterationIndex = _G.math.fmod(seqCount, numElements);
    local seqPathStr = seqContainer:get_path():toString();
    local sequenceHash = 0;
    local _g1 = 0;
    local _g = seqPathStr.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      sequenceHash = sequenceHash + _G.string.byte(seqPathStr,i + 1);
      end;
    local randomSeed = (sequenceHash + loopIndex) + self._state.storySeed;
    local random = ink.random.ParkMiller.new(randomSeed);
    local unpickedIndices = Array.new();
    local _g11 = 0;
    local _g2 = numElements;
    while (_g11 < _g2) do
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      unpickedIndices:push(i1);
      end;
    local _g12 = 0;
    local _g3 = iterationIndex + 1;
    while (_g12 < _g3) do
      _g12 = _g12 + 1;
      local i2 = _g12 - 1;
      local l = -0.4999;
      local h = (unpickedIndices.length - 1) + .4999;
      local chosen = _G.math.floor((l + ((h - l) * random:randomFloat())) + 0.5);
      local chosenIndex = unpickedIndices[chosen];
      unpickedIndices:splice(chosen,1);
      if (i2 == iterationIndex) then
        do return chosenIndex end;
      end;
      end;
    _G.error(ink.runtime.SystemException.new("Should never reach here"),0);
  end,
  'ErrorThrow', function(self,message,useEndLineNumber)
    if (useEndLineNumber == nil) then
      useEndLineNumber = false;
    end;
    local e = ink.runtime.StoryException.new(message);
    e.useEndLineNumber = useEndLineNumber;
    _G.error(e,0);
  end,
  'AddErrorThrow', function(self,message,useEndLineNumber)
    local dm = self:get_currentDebugMetadata();
    if (dm ~= nil) then
      local lineNum = (function()
        local _hx_1
        if (useEndLineNumber) then
        _hx_1 = dm.endLineNumber; else
        _hx_1 = dm.startLineNumber; end
        return _hx_1
      end )();
      message = "RUNTIME ERROR: '" .. dm.fileName .. "' line " .. lineNum .. ": " .. message;
    else
      message = "RUNTIME ERROR: " .. message;
    end;
    self._state:AddError(message);
    self._state:ForceEndFlow();
  end,
  'currentDebugMetadata', nil,
  'get_currentDebugMetadata', function(self)
    local dm;
    local currentContent = self._state:get_currentContentObject();
    if (currentContent ~= nil) then
      dm = currentContent:get_debugMetadata();
      if (dm ~= nil) then
        do return dm end;
      end;
    end;
    local i = self._state.callStack:get_elements().length - 1;
    while (i >= 0) do
      local currentObj = self._state.callStack:get_elements()[i]:get_currentObject();
      if ((currentObj ~= nil) and (currentObj:get_debugMetadata() ~= nil)) then
        do return currentObj:get_debugMetadata() end;
      end;
      i = i - 1;
      end;
    i = self._state:get_outputStream().length - 1;
    while (i >= 0) do
      local outputObj = self._state:get_outputStream()[i];
      dm = outputObj:get_debugMetadata();
      if (dm ~= nil) then
        do return dm end;
      end;
      i = i - 1;
      end;
    do return nil end
  end,
  'VariableStateDidChangeEvent', function(self,variableName,newValueObj)
    if (self._variableObservers == nil) then
      do return end;
    end;
    local observers = nil;
    local this1 = self._variableObservers;
    observers = this1.v[variableName];
    if (observers ~= nil) then
      if (not lua.Boot.__instanceof(newValueObj,ink.runtime.Value)) then
        _G.error(ink.runtime.SystemException.new("Tried to get the value of a variable that isn't a standard type"),0);
      end;
      local val = (function()
        local _hx_1
        if (lua.Boot.__instanceof(newValueObj,ink.runtime.Value)) then
        _hx_1 = newValueObj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      observers(variableName,val:get_valueObject());
    end;
  end,
  'Continue', function(self)
    if (not self._hasValidatedExternals) then
      self:ValidateExternalBindings();
    end;
    do return self:ContinueInternal() end
  end,
  'ContinueInternal', function(self)
    if (not self:get_canContinue()) then
      _G.error(ink.runtime.StoryException.new("Can't continue - should check canContinue before calling Continue"),0);
    end;
    self._state:ResetOutput();
    self._state.didSafeExit = false;
    self._state.variablesState:set_batchObservingVariableChanges(true);
    local stateAtLastNewline = nil;
    local count = 0;
    while (true) do
      count = count + 1;
      if ((count - 1) > 99999) then
        _G.error("Count iteration limit reached",0);
      end;
      self:Step();
      if (not self:get_canContinue()) then
        self:TryFollowDefaultInvisibleChoice();
      end;
      if (not self._state:get_inStringEvaluation()) then
        if (stateAtLastNewline ~= nil) then
          local currText = self:get_currentText();
          local prevTextLength = stateAtLastNewline:get_currentText().length;
          if (currText ~= stateAtLastNewline:get_currentText()) then
            if ((currText.length >= prevTextLength) and (currText:charAt(prevTextLength - 1) == "\n")) then
              self:RestoreStateSnapshot(stateAtLastNewline);
              break;
            else
              stateAtLastNewline = nil;
            end;
          end;
        end;
        if (self._state:get_outputStreamEndsInNewline()) then
          if (self:get_canContinue()) then
            stateAtLastNewline = self:StateSnapshot();
          else
            stateAtLastNewline = nil;
          end;
        end;
      end;
      if (not self:get_canContinue()) then
        break;
      end;
      end;
    if (stateAtLastNewline ~= nil) then
      self:RestoreStateSnapshot(stateAtLastNewline);
    end;
    if (not self:get_canContinue()) then
      if (self._state.callStack:get_canPopThread()) then
        self:ErrorThrow("Thread available to pop, threads should always be flat by the end of evaluation?");
      end;
      if (((self:get_currentChoices().length == 0) and not self._state.didSafeExit) and (self._temporaryEvaluationContainer == nil)) then
        if (self._state.callStack:CanPop(0)) then
          self:ErrorThrow("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?");
        else
          if (self._state.callStack:CanPop(1)) then
            self:ErrorThrow("unexpectedly reached end of content. Do you need a '~ return'?");
          else
            if (not self._state.callStack:get_canPop()) then
              self:ErrorThrow("ran out of content. Do you need a '-> DONE' or '-> END'?");
            else
              self:ErrorThrow("unexpectedly reached end of content for unknown reason. Please debug compiler!");
            end;
          end;
        end;
      end;
    end;
    self._state.didSafeExit = false;
    self._state.variablesState:set_batchObservingVariableChanges(false);
    do return self:get_currentText() end
  end,
  'canContinue', nil,
  'get_canContinue', function(self)
    if (self._state:get_currentContentObject() ~= nil) then
      do return not self._state:get_hasError() end;
    else
      do return false end;
    end;
  end,
  'ContinueMaximally', function(self)
    local sb_length;
    local sb_b = _hx_e();
    sb_length = 0;
    while (self:get_canContinue()) do
      local str = Std.string(self:Continue());
      _G.table.insert(sb_b,str);
      sb_length = sb_length + str.length;
      end;
    do return _G.table.concat(sb_b) end
  end,
  'ContentAtPath', function(self,path)
    do return self:get_mainContentContainer():ContentAtPath(path) end
  end,
  'StateSnapshot', function(self)
    do return self._state:Copy() end
  end,
  'RestoreStateSnapshot', function(self,state)
    self._state = state;
  end,
  'Step', function(self)
    local shouldAddToStream = true;
    local currentContentObj = self._state:get_currentContentObject();
    if (currentContentObj == nil) then
      do return end;
    end;
    local currentContainer = (function()
      local _hx_1
      if (lua.Boot.__instanceof(currentContentObj,ink.runtime.Container)) then
      _hx_1 = currentContentObj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    while (currentContainer ~= nil) do
      self:VisitContainer(currentContainer,true);
      if (currentContainer._content.length == 0) then
        break;
      end;
      currentContentObj = currentContainer._content[0];
      self._state.callStack:get_currentElement().currentContentIndex = 0;
      self._state.callStack:get_currentElement().currentContainer = currentContainer;
      currentContainer = (function()
        local _hx_2
        if (lua.Boot.__instanceof(currentContentObj,ink.runtime.Container)) then
        _hx_2 = currentContentObj; else
        _hx_2 = nil; end
        return _hx_2
      end )();
      end;
    currentContainer = self._state.callStack:get_currentElement().currentContainer;
    local isLogicOrFlowControl = self:PerformLogicAndFlowControl(currentContentObj);
    if (self._state:get_currentContentObject() == nil) then
      do return end;
    end;
    if (isLogicOrFlowControl) then
      shouldAddToStream = false;
    end;
    local choicePoint = (function()
      local _hx_3
      if (lua.Boot.__instanceof(currentContentObj,ink.runtime.ChoicePoint)) then
      _hx_3 = currentContentObj; else
      _hx_3 = nil; end
      return _hx_3
    end )();
    if (choicePoint ~= nil) then
      local choice = self:ProcessChoice(choicePoint);
      if (choice ~= nil) then
        self._state.currentChoices:add(choice);
      end;
      currentContentObj = nil;
      shouldAddToStream = false;
    end;
    if (lua.Boot.__instanceof(currentContentObj,ink.runtime.Container)) then
      shouldAddToStream = false;
    end;
    if (shouldAddToStream) then
      local varPointer = (function()
        local _hx_4
        if (lua.Boot.__instanceof(currentContentObj,ink.runtime.VariablePointerValue)) then
        _hx_4 = currentContentObj; else
        _hx_4 = nil; end
        return _hx_4
      end )();
      if ((varPointer ~= nil) and (varPointer.contextIndex == -1)) then
        local contextIdx = self._state.callStack:ContextForVariableNamed(varPointer:get_variableName());
        currentContentObj = ink.runtime.VariablePointerValue.new(varPointer:get_variableName(),contextIdx);
      end;
      if (self._state:get_inExpressionEvaluation()) then
        self._state:PushEvaluationStack(currentContentObj);
      else
        self._state:PushToOutputStream(currentContentObj);
      end;
    end;
    self:NextContent();
    local controlCmd = (function()
      local _hx_5
      if (lua.Boot.__instanceof(currentContentObj,ink.runtime.ControlCommand)) then
      _hx_5 = currentContentObj; else
      _hx_5 = nil; end
      return _hx_5
    end )();
    if ((controlCmd ~= nil) and (controlCmd.commandType == 14)) then
      self._state.callStack:PushThread();
    end;
  end,
  'VisitContainer', function(self,container,atStart)
    if (not container.countingAtStartOnly or atStart) then
      if (container.visitsShouldBeCounted) then
        self:IncrementVisitCountForContainer(container);
      end;
      if (container.turnIndexShouldBeCounted) then
        self:RecordTurnIndexVisitToContainer(container);
      end;
    end;
  end,
  'ProcessChoice', function(self,choicePoint)
    local showChoice = true;
    if (choicePoint.hasCondition) then
      local conditionValue = self._state:PopEvaluationStack();
      if (not self:IsTruthy(conditionValue)) then
        showChoice = false;
      end;
    end;
    local startText = "";
    local choiceOnlyText = "";
    if (choicePoint.hasChoiceOnlyContent) then
      local obj = self._state:PopEvaluationStack();
      local choiceOnlyStrVal = (function()
        local _hx_1
        if (lua.Boot.__instanceof(obj,ink.runtime.StringValue)) then
        _hx_1 = obj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      choiceOnlyText = choiceOnlyStrVal.value;
    end;
    if (choicePoint.hasStartContent) then
      local obj1 = self._state:PopEvaluationStack();
      local startStrVal = (function()
        local _hx_2
        if (lua.Boot.__instanceof(obj1,ink.runtime.StringValue)) then
        _hx_2 = obj1; else
        _hx_2 = nil; end
        return _hx_2
      end )();
      startText = startStrVal.value;
    end;
    if (choicePoint.onceOnly) then
      local visitCount = self:VisitCountForContainer(choicePoint:get_choiceTarget());
      if (visitCount > 0) then
        showChoice = false;
      end;
    end;
    local choice = ink.runtime.Choice.create(choicePoint);
    choice.threadAtGeneration = self._state.callStack:get_currentThread():Copy();
    if (not showChoice) then
      do return nil end;
    end;
    choice.text = startText .. choiceOnlyText;
    do return choice end
  end,
  'IsTruthy', function(self,obj)
    local truthy = false;
    if (lua.Boot.__instanceof(obj,ink.runtime.Value)) then
      local val = (function()
        local _hx_1
        if (lua.Boot.__instanceof(obj,ink.runtime.Value)) then
        _hx_1 = obj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if (lua.Boot.__instanceof(val,ink.runtime.DivertTargetValue)) then
        local divTarget = val;
        self:ErrorThrow("Shouldn't use a divert target (to " .. Std.string(divTarget:get_targetPath()) .. ") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)");
        do return false end;
      end;
      do return val:get_isTruthy() end;
    end;
    do return truthy end
  end,
  'PerformLogicAndFlowControl', function(self,contentObj)
    if (contentObj == nil) then
      do return false end;
    end;
    if (lua.Boot.__instanceof(contentObj,ink.runtime.Divert)) then
      local currentDivert = contentObj;
      if (currentDivert.isConditional) then
        local conditionValue = self._state:PopEvaluationStack();
        if (not self:IsTruthy(conditionValue)) then
          do return true end;
        end;
      end;
      if (currentDivert:get_hasVariableTarget()) then
        local varName = currentDivert.variableDivertName;
        local varContents = self._state.variablesState:GetVariableWithName(varName);
        if (not lua.Boot.__instanceof(varContents,ink.runtime.DivertTargetValue)) then
          local intContent = (function()
            local _hx_1
            if (lua.Boot.__instanceof(varContents,ink.runtime.IntValue)) then
            _hx_1 = varContents; else
            _hx_1 = nil; end
            return _hx_1
          end )();
          local errorMessage = "Tried to divert to a target from a variable, but the variable (" .. varName .. ") didn't contain a divert target, it ";
          if ((intContent ~= nil) and (intContent.value == 0)) then
            errorMessage = errorMessage .. "was empty/null (the value 0).";
          else
            errorMessage = errorMessage .. ("contained '" .. Std.string(varContents) .. "'.");
          end;
          self:ErrorThrow(errorMessage);
        end;
        local target = varContents;
        local tmp = target:get_targetPath();
        self._state.divertedTargetObject = self:ContentAtPath(tmp);
      else
        if (currentDivert.isExternal) then
          self:CallExternalFunction(currentDivert:get_targetPathString(),currentDivert.externalArgs);
          do return true end;
        else
          self._state.divertedTargetObject = currentDivert:get_targetContent();
        end;
      end;
      if (currentDivert.pushesToStack) then
        self._state.callStack:Push(currentDivert.stackPushType);
      end;
      if ((self._state.divertedTargetObject == nil) and not currentDivert.isExternal) then
        if ((currentDivert ~= nil) and (currentDivert:get_debugMetadata().sourceName ~= nil)) then
          self:ErrorThrow("Divert target doesn't exist: " .. currentDivert:get_debugMetadata().sourceName);
        else
          self:ErrorThrow("Divert resolution failed: " .. Std.string(currentDivert));
        end;
      end;
      do return true end;
    else
      if (lua.Boot.__instanceof(contentObj,ink.runtime.ControlCommand)) then
        local evalCommand = contentObj;
        local _g = evalCommand.commandType;
        local _g1 = _g;
        if (_g1) == 0 then
          if (self._state:get_inExpressionEvaluation() ~= false) then
            _G.error("Already in expression evaluation?",0);
          end;
          self._state:set_inExpressionEvaluation(true);
        elseif (_g1) == 1 then
          if (self._state.evaluationStack.length > 0) then
            local output = self._state:PopEvaluationStack();
            if (not lua.Boot.__instanceof(output,ink.runtime.VoidObj)) then
              local text = ink.runtime.StringValue.new(Std.string(output));
              self._state:PushToOutputStream(text);
            end;
          end;
        elseif (_g1) == 2 then
          if (self._state:get_inExpressionEvaluation() ~= true) then
            _G.error("Not in expression evaluation mode",0);
          end;
          self._state:set_inExpressionEvaluation(false);
        elseif (_g1) == 3 then
          self._state:PushEvaluationStack(self._state:PeekEvaluationStack());
        elseif (_g1) == 4 then
          self._state:PopEvaluationStack();
        elseif (_g1) == 5 or (_g1) == 6 then
          local popType = (function()
            local _hx_2
            if (evalCommand.commandType == 5) then
            _hx_2 = 1; else
            _hx_2 = 0; end
            return _hx_2
          end )();
          if ((self._state.callStack:get_currentElement().type ~= popType) or not self._state.callStack:get_canPop()) then
            local names_h = _hx_e();
            names_h[1] = "function return statement (~ return)";
            names_h[0] = "tunnel onwards statement (->->)";
            local expected = names_h[self._state.callStack:get_currentElement().type];
            if (not self._state.callStack:get_canPop()) then
              expected = "end of flow (-> END or choice)";
            end;
            local errorMsg = "Found " .. names_h[popType] .. ", when expected " .. expected;
            self:ErrorThrow(errorMsg);
          else
            self._state.callStack:Pop();
          end;
        elseif (_g1) == 7 then
          self._state:PushToOutputStream(evalCommand);
          if (self._state:get_inExpressionEvaluation() ~= true) then
            _G.error("Expected to be in an expression when evaluating a string",0);
          end;
          self._state:set_inExpressionEvaluation(false);
        elseif (_g1) == 8 then
          local contentStackForString = haxe.ds.GenericStack.new();
          local outputCountConsumed = 0;
          local i = self._state:get_outputStream().length - 1;
          while (i >= 0) do
            local obj = self._state:get_outputStream()[i];
            outputCountConsumed = outputCountConsumed + 1;
            local command = (function()
              local _hx_3
              if (lua.Boot.__instanceof(obj,ink.runtime.ControlCommand)) then
              _hx_3 = obj; else
              _hx_3 = nil; end
              return _hx_3
            end )();
            if ((command ~= nil) and (command.commandType == 7)) then
              break;
            end;
            if (lua.Boot.__instanceof(obj,ink.runtime.StringValue)) then
              contentStackForString.head = haxe.ds.GenericCell.new(obj,contentStackForString.head);
            end;
            i = i - 1;
            end;
          self._state:get_outputStream():splice(self._state:get_outputStream().length - outputCountConsumed,outputCountConsumed);
          local sb = StringBuf.new();
          local c = contentStackForString:iterator();
          while (c:hasNext()) do
            local c1 = c:next();
            local str = Std.string(Std.string(c1));
            _G.table.insert(sb.b,str);
            local sb1 = sb;
            sb1.length = sb1.length + str.length;
            end;
          self._state:set_inExpressionEvaluation(true);
          self._state:PushEvaluationStack(ink.runtime.StringValue.new(Std.string(sb)));
        elseif (_g1) == 9 then
        elseif (_g1) == 10 then
          local choiceCount = self:get_currentChoices().length;
          self._state:PushEvaluationStack(ink.runtime.IntValue.new(choiceCount));
        elseif (_g1) == 11 then
          local target1 = self._state:PopEvaluationStack();
          if (not lua.Boot.__instanceof(target1,ink.runtime.DivertTargetValue)) then
            local extraNote = "";
            if (lua.Boot.__instanceof(target1,ink.runtime.IntValue)) then
              extraNote = ". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?";
            end;
            self:ErrorThrow("TURNS_SINCE expected a divert target (knot, stitch, label name), but saw " .. Std.string(target1) .. extraNote);
          else
            local divertTarget = (function()
              local _hx_4
              if (lua.Boot.__instanceof(target1,ink.runtime.DivertTargetValue)) then
              _hx_4 = target1; else
              _hx_4 = nil; end
              return _hx_4
            end )();
            local obj1 = self:ContentAtPath(divertTarget:get_targetPath());
            local container = (function()
              local _hx_5
              if (lua.Boot.__instanceof(obj1,ink.runtime.Container)) then
              _hx_5 = obj1; else
              _hx_5 = nil; end
              return _hx_5
            end )();
            local turnCount = self:TurnsSinceForContainer(container);
            self._state:PushEvaluationStack(ink.runtime.IntValue.new(turnCount));
          end;
        elseif (_g1) == 12 then
          local count = self:VisitCountForContainer(self._state:get_currentContainer()) - 1;
          self._state:PushEvaluationStack(ink.runtime.IntValue.new(count));
        elseif (_g1) == 13 then
          local shuffleIndex = self:NextSequenceShuffleIndex();
          self._state:PushEvaluationStack(ink.runtime.IntValue.new(shuffleIndex));
        elseif (_g1) == 14 then
        elseif (_g1) == 15 then
          if (self._state.callStack:get_canPopThread()) then
            self._state.callStack:PopThread();
          else
            self._state.didSafeExit = true;
          end;
        elseif (_g1) == 16 then
          self._state:ForceEndFlow();else
        self:ErrorThrow("unhandled ControlCommand: " .. Std.string(evalCommand)); end;
        do return true end;
      else
        if (lua.Boot.__instanceof(contentObj,ink.runtime.VariableAssignment)) then
          local varAss = contentObj;
          local assignedVal = self._state:PopEvaluationStack();
          self._state.variablesState:Assign(varAss,assignedVal);
          do return true end;
        else
          if (lua.Boot.__instanceof(contentObj,ink.runtime.VariableReference)) then
            local varRef = contentObj;
            local foundValue = nil;
            if (varRef.pathForCount ~= nil) then
              local container1 = varRef:get_containerForCount();
              local count1 = self:VisitCountForContainer(container1);
              foundValue = ink.runtime.IntValue.new(count1);
            else
              foundValue = self._state.variablesState:GetVariableWithName(varRef.name);
              if (foundValue == nil) then
                self:ErrorThrow("Uninitialised variable: " .. varRef.name);
                foundValue = ink.runtime.IntValue.new(0);
              end;
            end;
            self._state.evaluationStack:push(foundValue);
            do return true end;
          else
            if (lua.Boot.__instanceof(contentObj,ink.runtime.NativeFunctionCall)) then
              local func = contentObj;
              local funcParams = self._state:PopEvaluationStack1(func:get_numberOfParameters());
              local result = func:Call(ink.runtime.LibUtil.arrayToList(funcParams));
              self._state.evaluationStack:push(result);
              do return true end;
            end;
          end;
        end;
      end;
    end;
    do return false end
  end,
  'ChoosePathString', function(self,path)
    self:ChoosePath(ink.runtime.Path.createFromString(path));
  end,
  'ChoosePath', function(self,path)
    self._state:SetChosenPath(path);
    self:VisitChangedContainersDueToDivert();
  end,
  'VisitChangedContainersDueToDivert', function(self)
    local previousContentObject = self._state:get_previousContentObject();
    local newContentObject = self._state:get_currentContentObject();
    if (newContentObject == nil) then
      do return end;
    end;
    local prevContainerSet = ink.runtime.HashSet.new();
    if (previousContentObject ~= nil) then
      local prevAncestor;
      if (lua.Boot.__instanceof(previousContentObject,ink.runtime.Container)) then
        prevAncestor = (function()
          local _hx_1
          if (lua.Boot.__instanceof(previousContentObject,ink.runtime.Container)) then
          _hx_1 = previousContentObject; else
          _hx_1 = nil; end
          return _hx_1
        end )();
      else
        local obj = previousContentObject.parent;
        if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
          prevAncestor = obj;
        else
          prevAncestor = nil;
        end;
      end;
      while (prevAncestor ~= nil) do
        prevContainerSet:add(prevAncestor);
        local obj1 = prevAncestor.parent;
        if (lua.Boot.__instanceof(obj1,ink.runtime.Container)) then
          prevAncestor = obj1;
        else
          prevAncestor = nil;
        end;
        end;
    end;
    local currentChildOfContainer = newContentObject;
    local obj2 = currentChildOfContainer.parent;
    local currentContainerAncestor = (function()
      local _hx_2
      if (lua.Boot.__instanceof(obj2,ink.runtime.Container)) then
      _hx_2 = obj2; else
      _hx_2 = nil; end
      return _hx_2
    end )();
    while ((currentContainerAncestor ~= nil) and not prevContainerSet:contains(currentContainerAncestor)) do
      local enteringAtStart = (currentContainerAncestor._content.length > 0) and (currentChildOfContainer == currentContainerAncestor._content[0]);
      self:VisitContainer(currentContainerAncestor,enteringAtStart);
      currentChildOfContainer = currentContainerAncestor;
      local obj3 = currentContainerAncestor.parent;
      if (lua.Boot.__instanceof(obj3,ink.runtime.Container)) then
        currentContainerAncestor = obj3;
      else
        currentContainerAncestor = nil;
      end;
      end;
  end,
  'mainContentContainer', nil,
  'get_mainContentContainer', function(self)
    if (self._temporaryEvaluationContainer ~= nil) then
      do return self._temporaryEvaluationContainer end;
    else
      do return self._mainContentContainer end;
    end;
  end,
  '_mainContentContainer', nil,
  '_externals', nil,
  '_variableObservers', nil,
  '_hasValidatedExternals', nil,
  '_temporaryEvaluationContainer', nil,
  'ChooseChoiceIndex', function(self,choiceIdx)
    local choices = self:get_currentChoices();
    if (not ((choiceIdx >= 0) and (choiceIdx < choices.length))) then
      _G.error("choice out of range",0);
    end;
    local choiceToChoose = choices[choiceIdx];
    self._state.callStack:set_currentThread(choiceToChoose.threadAtGeneration);
    self:ChoosePath(choiceToChoose.choicePoint:get_choiceTarget():get_path());
  end,
  'HasFunction', function(self,functionName)
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function()

        do return lua.Boot.__instanceof(self:ContentAtPath(ink.runtime.Path.createFromString(functionName)),ink.runtime.Container) end;
       return _hx_expected_result end)
     if not _hx_status then
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Error) ) then
        local e = _hx_1
        do return false end;
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'allowExternalFunctionFallbacks', nil,
  'CallExternalFunction', function(self,funcName,numberOfArguments)
    local func = nil;
    local fallbackFunctionContainer = nil;
    local this1 = self._externals;
    func = this1.v[funcName];
    local foundExternal = func ~= nil;
    if (not foundExternal) then
      if (self.allowExternalFunctionFallbacks) then
        local obj = self:ContentAtPath(ink.runtime.Path.createFromString(funcName));
        if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
          fallbackFunctionContainer = obj;
        else
          fallbackFunctionContainer = nil;
        end;
        if (fallbackFunctionContainer == nil) then
          _G.error("Trying to call EXTERNAL function '" .. funcName .. "' which has not been bound, and fallback ink function could not be found.",0);
        end;
        self._state.callStack:Push(1);
        self._state.divertedTargetObject = fallbackFunctionContainer;
        do return end;
      else
        _G.error("Trying to call EXTERNAL function '" .. funcName .. "' which has not been bound (and ink fallbacks disabled).",0);
      end;
    end;
    local arguments = Array.new();
    local _g1 = 0;
    local _g = numberOfArguments;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local obj1 = self._state:PopEvaluationStack();
      local poppedObj = (function()
        local _hx_1
        if (lua.Boot.__instanceof(obj1,ink.runtime.Value)) then
        _hx_1 = obj1; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      local valueObj = poppedObj:get_valueObject();
      arguments:push(valueObj);
      end;
    arguments:reverse();
    local funcResult = func(arguments);
    local returnObj = nil;
    if (funcResult ~= nil) then
      returnObj = ink.runtime.Value.Create(funcResult);
      local error = "Could not create ink value from returned object of type " .. Type.getClassName(Type.getClass(funcResult));
      if (returnObj == nil) then
        _G.error(error,0);
      end;
    else
      returnObj = ink.runtime.VoidObj.new();
    end;
    self._state:PushEvaluationStack(returnObj);
  end,
  'TryCoerce', function(self,value)
    do return value end
  end,
  'BindExternalFunctionGeneral', function(self,funcName,func)
    local this1 = self._externals;
    if (not (not (this1.k[funcName] or false))) then
      _G.error("Function '" .. funcName .. "' has already been bound.",0);
    end;
    local _this = self._externals;
    _this.v[funcName] = func;
    _this.k[funcName] = true;
  end,
  'BindExternalFunction0', function(self,funcName,func)
    if (func == nil) then
      _G.error("Can't bind a null function",0);
    end;
    self:BindExternalFunctionGeneral(funcName,function(args)
      if (args.length ~= 0) then
        _G.error("External function expected no arguments",0);
      end;
      do return func() end;
    end);
  end,
  'BindExternalFunction1', function(self,funcName,func)
    if (func == nil) then
      _G.error("Can't bind a null function",0);
    end;
    self:BindExternalFunctionGeneral(funcName,function(args)
      if (args.length ~= 1) then
        _G.error("External function expected 1 argument",0);
      end;
      local param1 = args[0];
      do return func(param1) end;
    end);
  end,
  'BindExternalFunction2', function(self,funcName,func)
    if (func == nil) then
      _G.error("Can't bind a null function",0);
    end;
    self:BindExternalFunctionGeneral(funcName,function(args)
      if (args.length ~= 2) then
        _G.error("External function expected 2 arguments",0);
      end;
      local param1 = args[0];
      local param2 = args[1];
      do return func(param1,param2) end;
    end);
  end,
  'BindExternalFunction3', function(self,funcName,func)
    if (func == nil) then
      _G.error("Can't bind a null function",0);
    end;
    self:BindExternalFunctionGeneral(funcName,function(args)
      if (args.length ~= 3) then
        _G.error("External function expected 3 arguments",0);
      end;
      local param1 = args[0];
      local param2 = args[1];
      local param3 = args[2];
      do return func(param1,param2,param3) end;
    end);
  end,
  'UnbindExternalFunction', function(self,funcName)
    local this1 = self._externals;
    if (not (this1.k[funcName] or false)) then
      _G.error("Function '" .. funcName .. "' has not been bound.",0);
    end;
    self._externals:remove(funcName);
  end,
  'ValidateExternalBindings', function(self)
    self:ValidateExternalBindingsC(self._mainContentContainer);
    self._hasValidatedExternals = true;
  end,
  'ValidateExternalBindingsC', function(self,c)
    local _g = 0;
    local _g1 = c._content;
    while (_g < _g1.length) do
      local innerContent = _g1[_g];
      _g = _g + 1;
      self:ValidateExternalBindingsO(innerContent);
      end;
    local value = c.namedContent:iterator();
    while (value:hasNext()) do
      local value1 = value:next();
      self:ValidateExternalBindingsO((function()
        local _hx_1
        if (lua.Boot.__instanceof(value1,ink.runtime.RObject)) then
        _hx_1 = value1; else
        _hx_1 = nil; end
        return _hx_1
      end )());
      end;
  end,
  'ValidateExternalBindingsO', function(self,o)
    local container = (function()
      local _hx_1
      if (lua.Boot.__instanceof(o,ink.runtime.Container)) then
      _hx_1 = o; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (container ~= nil) then
      self:ValidateExternalBindingsC(container);
      do return end;
    end;
    local divert = (function()
      local _hx_2
      if (lua.Boot.__instanceof(o,ink.runtime.Divert)) then
      _hx_2 = o; else
      _hx_2 = nil; end
      return _hx_2
    end )();
    if ((divert ~= nil) and divert.isExternal) then
      local name = divert:get_targetPathString();
      local this1 = self._externals;
      if (not (this1.k[name] or false)) then
        local fallbackFunction = nil;
        local this2 = self:get_mainContentContainer().namedContent;
        fallbackFunction = this2.v[name];
        local fallbackFound = fallbackFunction ~= nil;
        local message = nil;
        if (not self.allowExternalFunctionFallbacks) then
          message = "Missing function binding for external '" .. name .. "' (ink fallbacks disabled)";
        else
          if (not fallbackFound) then
            message = "Missing function binding for external '" .. name .. "', and no fallback ink function found.";
          end;
        end;
        if (message ~= nil) then
          local errorPreamble = "ERROR: ";
          if (divert:get_debugMetadata() ~= nil) then
            errorPreamble = errorPreamble .. ("'" .. divert:get_debugMetadata().fileName .. "' line " .. divert:get_debugMetadata().startLineNumber .. ": ");
          end;
          _G.error(ink.runtime.StoryException.new(errorPreamble .. message),0);
        end;
      end;
    end;
  end,
  'ReflectExternalBindings', function(self,array)
    if (array == nil) then
      array = Array.new();
    end;
    self:ReflectExternalBindingsC(self._mainContentContainer,array);
    do return array end
  end,
  'ReflectExternalBindingsC', function(self,c,array)
    local _g = 0;
    local _g1 = c._content;
    while (_g < _g1.length) do
      local innerContent = _g1[_g];
      _g = _g + 1;
      self:ReflectExternalBindingsO(innerContent,array);
      end;
    local value = c.namedContent:iterator();
    while (value:hasNext()) do
      local value1 = value:next();
      self:ReflectExternalBindingsO((function()
        local _hx_1
        if (lua.Boot.__instanceof(value1,ink.runtime.RObject)) then
        _hx_1 = value1; else
        _hx_1 = nil; end
        return _hx_1
      end )(),array);
      end;
  end,
  'ReflectExternalBindingsO', function(self,o,array)
    local container = (function()
      local _hx_1
      if (lua.Boot.__instanceof(o,ink.runtime.Container)) then
      _hx_1 = o; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (container ~= nil) then
      self:ReflectExternalBindingsC(container,array);
      do return end;
    end;
    local divert = (function()
      local _hx_2
      if (lua.Boot.__instanceof(o,ink.runtime.Divert)) then
      _hx_2 = o; else
      _hx_2 = nil; end
      return _hx_2
    end )();
    if ((divert ~= nil) and divert.isExternal) then
      array:push(divert:get_targetPathString());
    end;
  end
  ,'__class__',  ink.runtime.Story,
  '__properties__',  {get_mainContentContainer="get_mainContentContainer",get_canContinue="get_canContinue",get_currentDebugMetadata="get_currentDebugMetadata",get_state="get_state",get_variablesState="get_variablesState",get_hasErrorThrow="get_hasErrorThrow",get_currentErrors="get_currentErrors",get_currentText="get_currentText",get_currentChoices="get_currentChoices"}
)
ink.runtime.Story.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.Story.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.Story.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.StoryException.new = function(message)
  local self = _hx_new(ink.runtime.StoryException.prototype)
  ink.runtime.StoryException.super(self,message)
  return self
end
ink.runtime.StoryException.super = function(self,message)
  ink.runtime.SystemException.super(self,message);
end
_hxClasses["ink.runtime.StoryException"] = ink.runtime.StoryException
ink.runtime.StoryException.__name__ = {"ink","runtime","StoryException"}
ink.runtime.StoryException.prototype = _hx_a(
  'useEndLineNumber', nil
  ,'__class__',  ink.runtime.StoryException
)
ink.runtime.StoryException.__super__ = ink.runtime.SystemException
setmetatable(ink.runtime.StoryException.prototype,{__index=ink.runtime.SystemException.prototype})

ink.runtime.SystemNotImplementedException.new = function(message)
  local self = _hx_new(ink.runtime.SystemNotImplementedException.prototype)
  ink.runtime.SystemNotImplementedException.super(self,message)
  return self
end
ink.runtime.SystemNotImplementedException.super = function(self,message)
  ink.runtime.SystemException.super(self,message);
end
_hxClasses["ink.runtime.SystemNotImplementedException"] = ink.runtime.SystemNotImplementedException
ink.runtime.SystemNotImplementedException.__name__ = {"ink","runtime","SystemNotImplementedException"}
ink.runtime.SystemNotImplementedException.prototype = _hx_a(

  '__class__',  ink.runtime.SystemNotImplementedException
)
ink.runtime.SystemNotImplementedException.__super__ = ink.runtime.SystemException
setmetatable(ink.runtime.SystemNotImplementedException.prototype,{__index=ink.runtime.SystemException.prototype})

ink.runtime.StoryState.new = function(story)
  local self = _hx_new(ink.runtime.StoryState.prototype)
  ink.runtime.StoryState.super(self,story)
  return self
end
ink.runtime.StoryState.super = function(self,story)
  self.story = story;
  self._outputStream = Array.new();
  self.evaluationStack = Array.new();
  self.callStack = ink.runtime.CallStack.createCallStack(story:get_rootContentContainer());
  self.variablesState = ink.runtime.VariablesState.new(self.callStack);
  self.visitCounts = haxe.ds.StringMap.new();
  self.turnIndices = haxe.ds.StringMap.new();
  self.currentTurnIndex = -1;
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t",Std.int(d.t));
  local timeSeed = Std.int(d:getTime());
  self.storySeed = _G.math.fmod(Std.int(ink.random.ParkMiller.new(timeSeed):random()), 100);
  self.currentChoices = List.new();
  self:GoToStart();
end
_hxClasses["ink.runtime.StoryState"] = ink.runtime.StoryState
ink.runtime.StoryState.__name__ = {"ink","runtime","StoryState"}
ink.runtime.StoryState.prototype = _hx_a(
  'ToJson', function(self)
    do return haxe.Json.stringify(self:get_jsonToken()) end
  end,
  'LoadJson', function(self,json)
    self:set_jsonToken(haxe.Json.parse(json));
  end,
  'VisitCountAtPathString', function(self,pathString)
    local this1 = self.visitCounts;
    local visitCountOut = this1.v[pathString];
    if ((visitCountOut ~= nil) and not Math.isNaN(visitCountOut)) then
      do return visitCountOut end;
    end;
    do return 0 end
  end,
  'outputStream', nil,
  'get_outputStream', function(self)
    do return self._outputStream end
  end,
  'currentChoices', nil,
  'currentErrors', nil,
  'variablesState', nil,
  'callStack', nil,
  'evaluationStack', nil,
  'divertedTargetObject', nil,
  'visitCounts', nil,
  'turnIndices', nil,
  'currentTurnIndex', nil,
  'storySeed', nil,
  'didSafeExit', nil,
  'story', nil,
  'get_currentPath', function(self)
    if (self:get_currentContentObject() == nil) then
      do return nil end;
    end;
    do return self:get_currentContentObject():get_path() end
  end,
  'set_currentPath', function(self,value)
    if (value ~= nil) then
      self:set_currentContentObject(self.story:ContentAtPath(value));
    else
      self:set_currentContentObject(nil);
    end;
    if (self:get_currentContentObject() ~= nil) then
      do return self:get_currentContentObject():get_path() end;
    else
      do return nil end;
    end;
  end,
  'get_currentContentObject', function(self)
    do return self.callStack:get_currentElement():get_currentObject() end
  end,
  'set_currentContentObject', function(self,value)
    self.callStack:get_currentElement():set_currentObject(value);
    do return value end
  end,
  'currentContainer', nil,
  'get_currentContainer', function(self)
    do return self.callStack:get_currentElement().currentContainer end
  end,
  'get_previousContentObject', function(self)
    do return self.callStack:get_currentThread().previousContentObject end
  end,
  'set_previousContentObject', function(self,value)
    self.callStack:get_currentThread().previousContentObject = value;
    do return value end
  end,
  'hasError', nil,
  'get_hasError', function(self)
    if (self.currentErrors ~= nil) then
      do return self.currentErrors.length > 0 end;
    else
      do return false end;
    end;
  end,
  'currentText', nil,
  'get_currentText', function(self)
    local sb_length;
    local sb_b = _hx_e();
    sb_length = 0;
    local _g = 0;
    local _g1 = self._outputStream;
    while (_g < _g1.length) do
      local outputObj = _g1[_g];
      _g = _g + 1;
      local textContent = (function()
        local _hx_1
        if (lua.Boot.__instanceof(outputObj,ink.runtime.StringValue)) then
        _hx_1 = outputObj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if (textContent ~= nil) then
        local str = Std.string(textContent.value);
        _G.table.insert(sb_b,str);
        sb_length = sb_length + str.length;
      end;
      end;
    do return _G.table.concat(sb_b) end
  end,
  'get_inExpressionEvaluation', function(self)
    do return self.callStack:get_currentElement().inExpressionEvaluation end
  end,
  'set_inExpressionEvaluation', function(self,value)
    self.callStack:get_currentElement().inExpressionEvaluation = value;
    do return value end
  end,
  'GoToStart', function(self)
    self.callStack:get_currentElement().currentContainer = self.story:get_mainContentContainer();
    self.callStack:get_currentElement().currentContentIndex = 0;
  end,
  'Copy', function(self)
    local copy = ink.runtime.StoryState.new(self.story);
    ink.runtime.LibUtil.addRangeForArray(copy:get_outputStream(),self._outputStream);
    ink.runtime.LibUtil.addRangeForList(copy.currentChoices,self.currentChoices);
    if (self:get_hasError()) then
      copy.currentErrors = List.new();
      ink.runtime.LibUtil.addRangeForList(copy.currentErrors,self.currentErrors);
    end;
    copy.callStack = ink.runtime.CallStack.createCallStack2(self.callStack);
    copy._currentRightGlue = self._currentRightGlue;
    copy.variablesState = ink.runtime.VariablesState.new(copy.callStack);
    copy.variablesState:CopyFrom(self.variablesState);
    ink.runtime.LibUtil.addRangeForArray(copy.evaluationStack,self.evaluationStack);
    if (self.divertedTargetObject ~= nil) then
      copy.divertedTargetObject = self.divertedTargetObject;
    end;
    copy:set_previousContentObject(self:get_previousContentObject());
    copy.visitCounts = ink.runtime.LibUtil.cloneStrIntMap(self.visitCounts);
    copy.turnIndices = ink.runtime.LibUtil.cloneStrIntMap(self.turnIndices);
    copy.currentTurnIndex = self.currentTurnIndex;
    copy.storySeed = self.storySeed;
    copy.didSafeExit = self.didSafeExit;
    do return copy end
  end,
  'get_jsonToken', function(self)
    local obj = _hx_e();
    local choiceThreads = nil;
    local _g_head = self.currentChoices.h;
    while (_g_head ~= nil) do
      local val = _g_head.item;
      _g_head = _g_head.next;
      local c = val;
      c.originalChoicePath = c.choicePoint:get_path():get_componentsString();
      c.originalThreadIndex = c.threadAtGeneration.threadIndex;
      if (self.callStack:ThreadWithIndex(c.originalThreadIndex) == nil) then
        if (choiceThreads == nil) then
          choiceThreads = haxe.ds.StringMap.new();
        end;
        local k = Std.string(c.originalThreadIndex);
        local v = c.threadAtGeneration:get_jsonToken();
        choiceThreads.v[k] = v;
        choiceThreads.k[k] = true;
      end;
      end;
    if (choiceThreads ~= nil) then
      obj.choiceThreads = choiceThreads;
    end;
    obj.callstackThreads = self.callStack:GetJsonToken();
    obj.variablesState = self.variablesState:get_jsonToken();
    local serialisables = self.evaluationStack;
    local jArray = Array.new();
    local _g = 0;
    while (_g < serialisables.length) do
      local s = serialisables[_g];
      _g = _g + 1;
      jArray:push(ink.runtime.Json.RuntimeObjectToJToken(s));
      end;
    obj.evalStack = jArray;
    local serialisables1 = self._outputStream;
    local jArray1 = Array.new();
    local _g1 = 0;
    while (_g1 < serialisables1.length) do
      local s1 = serialisables1[_g1];
      _g1 = _g1 + 1;
      jArray1:push(ink.runtime.Json.RuntimeObjectToJToken(s1));
      end;
    obj.outputStream = jArray1;
    obj.currentChoices = ink.runtime.Json.ListToJArray(self.currentChoices);
    if (self._currentRightGlue ~= nil) then
      local rightGluePos = self._outputStream:indexOf(self._currentRightGlue);
      if (rightGluePos ~= -1) then
        obj.currRightGlue = rightGluePos;
      end;
    end;
    if (self.divertedTargetObject ~= nil) then
      obj.currentDivertTarget = self.divertedTargetObject:get_path():get_componentsString();
    end;
    obj.visitCounts = ink.runtime.Json.IntDictionaryToJObject(self.visitCounts);
    obj.turnIndices = ink.runtime.Json.IntDictionaryToJObject(self.turnIndices);
    obj.turnIdx = self.currentTurnIndex;
    obj.storySeed = self.storySeed;
    obj.inkSaveVersion = 4;
    obj.inkFormatVersion = 12;
    do return obj end
  end,
  'set_jsonToken', function(self,value)
    local jObject = value;
    local jSaveVersion = nil;
    jSaveVersion = Reflect.field(jObject,"inkSaveVersion");
    if (jSaveVersion == nil) then
      _G.error(ink.runtime.StoryException.new("ink save format incorrect, can't load."),0);
    else
      if (Std.int(jSaveVersion) < ink.runtime.StoryState.kMinCompatibleLoadVersion) then
        _G.error(ink.runtime.StoryException.new("Ink save format isn't compatible with the current version (saw '" .. Std.string(jSaveVersion) .. "', but minimum is " .. ink.runtime.StoryState.kMinCompatibleLoadVersion .. "), so can't load."),0);
      end;
    end;
    self.callStack:SetJsonToken(Reflect.field(jObject,"callstackThreads"),self.story);
    self.variablesState:set_jsonToken(Reflect.field(jObject,"variablesState"));
    self.evaluationStack = ink.runtime.Json.JArrayToRuntimeObjArray(Reflect.field(jObject,"evalStack"));
    self._outputStream = ink.runtime.Json.JArrayToRuntimeObjArray(Reflect.field(jObject,"outputStream"));
    self.currentChoices = ink.runtime.Json.JArrayToRuntimeObjList(Reflect.field(jObject,"currentChoices"));
    local propValue = Reflect.field(jObject,"currRightGlue");
    if (propValue ~= nil) then
      local gluePos = Std.int(propValue);
      if (gluePos >= 0) then
        local obj = self._outputStream[gluePos];
        self._currentRightGlue = (function()
          local _hx_1
          if (lua.Boot.__instanceof(obj,ink.runtime.Glue)) then
          _hx_1 = obj; else
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    local currentDivertTargetPath = Reflect.field(jObject,"currRightGlue");
    if (currentDivertTargetPath ~= nil) then
      local divertPath = ink.runtime.Path.createFromString(Std.string(currentDivertTargetPath));
      self.divertedTargetObject = self.story:ContentAtPath(divertPath);
    end;
    self.visitCounts = ink.runtime.Json.JObjectToIntDictionary(Reflect.field(jObject,"visitCounts"));
    self.turnIndices = ink.runtime.Json.JObjectToIntDictionary(Reflect.field(jObject,"turnIndices"));
    self.currentTurnIndex = Std.int(Reflect.field(jObject,"turnIdx"));
    self.storySeed = Std.int(Reflect.field(jObject,"storySeed"));
    local jChoiceThreadsObj = nil;
    jChoiceThreadsObj = Reflect.field(jObject,"choiceThreads");
    local jChoiceThreads = jChoiceThreadsObj;
    local _g_head = self.currentChoices.h;
    while (_g_head ~= nil) do
      local val = _g_head.item;
      _g_head = _g_head.next;
      local c = val;
      c.choicePoint = self.story:ContentAtPath(ink.runtime.Path.createFromString(c.originalChoicePath));
      local foundActiveThread = self.callStack:ThreadWithIndex(c.originalThreadIndex);
      if (foundActiveThread ~= nil) then
        c.threadAtGeneration = foundActiveThread;
      else
        local jSavedChoiceThread = Reflect.field(jChoiceThreads,Std.string(c.originalThreadIndex));
        c.threadAtGeneration = ink.runtime.Thread.create(jSavedChoiceThread,self.story);
      end;
      end;
    do return value end
  end,
  'ResetErrors', function(self)
    self.currentErrors = nil;
  end,
  'ResetOutput', function(self)
    local arr = self._outputStream;
    arr:splice(0,arr.length);
  end,
  'PushToOutputStream', function(self,obj)
    local text = (function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.StringValue)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (text ~= nil) then
      local listText = self:TrySplittingHeadTailWhitespace(text);
      if (listText ~= nil) then
        local _g_head = listText.h;
        while (_g_head ~= nil) do
          local val = _g_head.item;
          _g_head = _g_head.next;
          local textObj = val;
          self:PushToOutputStreamIndividual(textObj);
          end;
        do return end;
      end;
    end;
    self:PushToOutputStreamIndividual(obj);
  end,
  'TrySplittingHeadTailWhitespace', function(self,single)
    local str = single.value;
    local headFirstNewlineIdx = -1;
    local headLastNewlineIdx = -1;
    local _g1 = 0;
    local _g = str.length;
    local _hx_break_0 = false;
    while (_g1 < _g) do
      repeat
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      local c = str:charAt(i);
      if (c == "\n") then
        if (headFirstNewlineIdx == -1) then
          headFirstNewlineIdx = i;
        end;
        headLastNewlineIdx = i;
      else
        if ((c == " ") or (c == "\t")) then
          break;
        else
          _hx_break_1 = true; break;
        end;
      end;

    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    local tailLastNewlineIdx = -1;
    local tailFirstNewlineIdx = -1;
    local _g11 = 0;
    local _g2 = str.length;
    local _hx_break_0 = false;
    while (_g11 < _g2) do
      repeat
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      local c1 = str:charAt(i1);
      if (c1 == "\n") then
        if (tailLastNewlineIdx == -1) then
          tailLastNewlineIdx = i1;
        end;
        tailFirstNewlineIdx = i1;
      else
        if ((c1 == " ") or (c1 == "\t")) then
          break;
        else
          _hx_break_1 = true; break;
        end;
      end;

    until true
    if _hx_break_1 then _hx_break_1 = false; break; end
    end;
    if ((headFirstNewlineIdx == -1) and (tailLastNewlineIdx == -1)) then
      do return nil end;
    end;
    local listTexts = List.new();
    local innerStrStart = 0;
    local innerStrEnd = str.length;
    if (headFirstNewlineIdx ~= -1) then
      if (headFirstNewlineIdx > 0) then
        local leadingSpaces = ink.runtime.StringValue.new(str:substring(0,headFirstNewlineIdx));
        listTexts:add(leadingSpaces);
      end;
      listTexts:add(ink.runtime.StringValue.new("\n"));
      innerStrStart = headLastNewlineIdx + 1;
    end;
    if (tailLastNewlineIdx ~= -1) then
      innerStrEnd = tailFirstNewlineIdx;
    end;
    if (innerStrEnd > innerStrStart) then
      local innerStrText = str:substring(innerStrStart,innerStrEnd - innerStrStart);
      listTexts:add(ink.runtime.StringValue.new(innerStrText));
    end;
    if ((tailLastNewlineIdx ~= -1) and (tailFirstNewlineIdx > headLastNewlineIdx)) then
      listTexts:add(ink.runtime.StringValue.new("\n"));
      if (tailLastNewlineIdx < (str.length - 1)) then
        local numSpaces = (str.length - tailLastNewlineIdx) - 1;
        local trailingSpaces = ink.runtime.StringValue.new(str:substring(tailLastNewlineIdx + 1,numSpaces));
        listTexts:add(trailingSpaces);
      end;
    end;
    do return listTexts end
  end,
  'PushToOutputStreamIndividual', function(self,obj)
    local glue = (function()
      local _hx_1
      if (lua.Boot.__instanceof(obj,ink.runtime.Glue)) then
      _hx_1 = obj; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    local text = (function()
      local _hx_2
      if (lua.Boot.__instanceof(obj,ink.runtime.StringValue)) then
      _hx_2 = obj; else
      _hx_2 = nil; end
      return _hx_2
    end )();
    local includeInOutput = true;
    if (glue ~= nil) then
      local foundMatchingLeftGlue = (glue:get_isLeft() and (self._currentRightGlue ~= nil)) and (glue.parent == self._currentRightGlue.parent);
      if (foundMatchingLeftGlue) then
        self._currentRightGlue = nil;
      end;
      if (glue:get_isLeft() or glue:get_isBi()) then
        self:TrimNewlinesFromOutputStream(foundMatchingLeftGlue);
      end;
      local isNewRightGlue = glue:get_isRight() and (self._currentRightGlue == nil);
      if (isNewRightGlue) then
        self._currentRightGlue = glue;
      end;
      if (not glue:get_isBi()) then
        includeInOutput = isNewRightGlue;
      else
        includeInOutput = true;
      end;
    else
      if (text ~= nil) then
        if (self:get_currentGlueIndex() ~= -1) then
          if (text.isNewline) then
            self:TrimFromExistingGlue();
            includeInOutput = false;
          else
            if (text:get_isNonWhitespace()) then
              self:RemoveExistingGlue();
              self._currentRightGlue = nil;
            end;
          end;
        else
          if (text.isNewline) then
            if (self:get_outputStreamEndsInNewline() or not self:get_outputStreamContainsContent()) then
              includeInOutput = false;
            end;
          end;
        end;
      end;
    end;
    if (includeInOutput) then
      self._outputStream:push(obj);
    end;
  end,
  'TrimNewlinesFromOutputStream', function(self,stopAndRemoveRightGlue)
    local removeWhitespaceFrom = -1;
    local rightGluePos = -1;
    local foundNonWhitespace = false;
    local i = self._outputStream.length - 1;
    while (i >= 0) do
      local obj = self._outputStream[i];
      local cmd = (function()
        local _hx_1
        if (lua.Boot.__instanceof(obj,ink.runtime.ControlCommand)) then
        _hx_1 = obj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      local txt = (function()
        local _hx_2
        if (lua.Boot.__instanceof(obj,ink.runtime.StringValue)) then
        _hx_2 = obj; else
        _hx_2 = nil; end
        return _hx_2
      end )();
      local glue = (function()
        local _hx_3
        if (lua.Boot.__instanceof(obj,ink.runtime.Glue)) then
        _hx_3 = obj; else
        _hx_3 = nil; end
        return _hx_3
      end )();
      if ((cmd ~= nil) or ((txt ~= nil) and txt:get_isNonWhitespace())) then
        foundNonWhitespace = true;
        if (not stopAndRemoveRightGlue) then
          break;
        end;
      else
        if ((stopAndRemoveRightGlue and (glue ~= nil)) and glue:get_isRight()) then
          rightGluePos = i;
          break;
        else
          if (((txt ~= nil) and txt.isNewline) and not foundNonWhitespace) then
            removeWhitespaceFrom = i;
          end;
        end;
      end;
      i = i - 1;
      end;
    if (removeWhitespaceFrom >= 0) then
      i = removeWhitespaceFrom;
      while (i < self._outputStream.length) do
        local obj1 = self._outputStream[i];
        local text = (function()
          local _hx_4
          if (lua.Boot.__instanceof(obj1,ink.runtime.StringValue)) then
          _hx_4 = obj1; else
          _hx_4 = nil; end
          return _hx_4
        end )();
        if (text ~= nil) then
          self._outputStream:splice(i,1);
        else
          i = i + 1;
        end;
        end;
    end;
    if (stopAndRemoveRightGlue and (rightGluePos > -1)) then
      self:get_outputStream():splice(rightGluePos,1);
    end;
  end,
  'TrimFromExistingGlue', function(self)
    local i = self:get_currentGlueIndex();
    while (i < self._outputStream.length) do
      local obj = self._outputStream[i];
      local txt = (function()
        local _hx_1
        if (lua.Boot.__instanceof(obj,ink.runtime.StringValue)) then
        _hx_1 = obj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if ((txt ~= nil) and not txt:get_isNonWhitespace()) then
        self._outputStream:splice(i,1);
      else
        i = i + 1;
      end;
      end;
  end,
  'RemoveExistingGlue', function(self)
    local i = self:get_outputStream().length;
    while (i >= 0) do
      local c = self._outputStream[i];
      if (lua.Boot.__instanceof(c,ink.runtime.Glue)) then
        self:get_outputStream():splice(i,1);
      else
        if (lua.Boot.__instanceof(c,ink.runtime.ControlCommand)) then
          break;
        end;
      end;
      i = i - 1;
      end;
  end,
  'currentGlueIndex', nil,
  'get_currentGlueIndex', function(self)
    local i = self._outputStream.length - 1;
    while (i >= 0) do
      local c = self._outputStream[i];
      local glue = (function()
        local _hx_1
        if (lua.Boot.__instanceof(c,ink.runtime.Glue)) then
        _hx_1 = c; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if (glue ~= nil) then
        do return i end;
      else
        if (lua.Boot.__instanceof(c,ink.runtime.ControlCommand)) then
          break;
        end;
      end;
      i = i - 1;
      end;
    do return -1 end
  end,
  'outputStreamEndsInNewline', nil,
  'get_outputStreamEndsInNewline', function(self)
    if (self._outputStream.length > 0) then
      local i = self._outputStream.length - 1;
      while (i >= 0) do
        local obj = self._outputStream[i];
        if (lua.Boot.__instanceof(obj,ink.runtime.ControlCommand)) then
          break;
        end;
        local obj1 = self._outputStream[i];
        local text = (function()
          local _hx_1
          if (lua.Boot.__instanceof(obj1,ink.runtime.StringValue)) then
          _hx_1 = obj1; else
          _hx_1 = nil; end
          return _hx_1
        end )();
        if (text ~= nil) then
          if (text.isNewline) then
            do return true end;
          else
            if (text:get_isNonWhitespace()) then
              break;
            end;
          end;
        end;
        i = i - 1;
        end;
    end;
    do return false end
  end,
  'outputStreamContainsContent', nil,
  'get_outputStreamContainsContent', function(self)
    local _g = 0;
    local _g1 = self._outputStream;
    while (_g < _g1.length) do
      local content = _g1[_g];
      _g = _g + 1;
      if (lua.Boot.__instanceof(content,ink.runtime.StringValue)) then
        do return true end;
      end;
      end;
    do return false end
  end,
  'inStringEvaluation', nil,
  'get_inStringEvaluation', function(self)
    local i = self._outputStream.length - 1;
    while (i >= 0) do
      local obj = self._outputStream[i];
      local cmd = (function()
        local _hx_1
        if (lua.Boot.__instanceof(obj,ink.runtime.ControlCommand)) then
        _hx_1 = obj; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if ((cmd ~= nil) and (cmd.commandType == 7)) then
        do return true end;
      end;
      i = i - 1;
      end;
    do return false end
  end,
  'PushEvaluationStack', function(self,obj)
    self.evaluationStack:push(obj);
  end,
  'PopEvaluationStack', function(self)
    do return self.evaluationStack:pop() end
  end,
  'PeekEvaluationStack', function(self)
    do return self.evaluationStack[self.evaluationStack.length - 1] end
  end,
  'PopEvaluationStack1', function(self,numberOfObjects)
    if (numberOfObjects > self.evaluationStack.length) then
      _G.error(ink.runtime.SystemException.new("trying to pop too many objects"),0);
    end;
    local popped = self.evaluationStack:slice(self.evaluationStack.length - numberOfObjects,(self.evaluationStack.length - numberOfObjects) + numberOfObjects);
    self.evaluationStack:splice(self.evaluationStack.length - numberOfObjects,numberOfObjects);
    do return popped end
  end,
  'ForceEndFlow', function(self)
    self:set_currentContentObject(nil);
    while (self.callStack:get_canPopThread()) do
      self.callStack:PopThread();
      end;
    while (self.callStack:get_canPop()) do
      self.callStack:Pop();
      end;
    self.currentChoices:clear();
    self.didSafeExit = true;
  end,
  'SetChosenPath', function(self,path)
    self.currentChoices:clear();
    self:set_currentPath(path);
    self.currentTurnIndex = self.currentTurnIndex + 1;
  end,
  'AddError', function(self,message)
    if (self.currentErrors == nil) then
      self.currentErrors = List.new();
    end;
    self.currentErrors:add(message);
  end,
  '_outputStream', nil,
  '_currentRightGlue', nil
  ,'__class__',  ink.runtime.StoryState,
  '__properties__',  {get_inStringEvaluation="get_inStringEvaluation",get_outputStreamContainsContent="get_outputStreamContainsContent",get_outputStreamEndsInNewline="get_outputStreamEndsInNewline",get_currentGlueIndex="get_currentGlueIndex",set_jsonToken="set_jsonToken",get_jsonToken="get_jsonToken",set_inExpressionEvaluation="set_inExpressionEvaluation",get_inExpressionEvaluation="get_inExpressionEvaluation",get_currentText="get_currentText",get_hasError="get_hasError",set_previousContentObject="set_previousContentObject",get_previousContentObject="get_previousContentObject",get_currentContainer="get_currentContainer",set_currentContentObject="set_currentContentObject",get_currentContentObject="get_currentContentObject",set_currentPath="set_currentPath",get_currentPath="get_currentPath",get_outputStream="get_outputStream"}
)

ink.runtime.Value.new = function(val)
  local self = _hx_new(ink.runtime.Value.prototype)
  ink.runtime.Value.super(self,val)
  return self
end
ink.runtime.Value.super = function(self,val)
  ink.runtime.RObject.super(self);
  self.value = val;
end
_hxClasses["ink.runtime.Value"] = ink.runtime.Value
ink.runtime.Value.__name__ = {"ink","runtime","Value"}
ink.runtime.Value.Create = function(val)
  if (lua.Boot.__instanceof(val,Bool)) then
    local b = val;
    val = Std.int((function()
      local _hx_1
      if (b) then
      _hx_1 = 1; else
      _hx_1 = 0; end
      return _hx_1
    end )());
  end;
  if (lua.Boot.__instanceof(val,Int)) then
    do return ink.runtime.IntValue.new(val) end;
  else
    if (lua.Boot.__instanceof(val,Float)) then
      do return ink.runtime.FloatValue.new(val) end;
    else
      if (lua.Boot.__instanceof(val,String)) then
        do return ink.runtime.StringValue.new(val) end;
      else
        if (lua.Boot.__instanceof(val,ink.runtime.Path)) then
          do return ink.runtime.DivertTargetValue.new(val) end;
        end;
      end;
    end;
  end;
  do return nil end;
end
ink.runtime.Value.prototype = _hx_a(
  'value', nil,
  'valueType', nil,
  'isTruthy', nil,
  'Cast', function(self,newType)
    do return nil end
  end,
  'valueObject', nil,
  'Copy', function(self)
    do return ink.runtime.Value.Create(self:get_valueObject()) end
  end,
  'ToString', function(self)
    do return Std.string(self.value) end
  end,
  'toString', function(self)
    do return self:ToString() end
  end,
  'get_valueType', function(self)
    do return self.valueType end
  end,
  'get_isTruthy', function(self)
    do return self.isTruthy end
  end,
  'get_valueObject', function(self)
    do return self.value end
  end
  ,'__class__',  ink.runtime.Value,
  '__properties__',  {get_valueObject="get_valueObject",get_isTruthy="get_isTruthy",get_valueType="get_valueType"}
)
ink.runtime.Value.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.Value.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.Value.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.IntValue.new = function(val)
  local self = _hx_new(ink.runtime.IntValue.prototype)
  ink.runtime.IntValue.super(self,val)
  return self
end
ink.runtime.IntValue.super = function(self,val)
  if (val == nil) then
    val = 0;
  end;
  ink.runtime.Value.super(self,val);
end
_hxClasses["ink.runtime.IntValue"] = ink.runtime.IntValue
ink.runtime.IntValue.__name__ = {"ink","runtime","IntValue"}
ink.runtime.IntValue.prototype = _hx_a(
  'get_valueType', function(self)
    do return 0 end
  end,
  'get_isTruthy', function(self)
    do return self.value ~= 0 end
  end,
  'Cast', function(self,newType)
    if (newType == self:get_valueType()) then
      do return self end;
    end;
    if (newType == 0) then
      do return ink.runtime.IntValue.new(self.value) end;
    end;
    if (newType == 2) then
      do return ink.runtime.StringValue.new("" .. self.value) end;
    end;
    _G.error(ink.runtime.SystemException.new("Unexpected type cast of Value to new ValueType"),0);
  end
  ,'__class__',  ink.runtime.IntValue
)
ink.runtime.IntValue.__super__ = ink.runtime.Value
setmetatable(ink.runtime.IntValue.prototype,{__index=ink.runtime.Value.prototype})
setmetatable(ink.runtime.IntValue.prototype.__properties__,{__index=ink.runtime.Value.prototype.__properties__})

ink.runtime.FloatValue.new = function(val)
  local self = _hx_new(ink.runtime.FloatValue.prototype)
  ink.runtime.FloatValue.super(self,val)
  return self
end
ink.runtime.FloatValue.super = function(self,val)
  ink.runtime.Value.super(self,val);
end
_hxClasses["ink.runtime.FloatValue"] = ink.runtime.FloatValue
ink.runtime.FloatValue.__name__ = {"ink","runtime","FloatValue"}
ink.runtime.FloatValue.prototype = _hx_a(
  'Cast', function(self,newType)
    if (newType == self:get_valueType()) then
      do return self end;
    end;
    if (newType == 1) then
      do return ink.runtime.FloatValue.new(self.value) end;
    end;
    if (newType == 2) then
      do return ink.runtime.StringValue.new("" .. self.value) end;
    end;
    _G.error(ink.runtime.SystemException.new("Unexpected type cast of Value to new ValueType"),0);
  end
  ,'__class__',  ink.runtime.FloatValue
)
ink.runtime.FloatValue.__super__ = ink.runtime.Value
setmetatable(ink.runtime.FloatValue.prototype,{__index=ink.runtime.Value.prototype})
setmetatable(ink.runtime.FloatValue.prototype.__properties__,{__index=ink.runtime.Value.prototype.__properties__})

ink.runtime.StringValue.new = function(val)
  local self = _hx_new(ink.runtime.StringValue.prototype)
  ink.runtime.StringValue.super(self,val)
  return self
end
ink.runtime.StringValue.super = function(self,val)
  if (val == nil) then
    val = "";
  end;
  ink.runtime.Value.super(self,val);
  self.isNewline = self.value == "\n";
  self.isInlineWhitespace = true;
  local _g1 = 0;
  local _g = self.value.length;
  while (_g1 < _g) do
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local c = self.value:charAt(i);
    if ((c ~= " ") and (c ~= "\t")) then
      self.isInlineWhitespace = false;
      break;
    end;
    end;
end
_hxClasses["ink.runtime.StringValue"] = ink.runtime.StringValue
ink.runtime.StringValue.__name__ = {"ink","runtime","StringValue"}
ink.runtime.StringValue.prototype = _hx_a(
  'get_valueType', function(self)
    do return 2 end
  end,
  'get_isTruthy', function(self)
    do return self.value.length > 0 end
  end,
  'isNewline', nil,
  'isInlineWhitespace', nil,
  'isNonWhitespace', nil,
  'get_isNonWhitespace', function(self)
    if (not self.isNewline) then
      do return not self.isInlineWhitespace end;
    else
      do return false end;
    end;
  end,
  'Cast', function(self,newType)
    local tryVal;
    if (newType == self:get_valueType()) then
      do return self end;
    end;
    if (newType == 0) then
      tryVal = Std.parseInt(self.value);
      if (tryVal ~= nil) then
        do return ink.runtime.IntValue.new(tryVal) end;
      else
        do return nil end;
      end;
    end;
    if (newType == 1) then
      tryVal = Std.parseFloat(self.value);
      if (tryVal ~= nil) then
        do return ink.runtime.FloatValue.new(tryVal) end;
      else
        do return nil end;
      end;
    end;
    _G.error(ink.runtime.SystemException.new("Unexpected type cast of Value to new ValueType"),0);
  end
  ,'__class__',  ink.runtime.StringValue,
  '__properties__',  {get_isNonWhitespace="get_isNonWhitespace"}
)
ink.runtime.StringValue.__super__ = ink.runtime.Value
setmetatable(ink.runtime.StringValue.prototype,{__index=ink.runtime.Value.prototype})
setmetatable(ink.runtime.StringValue.prototype.__properties__,{__index=ink.runtime.Value.prototype.__properties__})

ink.runtime.DivertTargetValue.new = function(val)
  local self = _hx_new(ink.runtime.DivertTargetValue.prototype)
  ink.runtime.DivertTargetValue.super(self,val)
  return self
end
ink.runtime.DivertTargetValue.super = function(self,val)
  ink.runtime.Value.super(self,val);
end
_hxClasses["ink.runtime.DivertTargetValue"] = ink.runtime.DivertTargetValue
ink.runtime.DivertTargetValue.__name__ = {"ink","runtime","DivertTargetValue"}
ink.runtime.DivertTargetValue.prototype = _hx_a(
  'get_targetPath', function(self)
    do return self.value end
  end,
  'set_targetPath', function(self,value)
    self.value = value do return self.value end
  end,
  'get_valueType', function(self)
    do return 3 end
  end,
  'get_isTruthy', function(self)
    _G.error(ink.runtime.SystemException.new("Shouldn't be checking the truthiness of a divert target"),0);
  end,
  'Cast', function(self,newType)
    if (newType == self:get_valueType()) then
      do return self end;
    end;
    _G.error(ink.runtime.SystemException.new("Unexpected type cast of Value to new ValueType"),0);
  end,
  'ToString', function(self)
    do return "DivertTargetValue(" .. Std.string(self:get_targetPath()) .. ")" end
  end
  ,'__class__',  ink.runtime.DivertTargetValue,
  '__properties__',  {set_targetPath="set_targetPath",get_targetPath="get_targetPath"}
)
ink.runtime.DivertTargetValue.__super__ = ink.runtime.Value
setmetatable(ink.runtime.DivertTargetValue.prototype,{__index=ink.runtime.Value.prototype})
setmetatable(ink.runtime.DivertTargetValue.prototype.__properties__,{__index=ink.runtime.Value.prototype.__properties__})

ink.runtime.VariablePointerValue.new = function(variableName,contextIndex)
  local self = _hx_new(ink.runtime.VariablePointerValue.prototype)
  ink.runtime.VariablePointerValue.super(self,variableName,contextIndex)
  return self
end
ink.runtime.VariablePointerValue.super = function(self,variableName,contextIndex)
  if (contextIndex == nil) then
    contextIndex = -1;
  end;
  ink.runtime.Value.super(self,variableName);
  self.contextIndex = contextIndex;
end
_hxClasses["ink.runtime.VariablePointerValue"] = ink.runtime.VariablePointerValue
ink.runtime.VariablePointerValue.__name__ = {"ink","runtime","VariablePointerValue"}
ink.runtime.VariablePointerValue.prototype = _hx_a(
  'get_variableName', function(self)
    do return self.value end
  end,
  'set_variableName', function(self,value)
    self.value = value do return self.value end
  end,
  'get_valueType', function(self)
    do return 4 end
  end,
  'get_isTruthy', function(self)
    _G.error(ink.runtime.SystemException.new("Shouldn't be checking the truthiness of a variable pointer"),0);
  end,
  'contextIndex', nil,
  'Cast', function(self,newType)
    if (newType == self:get_valueType()) then
      do return self end;
    end;
    _G.error(ink.runtime.SystemException.new("Unexpected type cast of Value to new ValueType"),0);
  end,
  'ToString', function(self)
    do return "VariablePointerValue(" .. self:get_variableName() .. ")" end
  end,
  'Copy', function(self)
    do return ink.runtime.VariablePointerValue.new(self:get_variableName(),self.contextIndex) end
  end
  ,'__class__',  ink.runtime.VariablePointerValue,
  '__properties__',  {set_variableName="set_variableName",get_variableName="get_variableName"}
)
ink.runtime.VariablePointerValue.__super__ = ink.runtime.Value
setmetatable(ink.runtime.VariablePointerValue.prototype,{__index=ink.runtime.Value.prototype})
setmetatable(ink.runtime.VariablePointerValue.prototype.__properties__,{__index=ink.runtime.Value.prototype.__properties__})

ink.runtime.VariableAssignment.new = function(variableName,isNewDeclaration)
  local self = _hx_new(ink.runtime.VariableAssignment.prototype)
  ink.runtime.VariableAssignment.super(self,variableName,isNewDeclaration)
  return self
end
ink.runtime.VariableAssignment.super = function(self,variableName,isNewDeclaration)
  if (isNewDeclaration == nil) then
    isNewDeclaration = false;
  end;
  ink.runtime.RObject.super(self);
  self.variableName = variableName;
  self.isNewDeclaration = isNewDeclaration;
end
_hxClasses["ink.runtime.VariableAssignment"] = ink.runtime.VariableAssignment
ink.runtime.VariableAssignment.__name__ = {"ink","runtime","VariableAssignment"}
ink.runtime.VariableAssignment.prototype = _hx_a(
  'variableName', nil,
  'isNewDeclaration', nil,
  'isGlobal', nil,
  'toString', function(self)
    do return "VarAssign to " .. self.variableName end
  end
  ,'__class__',  ink.runtime.VariableAssignment
)
ink.runtime.VariableAssignment.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.VariableAssignment.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.VariableAssignment.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.VariableReference.new = function()
  local self = _hx_new(ink.runtime.VariableReference.prototype)
  ink.runtime.VariableReference.super(self)
  return self
end
ink.runtime.VariableReference.super = function(self)
  ink.runtime.RObject.super(self);
end
_hxClasses["ink.runtime.VariableReference"] = ink.runtime.VariableReference
ink.runtime.VariableReference.__name__ = {"ink","runtime","VariableReference"}
ink.runtime.VariableReference.create = function(name)
  local me = ink.runtime.VariableReference.new();
  me.name = name;
  do return me end;
end
ink.runtime.VariableReference.prototype = _hx_a(
  'name', nil,
  'pathForCount', nil,
  'containerForCount', nil,
  'get_containerForCount', function(self)
    local obj = self:ResolvePath(self.pathForCount);
    if (lua.Boot.__instanceof(obj,ink.runtime.Container)) then
      do return obj end;
    else
      do return nil end;
    end;
  end,
  'get_pathStringForCount', function(self)
    if (self.pathForCount == nil) then
      do return nil end;
    end;
    do return self:CompactPathString(self.pathForCount) end
  end,
  'set_pathStringForCount', function(self,value)
    if (value == nil) then
      self.pathForCount = nil;
    else
      self.pathForCount = ink.runtime.Path.createFromString(value);
    end;
    do return value end
  end,
  'toString', function(self)
    if (self.name ~= nil) then
      do return "var(" .. self.name .. ")" end;
    else
      local pathStr = self:get_pathStringForCount();
      do return "read_count(" .. pathStr .. ")" end;
    end;
  end
  ,'__class__',  ink.runtime.VariableReference,
  '__properties__',  {set_pathStringForCount="set_pathStringForCount",get_pathStringForCount="get_pathStringForCount",get_containerForCount="get_containerForCount"}
)
ink.runtime.VariableReference.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.VariableReference.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.VariableReference.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.VariablesState.new = function(callStack)
  local self = _hx_new(ink.runtime.VariablesState.prototype)
  ink.runtime.VariablesState.super(self,callStack)
  return self
end
ink.runtime.VariablesState.super = function(self,callStack)
  self.variableChangedEventCallbacks = _hx_tab_array({ }, 0);
  self._globalVariables = haxe.ds.StringMap.new();
  self._callStack = callStack;
end
_hxClasses["ink.runtime.VariablesState"] = ink.runtime.VariablesState
ink.runtime.VariablesState.__name__ = {"ink","runtime","VariablesState"}
ink.runtime.VariablesState.__interfaces__ = {ink.runtime.IProxy}
ink.runtime.VariablesState.prototype = _hx_a(
  'variableChangedEvent', nil,
  'variableChangedEventCallbacks', nil,
  'ObserveVariableChange', function(self,callback)
    local _gthis = self;
    if (self.variableChangedEvent == nil) then
      self.variableChangedEvent = function(self,variableName,newValue)
        local _g = 0;
        local _g1 = _gthis.variableChangedEventCallbacks;
        while (_g < _g1.length) do
          local cb = _g1[_g];
          _g = _g + 1;
          cb(variableName,newValue);
          end;
       end;
    end;
    self.variableChangedEventCallbacks:push(callback);
  end,
  'get_batchObservingVariableChanges', function(self)
    do return self._batchObservingVariableChanges end
  end,
  'set_batchObservingVariableChanges', function(self,value)
    self._batchObservingVariableChanges = value;
    if (value) then
      self._changedVariables = ink.runtime.HashSetString.new();
    else
      if (self._changedVariables ~= nil) then
        local variableName = self._changedVariables:keys();
        while (variableName:hasNext()) do
          local variableName1 = variableName:next();
          local this1 = self._globalVariables;
          local currentValue = this1.v[variableName1];
          self:variableChangedEvent(variableName1,currentValue);
          end;
      end;
      self._changedVariables = nil;
    end;
    do return self._batchObservingVariableChanges end
  end,
  '_batchObservingVariableChanges', nil,
  'field', function(self,variableName)
    local varContents;
    local map = self._globalVariables;
    varContents = map.v[variableName];
    if (varContents ~= nil) then
      do return ((function()
        local _hx_1
        if (lua.Boot.__instanceof(varContents,ink.runtime.Value)) then
        _hx_1 = varContents; else
        _hx_1 = nil; end
        return _hx_1
      end )()):get_valueObject() end;
    else
      do return nil end;
    end;
  end,
  'setField', function(self,variableName,value)
    local val = ink.runtime.Value.Create(value);
    if (val == nil) then
      if (value == nil) then
        _G.error(ink.runtime.StoryException.new("Cannot pass null to VariableState"),0);
      else
        _G.error(ink.runtime.StoryException.new("Invalid value passed to VariableState: " .. Std.string(value)),0);
      end;
    end;
    self:SetGlobal(variableName,val);
  end,
  'CopyFrom', function(self,varState)
    self._globalVariables = ink.runtime.LibUtil.cloneStrMap(varState._globalVariables);
    self.variableChangedEvent = varState.variableChangedEvent;
    if (varState:get_batchObservingVariableChanges() ~= self:get_batchObservingVariableChanges()) then
      if (varState:get_batchObservingVariableChanges()) then
        self._batchObservingVariableChanges = true;
        self._changedVariables = varState._changedVariables:clone();
      else
        self._batchObservingVariableChanges = false;
        self._changedVariables = nil;
      end;
    end;
  end,
  'get_jsonToken', function(self)
    do return ink.runtime.Json.DictionaryRuntimeObjsToJObject(self._globalVariables) end
  end,
  'set_jsonToken', function(self,value)
    self._globalVariables = ink.runtime.Json.JObjectToDictionaryRuntimeObjs(value) do return self._globalVariables end
  end,
  'GetVariableWithName', function(self,name)
    do return self:_GetVariableWithName(name,-1) end
  end,
  '_GetVariableWithName', function(self,name,contextIndex)
    local varValue = self:GetRawVariableWithName(name,contextIndex);
    local varPointer = (function()
      local _hx_1
      if (lua.Boot.__instanceof(varValue,ink.runtime.VariablePointerValue)) then
      _hx_1 = varValue; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (varPointer ~= nil) then
      varValue = self:ValueAtVariablePointer(varPointer);
    end;
    do return varValue end
  end,
  'GetRawVariableWithName', function(self,name,contextIndex)
    local varValue = nil;
    if ((contextIndex == 0) or (contextIndex == -1)) then
      local map = self._globalVariables;
      varValue = map.v[name];
      if (varValue ~= nil) then
        do return varValue end;
      end;
    end;
    varValue = self._callStack:GetTemporaryVariableWithName(name,contextIndex);
    if (varValue == nil) then
      _G.error(ink.runtime.SystemException.new("RUNTIME ERROR: Variable '" .. name .. "' could not be found in context '" .. contextIndex .. "'. This shouldn't be possible so is a bug in the ink engine. Please try to construct a minimal story that reproduces the problem and report to inkle, thank you!"),0);
    end;
    do return varValue end
  end,
  'ValueAtVariablePointer', function(self,pointer)
    do return self:_GetVariableWithName(pointer:get_variableName(),pointer.contextIndex) end
  end,
  'Assign', function(self,varAss,value)
    local name = varAss.variableName;
    local contextIndex = -1;
    local setGlobal = false;
    if (varAss.isNewDeclaration) then
      setGlobal = varAss.isGlobal;
    else
      local this1 = self._globalVariables;
      setGlobal = (this1.k[name] or false);
    end;
    if (varAss.isNewDeclaration) then
      local varPointer = (function()
        local _hx_1
        if (lua.Boot.__instanceof(value,ink.runtime.VariablePointerValue)) then
        _hx_1 = value; else
        _hx_1 = nil; end
        return _hx_1
      end )();
      if (varPointer ~= nil) then
        local fullyResolvedVariablePointer = self:ResolveVariablePointer(varPointer);
        value = fullyResolvedVariablePointer;
      end;
    else
      local existingPointer = nil;
      while (true) do
        local obj = self:GetRawVariableWithName(name,contextIndex);
        if (lua.Boot.__instanceof(obj,ink.runtime.VariablePointerValue)) then
          existingPointer = obj;
        else
          existingPointer = nil;
        end;
        if (existingPointer ~= nil) then
          name = existingPointer:get_variableName();
          contextIndex = existingPointer.contextIndex;
          setGlobal = contextIndex == 0;
        end;
        if (not (existingPointer ~= nil)) then
          break;
        end;
        end;
    end;
    if (setGlobal) then
      self:SetGlobal(name,value);
    else
      self._callStack:SetTemporaryVariable(name,value,varAss.isNewDeclaration,contextIndex);
    end;
  end,
  'SetGlobal', function(self,variableName,value)
    local oldValue = nil;
    local map = self._globalVariables;
    oldValue = map.v[variableName];
    local _this = self._globalVariables;
    _this.v[variableName] = value;
    _this.k[variableName] = true;
    if ((self.variableChangedEvent ~= nil) and not value:Equals(oldValue)) then
      if (self:get_batchObservingVariableChanges()) then
        self._changedVariables:add(variableName);
      else
        self:variableChangedEvent(variableName,value);
      end;
    end;
  end,
  'ResolveVariablePointer', function(self,varPointer)
    local contextIndex = varPointer.contextIndex;
    if (contextIndex == -1) then
      contextIndex = self:GetContextIndexOfVariableNamed(varPointer:get_variableName());
    end;
    local valueOfVariablePointedTo = self:GetRawVariableWithName(varPointer:get_variableName(),contextIndex);
    local doubleRedirectionPointer = (function()
      local _hx_1
      if (lua.Boot.__instanceof(valueOfVariablePointedTo,ink.runtime.VariablePointerValue)) then
      _hx_1 = valueOfVariablePointedTo; else
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (doubleRedirectionPointer ~= nil) then
      do return doubleRedirectionPointer end;
    else
      do return ink.runtime.VariablePointerValue.new(varPointer:get_variableName(),contextIndex) end;
    end;
  end,
  'GetContextIndexOfVariableNamed', function(self,varName)
    local this1 = self._globalVariables;
    if ((this1.k[varName] or false)) then
      do return 0 end;
    end;
    do return self._callStack:get_currentElementIndex() end
  end,
  '_globalVariables', nil,
  '_callStack', nil,
  '_changedVariables', nil
  ,'__class__',  ink.runtime.VariablesState,
  '__properties__',  {set_jsonToken="set_jsonToken",get_jsonToken="get_jsonToken",set_batchObservingVariableChanges="set_batchObservingVariableChanges",get_batchObservingVariableChanges="get_batchObservingVariableChanges"}
)

ink.runtime.VoidObj.new = function()
  local self = _hx_new(ink.runtime.VoidObj.prototype)
  ink.runtime.VoidObj.super(self)
  return self
end
ink.runtime.VoidObj.super = function(self)
  ink.runtime.RObject.super(self);
end
_hxClasses["ink.runtime.VoidObj"] = ink.runtime.VoidObj
ink.runtime.VoidObj.__name__ = {"ink","runtime","VoidObj"}
ink.runtime.VoidObj.prototype = _hx_a(

  '__class__',  ink.runtime.VoidObj
)
ink.runtime.VoidObj.__super__ = ink.runtime.RObject
setmetatable(ink.runtime.VoidObj.prototype,{__index=ink.runtime.RObject.prototype})
setmetatable(ink.runtime.VoidObj.prototype.__properties__,{__index=ink.runtime.RObject.prototype.__properties__})

ink.runtime.js.JSProxyTrap.new = function()
  local self = _hx_new(ink.runtime.js.JSProxyTrap.prototype)
  ink.runtime.js.JSProxyTrap.super(self)
  return self
end
ink.runtime.js.JSProxyTrap.super = function(self)
end
_hxClasses["ink.runtime.js.JSProxyTrap"] = ink.runtime.js.JSProxyTrap
ink.runtime.js.JSProxyTrap.__name__ = {"ink","runtime","js","JSProxyTrap"}
ink.runtime.js.JSProxyTrap.prototype = _hx_a(
  'get', function(self,target,property)
    do return target:field(property) end
  end,
  'set', function(self,target,property,value)
    target:setField(property,value);
  end
  ,'__class__',  ink.runtime.js.JSProxyTrap
)

lua.Boot.new = {}
_hxClasses["lua.Boot"] = lua.Boot
lua.Boot.__name__ = {"lua","Boot"}
lua.Boot._ = nil
lua.Boot.__unhtml = function(s)
  do return s:split("&"):join("&amp;"):split("<"):join("&lt;"):split(">"):join("&gt;") end;
end
lua.Boot.isClass = function(o)
  if (_G.type(o) ~= "table") then
    do return false end;
  else
    do return o.__name__ end;
  end;
end
lua.Boot.isEnum = function(e)
  if (_G.type(e) ~= "table") then
    do return false end;
  else
    do return e.__ename__ end;
  end;
end
lua.Boot.getClass = function(o)
  if (lua.Boot.__instanceof(o,Array)) then
    do return Array end;
  else
    local cl = o.__class__;
    if (cl ~= nil) then
      do return cl end;
    else
      do return nil end;
    end;
  end;
end
lua.Boot.__instanceof = function(o,cl)
  if (cl == nil) then
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then
    do return lua.Boot.isArray(o) end;
  elseif (cl1) == Bool then
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then
    do return true end;
  elseif (cl1) == Float then
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then
    if (_G.type(o) == "number") then
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then
    do return _G.type(o) == "table" end;
  elseif (cl1) == lua.Thread then
    do return _G.type(o) == "thread" end;
  elseif (cl1) == lua.UserData then
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then
    if (lua.Boot.extendsOrImplements(lua.Boot.getClass(o),cl)) then
      do return true end;
    end;
    if ((function()
      local _hx_1
      if (cl == Class) then
      _hx_1 = o.__name__ ~= nil; else
      _hx_1 = false; end
      return _hx_1
    end )()) then
      do return true end;
    end;
    if ((function()
      local _hx_2
      if (cl == Enum) then
      _hx_2 = o.__ename__ ~= nil; else
      _hx_2 = false; end
      return _hx_2
    end )()) then
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
lua.Boot.isArray = function(o)
  if (_G.type(o) == "table") then
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.inheritsFrom = function(o,cl)
  while ((_G.getmetatable(o) ~= nil) and (_G.getmetatable(o).__index ~= nil)) do
    if (_G.getmetatable(o).__index == cl.prototype) then
      do return true end;
    end;
    o = _G.getmetatable(o).__index;
    end;
  do return false end;
end
lua.Boot.__cast = function(o,t)
  if (lua.Boot.__instanceof(o,t)) then
    do return o end;
  else
    _G.error("Cannot cast " .. Std.string(o) .. " to " .. Std.string(t),0);
  end;
end
lua.Boot.printEnum = function(o,s)
  if (o.length == 2) then
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClass = function(c,s)
  do return "{" .. lua.Boot.printClassRec(c,"",s) .. "}" end;
end
lua.Boot.printClassRec = function(c,result,s)
  if (result == nil) then
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s)
  if (s == nil) then
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then
    do return tostring(o) end;
  elseif (_g1) == "function" then
    do return "<function>" end;
  elseif (_g1) == "nil" then
    do return "null" end;
  elseif (_g1) == "number" then
    if (o == _G.math.huge) then
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then
        do return "-Infinity" end;
      else
        if (o ~= o) then
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then
    do return o end;
  elseif (_g1) == "table" then
    if (o.__enum__ ~= nil) then
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then
          local o2 = o;
          if (s.length > 5) then
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do
              local f1 = f:next();
              if (first) then
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then
    do return "<thread>" end;
  elseif (_g1) == "userdata" then
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.defArray = function(tab,length)
  if (length == nil) then
    length = _hx_table.maxn(tab) + 1;
  end;
  do return _hx_tab_array(tab,length) end;
end
lua.Boot.tableToObject = function(t)
  do return _hx_o(t) end;
end
lua.Boot.dateStr = function(date)
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return date:getFullYear() .. "-" .. ((function()
    local _hx_1
    if (m < 10) then
    _hx_1 = "0" .. m; else
    _hx_1 = "" .. m; end
    return _hx_1
  end )()) .. "-" .. ((function()
    local _hx_2
    if (d < 10) then
    _hx_2 = "0" .. d; else
    _hx_2 = "" .. d; end
    return _hx_2
  end )()) .. " " .. ((function()
    local _hx_3
    if (h < 10) then
    _hx_3 = "0" .. h; else
    _hx_3 = "" .. h; end
    return _hx_3
  end )()) .. ":" .. ((function()
    local _hx_4
    if (mi < 10) then
    _hx_4 = "0" .. mi; else
    _hx_4 = "" .. mi; end
    return _hx_4
  end )()) .. ":" .. ((function()
    local _hx_5
    if (s < 10) then
    _hx_5 = "0" .. s; else
    _hx_5 = "" .. s; end
    return _hx_5
  end )()) end;
end
lua.Boot.clamp = function(x)
  do return _hx_bit_clamp(x) end;
end
lua.Boot.strDate = function(s)
  local _g = s.length;
  local _g1 = _g;
  if (_g1) == 8 then
    local k = s:split(":");
    local t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=0,month=1,day=1,hour=_G.tonumber(k[0]),min=_G.tonumber(k[1]),sec=_G.tonumber(k[2])}));
    local d = _hx_e();
    _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = t / 1000;
    d.d = _G.os.date("*t",Std.int(d.t));
    do return d end;
  elseif (_g1) == 10 then
    local k1 = s:split("-");
    do return Date.new(_G.tonumber(k1[0]),_G.tonumber(k1[1]) - 1,_G.tonumber(k1[2]),0,0,0) end;
  elseif (_g1) == 19 then
    local k2 = s:split(" ");
    local y = k2[0]:split("-");
    local t1 = k2[1]:split(":");
    local tmp = _G.tonumber(y[1]) - 1;
    local tmp1 = _G.tonumber(y[2]);
    local tmp2 = _G.tonumber(t1[0]);
    local tmp3 = _G.tonumber(t1[1]);
    local tmp4 = _G.tonumber(t1[2]);
    do return Date.new(y[0],tmp,tmp1,tmp2,tmp3,tmp4) end;else
  _G.error("Invalid date format : " .. s,0); end;
end
lua.Boot.extendsOrImplements = function(cl1,cl2)
  if ((cl1 == nil) or (cl2 == nil)) then
    do return false end;
  else
    if (cl1 == cl2) then
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then
        local intf = cl1.__interfaces__;
        local _g1 = 1;
        local _g = _hx_table.maxn(intf) + 1;
        while (_g1 < _g) do
          _g1 = _g1 + 1;
          local i = _g1 - 1;
          if (lua.Boot.extendsOrImplements(intf[i],cl2)) then
            do return true end;
          end;
          end;
      end;
    end;
  end;
  do return lua.Boot.extendsOrImplements(cl1.__super__,cl2) end;
end
lua.Boot.shellEscapeCmd = function(cmd,args)
  if (args ~= nil) then
    local _g = Sys.systemName();
    if (_g == "Windows") then
      local _g1 = _hx_tab_array({ }, 0);
      local _g11 = 0;
      local _g2 = _hx_tab_array({[0]=StringTools.replace(cmd,"/","\\") }, 1):concat(args);
      while (_g11 < _g2.length) do
        local a = _g2[_g11];
        _g11 = _g11 + 1;
        _g1:push(StringTools.quoteWinArg(a,true));
        end;
      cmd = _g1:join(" ");
    else
      cmd = _hx_tab_array({[0]=cmd }, 1):concat(args):map(StringTools.quoteUnixArg):join(" ");
    end;
  end;
  do return cmd end;
end
lua.Boot.tempFile = function()
  local _g = Sys.systemName();
  if (_g == "Windows") then
    do return haxe.io.Path.join(_hx_tab_array({[0]=_G.os.getenv("TMP"), _G.os.tmpname() }, 2)) end;
  else
    do return _G.os.tmpname() end;
  end;
end
lua.Boot.fieldIterator = function(o)
  local tbl = (function()
    local _hx_1
    if (o.__fields__ ~= nil) then
    _hx_1 = o.__fields__; else
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val)
    while (lua.Boot.hiddenFields[val] ~= nil) do
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self)
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function(self)
    do return cur_val ~= nil end;
  end}) end;
end
lua.Boot.systemName = function()
  local os = nil;
  if ((jit ~= nil) and (jit.os ~= nil)) then
    os = jit.os;
    os = os:toLowerCase();
  else
    local popen_status = false;
    local popen_result = nil;
    popen_status, popen_result = pcall(_G.io.popen, '');
    if (popen_status) then
      os = _G.io.popen("uname -s","r"):read("*l"):toLowerCase();
    else
      os = _G.os.getenv("OS"):toLowerCase();
    end;
  end;
  local k = lua.Boot.os_patterns:keys();
  while (k:hasNext()) do
    local k1 = k:next();
    local _g = 0;
    local this1 = lua.Boot.os_patterns;
    local _g1 = this1.v[k1];
    while (_g < _g1.length) do
      local p = _g1[_g];
      _g = _g + 1;
      if (_G.string.match(os,p) ~= nil) then
        do return k1 end;
      end;
      end;
    end;
  do return nil end;
end

lua.UserData.new = {}
_hxClasses["lua.UserData"] = lua.UserData
lua.UserData.__name__ = {"lua","UserData"}

lua.HaxeIterator.new = function(f)
  local self = _hx_new(lua.HaxeIterator.prototype)
  lua.HaxeIterator.super(self,f)
  return self
end
lua.HaxeIterator.super = function(self,f)
  self.f = _hx_funcToField(f);
  self.state = f();
end
_hxClasses["lua.HaxeIterator"] = lua.HaxeIterator
lua.HaxeIterator.__name__ = {"lua","HaxeIterator"}
lua.HaxeIterator.prototype = _hx_a(
  'state', nil,
  'f', nil,
  'next', function(self)
    local ret = self.state;
    self.state = self:f();
    do return ret end
  end,
  'hasNext', function(self)
    do return self.state ~= nil end
  end
  ,'__class__',  lua.HaxeIterator
)

lua._Io.IoType_Impl_.new = {}
_hxClasses["lua._Io.IoType_Impl_"] = lua._Io.IoType_Impl_
lua._Io.IoType_Impl_.__name__ = {"lua","_Io","IoType_Impl_"}
lua._Io.IoType_Impl_.toString = function(this1)
  do return this1 end;
end

lua.Lib.new = {}
_hxClasses["lua.Lib"] = lua.Lib
lua.Lib.__name__ = {"lua","Lib"}
lua.Lib.println = function(v)
  _G.print(Std.string(v));
end
lua.Lib.print = function(v)
  _G.io.write(Std.string(v));
  _G.io.flush();
end
lua.Lib.tableToArray = function(t,length)
  local length1 = length;
  if (length1 == nil) then
    length1 = _hx_table.maxn(t) + 1;
  end;
  do return _hx_tab_array(t,length1) end;
end
lua.Lib.tableToObject = function(t)
  do return _hx_o(t) end;
end
lua.Lib.patternQuote = function(str)
  do return _G.string.gsub(str,"[%(%)%.%%%+%-%*%?%[%]%^%$]",function(c)
    do return "%" .. c end;
  end) end;
end
lua.Lib.defArray = function(tab,length)
  local length1 = length;
  if (length1 == nil) then
    length1 = _hx_table.maxn(tab) + 1;
  end;
  do return _hx_tab_array(tab,length1) end;
end
lua.Lib.fillArray = function(itr)
  local i = nil;
  local ret = _hx_tab_array({ }, 0);
  while (true) do
    i = itr();
    if (not (i ~= nil)) then
      break;
    end;
    ret:push(i);
    end;
  do return ret end;
end
lua.Lib.isShellAvailable = function()
  local ret = _G.os.execute();
  if (_G.type(ret) == "bool") then
    do return ret end;
  else
    do return ret ~= 0 end;
  end;
end

lua._NativeIterator.NativeIterator_Impl_.new = {}
_hxClasses["lua._NativeIterator.NativeIterator_Impl_"] = lua._NativeIterator.NativeIterator_Impl_
lua._NativeIterator.NativeIterator_Impl_.__name__ = {"lua","_NativeIterator","NativeIterator_Impl_"}
lua._NativeIterator.NativeIterator_Impl_._new = function(f)
  local this1 = f;
  do return this1 end;
end
lua._NativeIterator.NativeIterator_Impl_.fromF = function(f)
  do return lua._NativeIterator.NativeIterator_Impl_._new(f) end;
end
lua._NativeIterator.NativeIterator_Impl_.toIterator = function(this1)
  do return lua.HaxeIterator.new(this1) end;
end

lua.Thread.new = {}
_hxClasses["lua.Thread"] = lua.Thread
lua.Thread.__name__ = {"lua","Thread"}

sys.FileSystem.new = {}
_hxClasses["sys.FileSystem"] = sys.FileSystem
sys.FileSystem.__name__ = {"sys","FileSystem"}
sys.FileSystem.exists = function(path)
  if (path == nil) then
    do return false end;
  else
    local f = _G.io.open(path);
    if (f == nil) then
      do return false end;
    else
      f:close();
      do return true end;
    end;
  end;
end
sys.FileSystem.rename = function(path,newPath)
  local _hx_1_ret_success, _hx_1_ret_message = _G.os.rename(path,newPath);
  if (not _hx_1_ret_success) then
    _G.error(_hx_1_ret_message,0);
  end;
end
sys.FileSystem.stat = function(path)
  local _hx_1_ls_result, _hx_1_ls_message = lua.lib.luv.fs.FileSystem.fs_stat(path);
  if (_hx_1_ls_result == nil) then
    _G.error(_hx_1_ls_message,0);
  end;
  local l = _hx_1_ls_result;
  local l1 = l.gid;
  local l2 = l.uid;
  local l3 = l.rdev;
  local l4 = l.size;
  local l5 = l.nlink;
  local t = l.mtime.sec + (l.mtime.nsec / 1000000);
  local d = _hx_e();
  _G.setmetatable(d,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t",Std.int(d.t));
  local l6 = l.mode;
  local l7 = l.ino;
  local l8 = l.dev;
  local t1 = l.ctime.sec + (l.ctime.nsec / 1000000);
  local d1 = _hx_e();
  _G.setmetatable(d1,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d1.t = t1 / 1000;
  d1.d = _G.os.date("*t",Std.int(d1.t));
  local t2 = l.atime.sec + (l.atime.nsec / 1000000);
  local d2 = _hx_e();
  _G.setmetatable(d2,_hx_o({__fields__={__index=true},__index=Date.prototype}));
  d2.t = t2 / 1000;
  d2.d = _G.os.date("*t",Std.int(d2.t));
  do return _hx_o({__fields__={gid=true,uid=true,rdev=true,size=true,nlink=true,mtime=true,mode=true,ino=true,dev=true,ctime=true,atime=true},gid=l1,uid=l2,rdev=l3,size=l4,nlink=l5,mtime=d,mode=l6,ino=l7,dev=l8,ctime=d1,atime=d2}) end;
end
sys.FileSystem.fullPath = function(relPath)
  local pwd = lua.lib.luv.Misc.cwd();
  do return haxe.io.Path.normalize((function()
    local _hx_1
    if (pwd == nil) then
    _hx_1 = relPath; else
    _hx_1 = haxe.io.Path.join(_hx_tab_array({[0]=pwd, relPath }, 2)); end
    return _hx_1
  end )()) end;
end
sys.FileSystem.absolutePath = function(relPath)
  local pwd = lua.lib.luv.Misc.cwd();
  if (pwd == nil) then
    do return relPath end;
  end;
  do return haxe.io.Path.join(_hx_tab_array({[0]=pwd, relPath }, 2)) end;
end
sys.FileSystem.deleteFile = function(path)
  local _hx_1_ret_success, _hx_1_ret_message = _G.os.remove(path);
  if (not _hx_1_ret_success) then
    _G.error(_hx_1_ret_message,0);
  end;
end
sys.FileSystem.readDirectory = function(path)
  local scandir = lua.lib.luv.fs.FileSystem.fs_scandir(path);
  local itr = function()
    local next = lua.lib.luv.fs.FileSystem.fs_scandir_next(scandir);
    do return next end;
  end;
  do return lua.Lib.fillArray(itr) end;
end
sys.FileSystem.isDirectory = function(path)
  local result = lua.lib.luv.fs.FileSystem.fs_stat(path);
  if (result == nil) then
    do return false end;
  else
    do return result.type == "directory" end;
  end;
end
sys.FileSystem.deleteDirectory = function(path)
  local _hx_1_ret_result, _hx_1_ret_message = lua.lib.luv.fs.FileSystem.fs_rmdir(path);
  if (_hx_1_ret_result == nil) then
    _G.error(_hx_1_ret_message,0);
  end;
end
sys.FileSystem.createDirectory = function(path)
  local path1 = haxe.io.Path.addTrailingSlash(path);
  local _p = nil;
  local parts = _hx_tab_array({ }, 0);
  while (true) do
    _p = haxe.io.Path.directory(path1);
    if (not (path1 ~= _p)) then
      break;
    end;
    parts:unshift(path1);
    path1 = _p;
    end;
  local _g = 0;
  while (_g < parts.length) do
    local part = parts[_g];
    _g = _g + 1;
    if (((part:charCodeAt(part.length - 1) ~= 58) and not sys.FileSystem.exists(part)) and not lua.lib.luv.fs.FileSystem.fs_mkdir(part,511)) then
      _G.error("Could not create directory:" .. part,0);
    end;
    end;
end

sys.io.FileInput.new = function(f)
  local self = _hx_new(sys.io.FileInput.prototype)
  sys.io.FileInput.super(self,f)
  return self
end
sys.io.FileInput.super = function(self,f)
  if (f == nil) then
    _G.error("Invalid filehandle : " .. Std.string(f),0);
  end;
  self:set_bigEndian(lua.Boot.platformBigEndian);
  self.f = f;
  self._eof = false;
end
_hxClasses["sys.io.FileInput"] = sys.io.FileInput
sys.io.FileInput.__name__ = {"sys","io","FileInput"}
sys.io.FileInput.prototype = _hx_a(
  'f', nil,
  '_eof', nil,
  'seek', function(self,p,pos)
    local arg;
    local pos1 = pos[1];
    if (pos1) == 0 then
      arg = "set";
    elseif (pos1) == 1 then
      arg = "cur";
    elseif (pos1) == 2 then
      arg = "end"; end;
    self._eof = false;
    self.f:seek(arg,p);
    do return end
  end,
  'tell', function(self)
    do return self.f:seek() end
  end,
  'eof', function(self)
    do return self._eof end
  end,
  'readByte', function(self)
    local byte = self.f:read(1);
    if (byte == nil) then
      self._eof = true;
      _G.error(haxe.io.Eof.new(),0);
    end;
    do return _G.string.byte(byte) end
  end,
  'close', function(self)
    self.f:close();
  end,
  'readAll', function(self,bufsize)
    if (bufsize == nil) then
      bufsize = 16384;
    end;
    local buf = haxe.io.Bytes.alloc(bufsize);
    local total = haxe.io.BytesBuffer.new();
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function()

        while (true) do
          local len = self:readBytes(buf,0,bufsize);
          if (len == 0) then
            break;
          end;
          if ((len < 0) or (len > buf.length)) then
            _G.error(haxe.io.Error.OutsideBounds,0);
          end;
          local b1 = total.b;
          local b2 = buf.b;
          local _g1 = 0;
          local _g = len;
          while (_g1 < _g) do
            _g1 = _g1 + 1;
            local i = _g1 - 1;
            total.b:push(b2[i]);
            end;
          end;
       return _hx_expected_result end)
     if not _hx_status then
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Eof) ) then
        local e = _hx_1
        self._eof = true;
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    do return total:getBytes() end
  end
  ,'__class__',  sys.io.FileInput
)
sys.io.FileInput.__super__ = haxe.io.Input
setmetatable(sys.io.FileInput.prototype,{__index=haxe.io.Input.prototype})
setmetatable(sys.io.FileInput.prototype.__properties__,{__index=haxe.io.Input.prototype.__properties__})

sys.io.FileOutput.new = function(f)
  local self = _hx_new(sys.io.FileOutput.prototype)
  sys.io.FileOutput.super(self,f)
  return self
end
sys.io.FileOutput.super = function(self,f)
  if (f == nil) then
    _G.error("Invalid filehandle : " .. Std.string(f),0);
  end;
  self.f = f;
end
_hxClasses["sys.io.FileOutput"] = sys.io.FileOutput
sys.io.FileOutput.__name__ = {"sys","io","FileOutput"}
sys.io.FileOutput.prototype = _hx_a(
  'f', nil,
  'seek', function(self,p,pos)
    local arg;
    local pos1 = pos[1];
    if (pos1) == 0 then
      arg = "set";
    elseif (pos1) == 1 then
      arg = "cur";
    elseif (pos1) == 2 then
      arg = "end"; end;
    self.f:seek(arg,p);
    do return end
  end,
  'tell', function(self)
    do return self.f:seek() end
  end,
  'writeByte', function(self,c)
    self.f:write(_G.string.char(c));
  end,
  'close', function(self)
    self.f:close();
  end
  ,'__class__',  sys.io.FileOutput
)
sys.io.FileOutput.__super__ = haxe.io.Output
setmetatable(sys.io.FileOutput.prototype,{__index=haxe.io.Output.prototype})
setmetatable(sys.io.FileOutput.prototype.__properties__,{__index=haxe.io.Output.prototype.__properties__})
_hxClasses["sys.io.FileSeek"] = sys.io.FileSeek;
_hxClasses["sys.io.FileSeek"] = { __ename__ = {"sys","io","FileSeek"}, __constructs__ = _hx_tab_array({[0]="SeekBegin","SeekCur","SeekEnd"},3)}
sys.io.FileSeek = _hxClasses["sys.io.FileSeek"];
sys.io.FileSeek.SeekBegin = _hx_tab_array({[0]="SeekBegin",0,__enum__ = sys.io.FileSeek},2)
rawset(sys.io.FileSeek.SeekBegin, 'toString', _estr)

sys.io.FileSeek.SeekCur = _hx_tab_array({[0]="SeekCur",1,__enum__ = sys.io.FileSeek},2)
rawset(sys.io.FileSeek.SeekCur, 'toString', _estr)

sys.io.FileSeek.SeekEnd = _hx_tab_array({[0]="SeekEnd",2,__enum__ = sys.io.FileSeek},2)
rawset(sys.io.FileSeek.SeekEnd, 'toString', _estr)

sys.io.FileSeek.__empty_constructs__ = _hx_tab_array({[0] = sys.io.FileSeek.SeekBegin,sys.io.FileSeek.SeekCur,sys.io.FileSeek.SeekEnd}, 3)

sys.io.Process.new = function(cmd,args)
  local self = _hx_new(sys.io.Process.prototype)
  sys.io.Process.super(self,cmd,args)
  return self
end
sys.io.Process.super = function(self,cmd,args)
  local _gthis = self;
  local _stdout = lua.lib.luv.Pipe.new_pipe(false);
  local _stderr = lua.lib.luv.Pipe.new_pipe(false);
  local _stdin = lua.lib.luv.Pipe.new_pipe(false);
  self.stdout = sys.io.ProcessInput.new(_stdout);
  self.stderr = sys.io.ProcessInput.new(_stderr);
  self.stdin = sys.io.ProcessOutput.new(_stdin);
  local stdio = ({_stdin,_stdout,_stderr});
  local opt = _hx_o({__fields__={args=true,stdio=true},args=sys.io.Process.setArgs(cmd,args),stdio=stdio});
  local _hx_1_p_handle, _hx_1_p_pid = lua.lib.luv.Process.spawn(sys.io.Process._shell,opt,function(code,signal)
    _gthis._code = code;
  end);
  if (_hx_1_p_handle == nil) then
    _G.error(_hx_1_p_pid,0);
  end;
  self._pid = _hx_1_p_pid;
  self._handle = _hx_1_p_handle;
end
_hxClasses["sys.io.Process"] = sys.io.Process
sys.io.Process.__name__ = {"sys","io","Process"}
sys.io.Process.setArgs = function(cmd,args)
  local pargs = ({});
  local idx = 1;
  if (sys.FileSystem.exists(cmd)) then
    cmd = "\"" .. cmd .. "\"";
  end;
  local all = _hx_tab_array({[0]=cmd }, 1);
  if (args ~= nil) then
    local _g = 0;
    while (_g < args.length) do
      local a = args[_g];
      _g = _g + 1;
      all:push(sys.io.Process.argQuote(a));
      end;
  end;
  if (Sys.systemName() == "Windows") then
    idx = idx + 1;
    pargs[idx - 1] = "/s";
    idx = idx + 1;
    pargs[idx - 1] = "/c";
    idx = idx + 1;
    pargs[idx - 1] = all:join(" ");
  else
    idx = idx + 1;
    pargs[idx - 1] = "-c";
    idx = idx + 1;
    pargs[idx - 1] = all:join(" ");
  end;
  do return pargs end;
end
sys.io.Process.prototype = _hx_a(
  '_pid', nil,
  '_handle', nil,
  '_code', nil,
  'closef', nil,
  'stdout', nil,
  'stderr', nil,
  'stdin', nil,
  'getPid', function(self)
    do return self._pid end
  end,
  'close', function(self)
    self.stdout:close();
    self.stdin:close();
    self.stderr:close();
    self._handle:close();
  end,
  'exitCode', function(self,block)
    if (block == nil) then
      block = true;
    end;
    if (not block) then
      do return self._code end;
    end;
    while (self._handle:is_active()) do
      lua.lib.luv.Loop.run();
      end;
    do return self._code end
  end,
  'kill', function(self)
    self._handle:kill("sigterm");
  end
  ,'__class__',  sys.io.Process
)

sys.io.ProcessInput.new = function(pipe)
  local self = _hx_new(sys.io.ProcessInput.prototype)
  sys.io.ProcessInput.super(self,pipe)
  return self
end
sys.io.ProcessInput.super = function(self,pipe)
  self.b = pipe;
end
_hxClasses["sys.io.ProcessInput"] = sys.io.ProcessInput
sys.io.ProcessInput.__name__ = {"sys","io","ProcessInput"}
sys.io.ProcessInput.prototype = _hx_a(
  'b', nil,
  'buf', nil,
  'idx', nil,
  'readByte', function(self)
    local _gthis = self;
    local err_str = nil;
    if ((self.buf == nil) or (self.idx >= self.buf.length)) then
      self.buf = nil;
      self.idx = 0;
      local pending = true;
      self.b:read_start(function(err,chunk)
        if (chunk ~= nil) then
          _gthis.buf = chunk;
        end;
        if (err ~= nil) then
          err_str = err;
        end;
        pending = false;
      end);
      while (pending) do
        lua.lib.luv.Loop.run();
        end;
    end;
    if (self.buf == nil) then
      _G.error(haxe.io.Eof.new(),0);
    end;
    if (err_str ~= nil) then
      _G.error(err_str,0);
    end;
    local code = self.buf:charCodeAt((function()
    local _hx_obj = self;
    local _hx_fld = 'idx';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)());
    do return code end
  end,
  'readAll', function(self,bufsize)
    if (bufsize == nil) then
      bufsize = 16384;
    end;
    local buf = haxe.io.Bytes.alloc(bufsize);
    local total = haxe.io.BytesBuffer.new();
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function()

        while (true) do
          local len = self:readBytes(buf,0,bufsize);
          if (len ~= 0) then
            if ((len < 0) or (len > buf.length)) then
              _G.error(haxe.io.Error.OutsideBounds,0);
            end;
            local b1 = total.b;
            local b2 = buf.b;
            local _g1 = 0;
            local _g = len;
            while (_g1 < _g) do
              _g1 = _g1 + 1;
              local i = _g1 - 1;
              total.b:push(b2[i]);
              end;
          end;
          if (len < bufsize) then
            break;
          end;
          end;
       return _hx_expected_result end)
     if not _hx_status then
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Eof) ) then
        local e = _hx_1
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    do return total:getBytes() end
  end
  ,'__class__',  sys.io.ProcessInput
)
sys.io.ProcessInput.__super__ = haxe.io.Input
setmetatable(sys.io.ProcessInput.prototype,{__index=haxe.io.Input.prototype})
setmetatable(sys.io.ProcessInput.prototype.__properties__,{__index=haxe.io.Input.prototype.__properties__})

sys.io.ProcessOutput.new = function(pipe)
  local self = _hx_new(sys.io.ProcessOutput.prototype)
  sys.io.ProcessOutput.super(self,pipe)
  return self
end
sys.io.ProcessOutput.super = function(self,pipe)
  self.b = pipe;
  self:set_bigEndian(lua.Boot.platformBigEndian);
end
_hxClasses["sys.io.ProcessOutput"] = sys.io.ProcessOutput
sys.io.ProcessOutput.__name__ = {"sys","io","ProcessOutput"}
sys.io.ProcessOutput.prototype = _hx_a(
  'b', nil,
  'writeByte', function(self,c)
    self.b:write(_G.string.char(c));
  end,
  'close', function(self)
    self.b:close();
  end
  ,'__class__',  sys.io.ProcessOutput
)
sys.io.ProcessOutput.__super__ = haxe.io.Output
setmetatable(sys.io.ProcessOutput.prototype,{__index=haxe.io.Output.prototype})
setmetatable(sys.io.ProcessOutput.prototype.__properties__,{__index=haxe.io.Output.prototype.__properties__})
_hx_bit_clamp = function(v)
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end
pcall(require, 'bit')
if bit then
  _hx_bit = bit
elseif bit32 then
  local _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
else
_hx_bit = {}
_hx_bit.shr = function(...) return 0 end
_hx_bit.arshift = function(...) return 0 end
_hx_bit.band = function(...) return 0 end
_hx_bit.bor = function(...) return 0 end
end
local _hx_string_mt = _G.getmetatable('') or {}
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  EReg.FLAGS = lua.lib.lrexlib.Rex.flags()
  StringTools.winMetaCharacters = _hx_tab_array({[0]=32, 40, 41, 37, 33, 94, 34, 60, 62, 38, 124, 10, 13, 44, 59 }, 15)
  haxe.ds.ObjectMap.count = 0
  haxe.io.FPHelper.i64tmp = (function()
    local _hx_1

    local this1 = haxe._Int64.___Int64.new(haxe._Int32.Int32_Impl_.shr(0,31),0);

    _hx_1 = this1;
    return _hx_1
  end )()
  haxe.io.FPHelper.LN2 = 0.6931471805599453
  ink.random.Limits.INT8_MIN = -128
  ink.random.Limits.INT8_MAX = 127
  ink.random.Limits.UINT8_MAX = 255
  ink.random.Limits.INT16_MIN = -32768
  ink.random.Limits.INT16_MAX = 32767
  ink.random.Limits.UINT16_MAX = 65535
  ink.random.Limits.INT32_MIN = -2147483648
  ink.random.Limits.INT32_MAX = 2147483647
  ink.random.Limits.UINT32_MAX = -1
  ink.random.Limits.INT_BITS = 32
  ink.random.Limits.FLOAT_MAX = 3.4028234663852886e+38
  ink.random.Limits.FLOAT_MIN = -3.4028234663852886e+38
  ink.random.Limits.DOUBLE_MAX = 1.7976931348623157e+308
  ink.random.Limits.DOUBLE_MIN = -1.7976931348623157e+308
  ink.runtime.CountFlags.Visits = 1
  ink.runtime.CountFlags.Turns = 2
  ink.runtime.CountFlags.CountStartOnly = 4
  ink.runtime.Json._controlCommandNames = (function()
    local _hx_2

    ink.runtime.Json._controlCommandNames = Array.new();

    ink.runtime.Json._controlCommandNames[0] = "ev";

    ink.runtime.Json._controlCommandNames[1] = "out";

    ink.runtime.Json._controlCommandNames[2] = "/ev";

    ink.runtime.Json._controlCommandNames[3] = "du";

    ink.runtime.Json._controlCommandNames[4] = "pop";

    ink.runtime.Json._controlCommandNames[5] = "~ret";

    ink.runtime.Json._controlCommandNames[6] = "->->";

    ink.runtime.Json._controlCommandNames[7] = "str";

    ink.runtime.Json._controlCommandNames[8] = "/str";

    ink.runtime.Json._controlCommandNames[9] = "nop";

    ink.runtime.Json._controlCommandNames[10] = "choiceCnt";

    ink.runtime.Json._controlCommandNames[11] = "turns";

    ink.runtime.Json._controlCommandNames[12] = "visit";

    ink.runtime.Json._controlCommandNames[13] = "seq";

    ink.runtime.Json._controlCommandNames[14] = "thread";

    ink.runtime.Json._controlCommandNames[15] = "done";

    ink.runtime.Json._controlCommandNames[16] = "end";

    local len = 17;

    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (ink.runtime.Json._controlCommandNames[i] == nil) then
        _G.error(ink.runtime.SystemException.new("Control command not accounted for in serialisation"),0);
      end;
      end;

    _hx_2 = ink.runtime.Json._controlCommandNames;
    return _hx_2
  end )()
  ink.runtime.NativeFunctionCall.Add = "+"
  ink.runtime.NativeFunctionCall.Subtract = "-"
  ink.runtime.NativeFunctionCall.Divide = "/"
  ink.runtime.NativeFunctionCall.Multiply = "*"
  ink.runtime.NativeFunctionCall.Mod = "%"
  ink.runtime.NativeFunctionCall.Negate = "~"
  ink.runtime.NativeFunctionCall.Equal = "=="
  ink.runtime.NativeFunctionCall.Greater = ">"
  ink.runtime.NativeFunctionCall.Less = "<"
  ink.runtime.NativeFunctionCall.GreaterThanOrEquals = ">="
  ink.runtime.NativeFunctionCall.LessThanOrEquals = "<="
  ink.runtime.NativeFunctionCall.NotEquals = "!="
  ink.runtime.NativeFunctionCall.Not = "!"
  ink.runtime.NativeFunctionCall.And = "&&"
  ink.runtime.NativeFunctionCall.Or = "||"
  ink.runtime.NativeFunctionCall.Min = "MIN"
  ink.runtime.NativeFunctionCall.Max = "MAX"
  ink.runtime.Path.parentId = "^"
  ink.runtime.Story.inkVersionCurrent = 12
  ink.runtime.Story.inkVersionMinimumCompatible = 12
  ink.runtime.StoryState.kInkSaveStateVersion = 4
  ink.runtime.StoryState.kMinCompatibleLoadVersion = 4
  lua.Boot._fid = 0
  lua.Boot.platformBigEndian = _G.string.byte(_G.string.dump(function()
  end),7) > 0
  lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  lua.Boot.os_patterns = (function()
    local _hx_3

    local _g = haxe.ds.StringMap.new();

    _g.v["Windows"] = _hx_tab_array({[0]="windows", "^mingw", "^cygwin" }, 3);
    _g.k["Windows"] = true;

    _g.v["Linux"] = _hx_tab_array({[0]="linux" }, 1);
    _g.k["Linux"] = true;

    _g.v["Mac"] = _hx_tab_array({[0]="mac", "darwin" }, 2);
    _g.k["Mac"] = true;

    _g.v["BSD"] = _hx_tab_array({[0]="bsd$" }, 1);
    _g.k["BSD"] = true;

    _g.v["Solaris"] = _hx_tab_array({[0]="SunOS" }, 1);
    _g.k["Solaris"] = true;

    _hx_3 = _g;
    return _hx_3
  end )()
  lua._Io.IoType_Impl_.File = "file"
  lua._Io.IoType_Impl_.ClosedFile = "closed file"
  lua._Io.IoType_Impl_.NotAFile = nil
  sys.io.Process.argQuote = (function()
    local _hx_4
    if (Sys.systemName() == "Windows") then
    _hx_4 = function(x)
      do return StringTools.quoteWinArg(x,true) end;
    end; else
    _hx_4 = StringTools.quoteUnixArg; end
    return _hx_4
  end )()
  sys.io.Process._shell = (function()
    local _hx_5
    if (Sys.systemName() == "Window") then
    _hx_5 = "cmd.exe"; else
    _hx_5 = "/bin/bash"; end
    return _hx_5
  end )()

  if (lua.lib.lrexlib.Rex == nil) then
    _G.error("Rex is missing.  Please install lrexlib-pcre.",0);
  end;
  String.prototype.__class__ = (function()
  _hxClasses.String = String; return _hxClasses.String end)();
  String.__name__ = ({"String"});
  _hxClasses.Array = Array;
  Array.__name__ = ({"Array"});
end

function _hx_iterator(o)  if ( lua.Boot.__instanceof(o, Array) ) then return function() return HxOverrides.iter(o) end elseif (typeof(o.iterator) == 'function') then return  _hx_bind(o,o.iterator) else return  o.iterator end end
_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end
_hx_staticToInstance = function (tab)
  return setmetatable({}, {
    __index = function(t,k)
      if type(rawget(tab,k)) == 'function' then
	return function(self,...)
	  return rawget(tab,k)(...)
	end
      else
	return rawget(tab,k)
      end
    end
  })
end
_hx_funcToField = function(f)
  if type(f) == 'function' then
    return function(self,...)
      return f(...)
    end
  else
    return f
  end
end
_G.math.randomseed(_G.os.time());
_hx_print = print or (function() end)
_hx_apply_self = function(self, f, ...)
  return self[f](self,...)
end
_hx_box_mr = function(x,nt)
   res = _hx_o({__fields__={}})
   for i,v in ipairs(nt) do
     res[v] = x[i]
   end
   return res
end
_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;
_hx_static_init();
--InkRuntime.main()
return _hx_exports
